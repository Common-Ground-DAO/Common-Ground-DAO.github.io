This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-11T10:16:57.476Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
_data/
  wiki_metadata.json
  wiki_relationships.json
_includes/
  footer.html
  head.html
  header.html
  home_updates.html
  treasury_search.html
  treasury_sidebar.html
  wiki_article_list.html
  wiki_breadcrumb.html
  wiki_breadcrumbs.html
  wiki_graph.html
  wiki_metadata.html
  wiki_nav.html
  wiki_navigation.html
  wiki_related.html
  wiki_search.html
  wiki_sidebar.html
_layouts/
  base.html
  default.html
  home.html
  page.html
  stakeholder.html
  treasury.html
  wiki.html
_pages/
  about.md
  community.md
  governance.md
  press.md
  treasury-v2.md
_plugins/
  search_index_generator.rb
_stakeholders/
_wiki/
  categories/
    concepts/
      index.html
    glossary/
      index.html
    mechanics/
      index.html
    primitives/
      index.html
    index.md
  concepts/
    community-hyperstructures.md
    community-sovereignty.md
    composite-primitives.md
    convergence.md
    coordination.md
    cross-chain-interoperability.md
    ecosystem-economics.md
    game-of-chains.md
    identity-authentication.md
    meta-protocol.md
    onchain-culture.md
    protocol-discovery.md
    shared-coordination-resources.md
    token-distribution-mechanisms.md
    trust-networks.md
    value-capture-models.md
    zero-friction-onboarding.md
  glossary/
    antifragility.md
    cg-token.md
    coinship.md
    common-dollar.md
    credible-neutrality.md
    duna.md
    harberger-tax.md
    hyperobject.md
    intent-origination.md
    memecoin.md
    sce.md
    smart-contract-standards.md
    spark.md
  mechanics/
    degen-value-capture.md
    regen-value-redistribution.md
  primitives/
    ai-hiveminds.md
    community-token.md
    discourse-graphs.md
    ecosystem.md
    hypercerts.md
    onchain-community.md
    passport.md
    subjectivocracy.md
  stakeholders/
  tag/
    community/
      index.html
    coordination/
      index.html
    infrastructure/
      index.html
    web3/
      index.html
assets/
  css/
    base.css
    components.css
    layout.css
    main.css
    templates.css
    treasury-v2.css
    utilities.css
    wiki-components.css
    wiki.css
  images/
    logo-black-transparent.svg
  js/
    mobile-nav.js
    network-viz.js
    price-updates.js
    treasury-cost-charts.js
    treasury-cost-processor.js
    treasury-v2-data.js
    treasury-v2.js
    treasury.charts.js
    treasury.js
    vendor-entry.js
    vendor.bundle.js
    vendor.bundle.js.map
    wiki-graph.js
    wiki-preview.js
client/
  src/
    hooks/
      usePriceUpdates.js
docs/
  analysis.md
  css-assessment-2.md
  css-assessment-3.md
  css-assessment.md
  template-assessment.md
  template-final-assessment.md
  template-improvements-roadmap.md
  template-styles-analysis.md
  templates-css-status.md
downloads/
wiki/
  index.html
_config.development.yml
_config.yml
.gitignore
CNAME
Gemfile
index.md
package.json
README.md
rollup.config.js
search-index.json
site.webmanifest
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_data/wiki_metadata.json">
{
  "categories": {
    "glossary": {
      "name": "Glossary",
      "description": "Core terms and concepts in the Common Ground ecosystem",
      "entries": ["hyperobject", "coinship", "memecoin", "game_of_chains"]
    },
    "mechanics": {
      "name": "Mechanics",
      "description": "Key mechanisms and processes that drive the ecosystem",
      "entries": ["degen_value_capture", "regen_value_redistribution"]
    },
    "primitives": {
      "name": "Primitives",
      "description": "Fundamental building blocks of the Common Ground system",
      "entries": ["community_token", "hypercerts", "discourse_graphs", "ai_hiveminds", "subjectivocracy"]
    },
    "patterns": {
      "name": "Design Patterns",
      "description": "Recurring solutions and architectural patterns",
      "entries": ["token_distribution", "value_capture", "coordination_mechanisms"]
    },
    "infrastructure": {
      "name": "Infrastructure",
      "description": "Technical components and system architecture",
      "entries": ["smart_contracts", "token_standards", "governance_systems"]
    },
    "governance": {
      "name": "Governance",
      "description": "Decision-making and coordination frameworks",
      "entries": ["voting_mechanisms", "proposal_systems", "treasury_management"]
    }
  },
  "clusters": {
    "theory": {
      "name": "Theoretical Concepts",
      "description": "Foundational ideas and frameworks",
      "color": "#4A90E2"
    },
    "mechanics": {
      "name": "System Mechanics",
      "description": "Operational mechanisms and processes",
      "color": "#50E3C2"
    },
    "primitives": {
      "name": "System Primitives",
      "description": "Core building blocks and components",
      "color": "#F5A623"
    },
    "implementation": {
      "name": "Implementation",
      "description": "Technical implementation details",
      "color": "#D0021B"
    },
    "community": {
      "name": "Community",
      "description": "Social and community aspects",
      "color": "#7ED321"
    },
    "economics": {
      "name": "Economics",
      "description": "Economic models and incentives",
      "color": "#9013FE"
    }
  },
  "difficulty_levels": {
    "beginner": {
      "name": "Beginner",
      "description": "Fundamental concepts accessible to newcomers",
      "color": "#7ED321"
    },
    "intermediate": {
      "name": "Intermediate",
      "description": "Concepts requiring some background knowledge",
      "color": "#F5A623"
    },
    "advanced": {
      "name": "Advanced",
      "description": "Complex concepts requiring deep understanding",
      "color": "#D0021B"
    }
    },
  "relationship_types": {
    "implements": {
      "name": "Implements",
      "description": "A implements or realizes B",
      "inverse": "implemented_by",
      "color": "#4A90E2"
    },
    "enables": {
      "name": "Enables",
      "description": "A enables or facilitates B",
      "inverse": "enabled_by",
      "color": "#7ED321"
    },
    "type_of": {
      "name": "Type Of",
      "description": "A is a type or kind of B",
      "inverse": "has_type",
      "color": "#9013FE"
    },
    "utilizes": {
      "name": "Utilizes",
      "description": "A uses or leverages B",
      "inverse": "utilized_by",
      "color": "#F5A623"
    },
    "mechanism": {
      "name": "Mechanism",
      "description": "A is a mechanism of B",
      "inverse": "has_mechanism",
      "color": "#50E3C2"
    },
    "component": {
      "name": "Component",
      "description": "A is a component of B",
      "inverse": "has_component",
      "color": "#D0021B"
    },
    "participates_in": {
      "name": "Participates In",
      "description": "A participates in or is part of B",
      "inverse": "has_participant",
      "color": "#B8E986"
    },
    "counterpart": {
      "name": "Counterpart",
      "description": "A is a complementary concept to B",
      "inverse": "counterpart",
      "color": "#9B9B9B"
    },
    "operates_within": {
      "name": "Operates Within",
      "description": "A operates or functions within B",
      "inverse": "contains",
      "color": "#4A4A4A"
    },
    "extends": {
      "name": "Extends",
      "description": "A extends or builds upon B",
      "inverse": "extended_by",
      "color": "#C7B299"
    },
    "influences": {
      "name": "Influences",
      "description": "A influences or affects B",
      "inverse": "influenced_by",
      "color": "#BD10E0"
    },
    "governs": {
      "name": "Governs",
      "description": "A governs or controls B",
      "inverse": "governed_by",
      "color": "#9B51E0"
    },
    "interacts_with": {
      "name": "Interacts With",
      "description": "A interacts with B",
      "inverse": "interacts_with",
      "color": "#50E3C2"
    },
    "depends_on": {
      "name": "Depends On",
      "description": "A depends on B",
      "inverse": "required_by",
      "color": "#F5A623"
    }
  },
  "learning_paths": {
    "token_mechanics": {
      "name": "Token Mechanics",
      "description": "Understanding token-based coordination",
      "sequence": ["community_token", "coinship", "memecoin", "game_of_chains"]
    },
    "value_systems": {
      "name": "Value Systems",
      "description": "Understanding value capture and redistribution",
      "sequence": ["degen_value_capture", "regen_value_redistribution", "hypercerts"]
    },
    "governance_path": {
      "name": "Governance Systems",
      "description": "Understanding community governance and decision making",
      "sequence": ["community_token", "voting_mechanisms", "proposal_systems", "treasury_management"]
    },
    "technical_path": {
      "name": "Technical Implementation",
      "description": "Understanding the technical architecture",
      "sequence": ["smart_contracts", "token_standards", "governance_systems"]
    },
    "community_path": {
      "name": "Community Building",
      "description": "Understanding community development and engagement",
      "sequence": ["coinship", "memecoin", "coordination_mechanisms"]
    }
  },
  "tags": {
    "technical": {
      "name": "Technical",
      "description": "Technical implementation details",
      "color": "#4A90E2"
    },
    "social": {
      "name": "Social",
      "description": "Social and community aspects",
      "color": "#7ED321"
    },
    "economic": {
      "name": "Economic",
      "description": "Economic models and incentives",
      "color": "#F5A623"
    },
    "governance": {
      "name": "Governance",
      "description": "Governance and decision making",
      "color": "#9013FE"
    },
    "infrastructure": {
      "name": "Infrastructure",
      "description": "System infrastructure and architecture",
      "color": "#D0021B"
    }
  },
  "status": {
    "draft": {
      "name": "Draft",
      "description": "Initial draft of the concept",
      "color": "#9B9B9B"
    },
    "review": {
      "name": "Under Review",
      "description": "Being reviewed by the community",
      "color": "#F5A623"
    },
    "stable": {
      "name": "Stable",
      "description": "Well-established concept",
      "color": "#7ED321"
    },
    "evolving": {
      "name": "Evolving",
      "description": "Concept is actively evolving",
      "color": "#4A90E2"
    }
  }
}
</file>

<file path="_data/wiki_relationships.json">
{
  "nodes": {
    "hyperobject": {
      "id": "hyperobject",
      "title": "Hyperobject",
      "category": "glossary",
      "cluster": "theory",
      "difficulty": "advanced",
      "coordinates": {
        "x": 0.1,
        "y": 0.1
      }
    },
    "coinship": {
      "id": "coinship",
      "title": "Coinship",
      "category": "glossary",
      "cluster": "theory",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.3,
        "y": 0.1
      }
    },
    "memecoin": {
      "id": "memecoin",
      "title": "Memecoin",
      "category": "glossary",
      "cluster": "theory",
      "difficulty": "beginner",
      "coordinates": {
        "x": 0.5,
        "y": 0.1
      }
    },
    "game_of_chains": {
      "id": "game_of_chains",
      "title": "Game of Chains",
      "category": "glossary",
      "cluster": "theory",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.7,
        "y": 0.1
      }
    },
    "degen_value_capture": {
      "id": "degen_value_capture",
      "title": "Degen Value Capture",
      "category": "mechanics",
      "cluster": "mechanics",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.2,
        "y": 0.3
      }
    },
    "regen_value_redistribution": {
      "id": "regen_value_redistribution",
      "title": "Regen Value Redistribution",
      "category": "mechanics",
      "cluster": "mechanics",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.4,
        "y": 0.3
      }
    },
    "voting_mechanisms": {
      "id": "voting_mechanisms",
      "title": "Voting Mechanisms",
      "category": "governance",
      "cluster": "implementation",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.6,
        "y": 0.3
      }
    },
    "proposal_systems": {
      "id": "proposal_systems",
      "title": "Proposal Systems",
      "category": "governance",
      "cluster": "implementation",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.8,
        "y": 0.3
      }
    },
    "treasury_management": {
      "id": "treasury_management",
      "title": "Treasury Management",
      "category": "governance",
      "cluster": "implementation",
      "difficulty": "advanced",
      "coordinates": {
        "x": 0.3,
        "y": 0.5
      }
    },
    "token_distribution": {
      "id": "token_distribution",
      "title": "Token Distribution",
      "category": "patterns",
      "cluster": "mechanics",
      "difficulty": "intermediate",
      "coordinates": {
        "x": 0.5,
        "y": 0.5
      }
    },
    "coordination_mechanisms": {
      "id": "coordination_mechanisms",
      "title": "Coordination Mechanisms",
      "category": "patterns",
      "cluster": "mechanics",
      "difficulty": "advanced",
      "coordinates": {
        "x": 0.7,
        "y": 0.5
      }
    }
  },
  "edges": [
    {
      "source": "hyperobject",
      "target": "community_hyperstructures",
      "type": "implements",
      "weight": 0.9
    },
    {
      "source": "hyperobject",
      "target": "coordination",
      "type": "enables",
      "weight": 0.8
    },
    {
      "source": "coinship",
      "target": "community_token",
      "type": "implements",
      "weight": 0.9
    },
    {
      "source": "coinship",
      "target": "degen_value_capture",
      "type": "utilizes",
      "weight": 0.8
    },
    {
      "source": "coinship",
      "target": "coordination",
      "type": "mechanism",
      "weight": 0.7
    },
    {
      "source": "memecoin",
      "target": "community_token",
      "type": "type_of",
      "weight": 0.9
    },
    {
      "source": "memecoin",
      "target": "coinship",
      "type": "implements",
      "weight": 0.8
    },
    {
      "source": "memecoin",
      "target": "game_of_chains",
      "type": "participates_in",
      "weight": 0.7
    },
    {
      "source": "game_of_chains",
      "target": "memecoin",
      "type": "component",
      "weight": 0.9
    },
    {
      "source": "game_of_chains",
      "target": "degen_value_capture",
      "type": "mechanism",
      "weight": 0.8
    },
    {
      "source": "game_of_chains",
      "target": "regen_value_redistribution",
      "type": "mechanism",
      "weight": 0.8
    },
    {
      "source": "game_of_chains",
      "target": "coinship",
      "type": "implements",
      "weight": 0.7
    },
    {
      "source": "degen_value_capture",
      "target": "community_token",
      "type": "utilizes",
      "weight": 0.9
    },
    {
      "source": "degen_value_capture",
      "target": "regen_value_redistribution",
      "type": "counterpart",
      "weight": 0.9
    },
    {
      "source": "degen_value_capture",
      "target": "ecosystem",
      "type": "operates_within",
      "weight": 0.7
    },
    {
      "source": "regen_value_redistribution",
      "target": "degen_value_capture",
      "type": "counterpart",
      "weight": 0.9
    },
    {
      "source": "regen_value_redistribution",
      "target": "hypercerts",
      "type": "utilizes",
      "weight": 0.8
    },
    {
      "source": "regen_value_redistribution",
      "target": "community_token",
      "type": "implements",
      "weight": 0.7
    },
    {
      "source": "voting_mechanisms",
      "target": "proposal_systems",
      "type": "interacts_with",
      "weight": 0.9
    },
    {
      "source": "proposal_systems",
      "target": "treasury_management",
      "type": "governs",
      "weight": 0.8
    },
    {
      "source": "token_distribution",
      "target": "degen_value_capture",
      "type": "implements",
      "weight": 0.9
    },
    {
      "source": "token_distribution",
      "target": "regen_value_redistribution",
      "type": "implements",
      "weight": 0.9
    },
    {
      "source": "coordination_mechanisms",
      "target": "coinship",
      "type": "enables",
      "weight": 0.8
    },
    {
      "source": "coordination_mechanisms",
      "target": "game_of_chains",
      "type": "implements",
      "weight": 0.9
    },
    {
      "source": "voting_mechanisms",
      "target": "coordination_mechanisms",
      "type": "type_of",
      "weight": 0.7
    },
    {
      "source": "treasury_management",
      "target": "regen_value_redistribution",
      "type": "utilizes",
      "weight": 0.8
    },
    {
      "source": "game_of_chains",
      "target": "token_distribution",
      "type": "influences",
      "weight": 0.8
    },
    {
      "source": "proposal_systems",
      "target": "coordination_mechanisms",
      "type": "extends",
      "weight": 0.7
    }
  ]
}
</file>

<file path="_includes/footer.html">
<footer>
  <div class="container">
    <div class="footer-content">
      <div class="footer-info">
        <a href="/" class="footer-logo">
          <img src="/assets/images/logo-black-transparent.png" alt="Common Ground">
        </a>
        <p>A web3-native messaging and voice chat platform, built as a public good</p>
        <div class="social-links">
          <a href="https://github.com/Common-Ground-DAO" target="_blank" class="social-link">
            <svg viewBox="0 0 24 24" aria-hidden="true" class="social-icon github">
              <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"></path>
            </svg>
          </a>
          <a href="https://app.cg" target="_blank" class="social-link">
            <img src="/assets/images/common-ground.png" alt="Common Ground App" class="social-icon cg">
          </a>
        </div>
      </div>
      <div class="footer-links">
        <h4>DAO</h4>
        <ul>
          <li><a href="/about/">About</a></li>
          <li><a href="/governance/">Governance</a></li>
        </ul>
      </div>
      <div class="footer-links">
        <h4>Resources</h4>
        <ul>
          <li><a href="/wiki/">Wiki</a></li>
          <li><a href="https://app.cg/c/commonground" target="_blank">Community</a></li>
          <li><a href="mailto:ola@dao.cg">Contact</a></li>
        </ul>
      </div>
    </div>
  </div>
</footer>
</file>

<file path="_includes/head.html">
<!-- _includes/head.html -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<!-- Additional SEO or meta tags can be added here -->
</file>

<file path="_includes/header.html">
<header>
  <div class="container">
    <nav>
      <a href="/" class="logo">
        <img src="/assets/images/logo-black-transparent.png" alt="Common Ground">
      </a>
      <button class="burger-menu" aria-label="Toggle navigation menu">☰</button>
      <div class="nav-links">
        <a href="/about/">About</a>
        <a href="/governance/">Governance</a>
        <a href="/wiki/">Wiki</a>
        <a href="https://app.cg/c/commonground" class="button join-button" target="_blank">Community<span class="arrow">↗</span></a>
      </div>
    </nav>
  </div>
</header>
</file>

<file path="_includes/home_updates.html">
<!-- _includes/home_updates.html -->
<section class="home-updates">
  <h2>Latest Updates</h2>
  <p>Latest updates will be displayed here.</p>
  <!-- You can replace this section with dynamic content if desired -->
</section>
</file>

<file path="_includes/treasury_search.html">
<div class="treasury-search">
    <div class="search-input-wrapper">
        <svg class="search-icon" width="16" height="16" viewBox="0 0 16 16">
            <path fill="currentColor" d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
        </svg>
        <input type="text" 
               id="treasury-search-input" 
               class="search-input"
               placeholder="Search treasury..."
               autocomplete="off"
               aria-label="Search treasury">
        <kbd class="search-shortcut">⌘K</kbd>
    </div>
    <div id="treasury-search-results" class="search-results">
        <div class="search-results-header">
            <span id="search-count" class="search-count">0 results</span>
        </div>
        <div class="search-results-list"></div>
        <div class="search-empty-state">
            <p>No results found</p>
        </div>
    </div>
</div>
<style>
.treasury-search {
    position: relative;
    margin-bottom: 1.5rem;
}
.search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}
.search-icon {
    position: absolute;
    left: 0.75rem;
    color: var(--text-secondary);
}
.search-input {
    width: 100%;
    padding: 0.75rem 2.5rem;
    font-size: var(--font-size-base);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    background: var(--background-color);
    transition: all 0.2s ease;
}
.search-input:focus {
    outline: none;
    border-color: var(--brand-color);
    box-shadow: 0 0 0 3px var(--brand-color-light);
}
.search-shortcut {
    position: absolute;
    right: 0.75rem;
    padding: 0.25rem 0.5rem;
    font-size: var(--font-size-xs);
    color: var(--text-secondary);
    background: var(--light-gray);
    border-radius: 0.25rem;
    pointer-events: none;
}
.search-results {
    display: none;
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    max-height: min(500px, calc(100vh - 12rem));
    overflow-y: auto;
    z-index: 100;
}
.search-results.active {
    display: block;
}
.search-results-header {
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid var(--border-color);
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
}
.search-result-item {
    padding: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.1s ease;
}
.search-result-item:last-child {
    border-bottom: none;
}
.search-result-item:hover,
.search-result-item.active {
    background: var(--light-gray);
}
.result-title {
    font-weight: var(--font-weight-medium);
    color: var(--text-color);
    margin-bottom: 0.25rem;
}
.result-category {
    font-size: var(--font-size-xs);
    color: var(--text-secondary);
    background: var(--light-gray);
    padding: 0.125rem 0.375rem;
    border-radius: 1rem;
    display: inline-block;
}
.search-empty-state {
    padding: 1.5rem 0.75rem;
    text-align: center;
    color: var(--text-secondary);
    font-size: var(--font-size-sm);
    display: none;
}
.search-empty-state.active {
    display: block;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('treasury-search-input');
    const searchResults = document.getElementById('treasury-search-results');
    const resultsList = searchResults.querySelector('.search-results-list');
    const searchCount = document.getElementById('search-count');
    const emptyState = searchResults.querySelector('.search-empty-state');
    // Search functionality will be implemented when we have the treasury data structure
    function performSearch(query) {
        // TODO: Implement search across treasury data
        // For now, just show/hide the results container
        if (!query || query.length < 2) {
            searchResults.classList.remove('active');
            return;
        }
        searchResults.classList.add('active');
    }
    // Keyboard shortcut
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchInput.focus();
        }
    });
    // Search input handler
    searchInput.addEventListener('input', function(e) {
        performSearch(e.target.value);
    });
    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('active');
        }
    });
});
</script>
</file>

<file path="_includes/treasury_sidebar.html">
<aside class="treasury-sidebar">
    <nav class="treasury-nav">
        <!-- Search Component -->
        {% include treasury_search.html %}
        <!-- Navigation Sections -->
        <div class="treasury-nav-section">
            <h3>Overview</h3>
            <ul>
                <li>
                    <a href="#metrics" class="nav-link">
                        Metrics
                    </a>
                </li>
                <li>
                    <a href="#components" class="nav-link">
                        Components
                    </a>
                </li>
                <li>
                    <a href="#token-distribution" class="nav-link">
                        Token Distribution
                    </a>
                </li>
            </ul>
        </div>
        <div class="treasury-nav-section">
            <h3>Portfolio</h3>
            <ul>
                <li>
                    <a href="#liquid-assets" class="nav-link">
                        Liquid Assets
                    </a>
                </li>
                <li>
                    <a href="#illiquid-assets" class="nav-link">
                        Illiquid Assets
                    </a>
                </li>
            </ul>
        </div>
        <div class="treasury-nav-section">
            <h3>Costs</h3>
            <ul>
                <li>
                    <a href="#cost-analysis" class="nav-link">
                        Cost Overview
                    </a>
                </li>
            </ul>
        </div>
        <div class="treasury-nav-section">
            <h3>Wallets</h3>
            <ul>
                <li>
                    <a href="#multisig-wallets" class="nav-link">
                        Multisig Wallets
                    </a>
                </li>
            </ul>
        </div>
    </nav>
</aside>
<style>
.treasury-sidebar {
    position: sticky;
    top: 2rem;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border-color) transparent;
}
.treasury-sidebar::-webkit-scrollbar {
    width: 6px;
}
.treasury-sidebar::-webkit-scrollbar-track {
    background: transparent;
}
.treasury-sidebar::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}
.treasury-nav-section {
    margin-bottom: 2rem;
}
.treasury-nav-section h3 {
    font-size: var(--font-size-base);
    color: var(--text-secondary);
    margin-bottom: 1rem;
    font-weight: 600;
}
.treasury-nav-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
}
.treasury-nav-section a {
    display: block;
    padding: 0.5rem;
    color: var(--text-color);
    text-decoration: none;
    border-radius: 0.25rem;
    transition: all 0.2s ease;
}
.treasury-nav-section a:hover {
    background: var(--light-gray);
}
.treasury-nav-section a.active {
    background: var(--primary-light);
    color: var(--primary);
    font-weight: 500;
}
@media (max-width: 768px) {
    .treasury-sidebar {
        position: relative;
        top: 0;
        max-height: none;
        margin-bottom: 2rem;
    }
}
</style>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Handle smooth scrolling for anchor links
    document.querySelectorAll('.nav-link').forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });
    // Handle active state based on scroll position
    const sections = document.querySelectorAll('.dashboard-section');
    const navLinks = document.querySelectorAll('.nav-link');
    function setActiveLink() {
        let currentSection = '';
        sections.forEach(section => {
            const sectionTop = section.offsetTop;
            const sectionHeight = section.clientHeight;
            if (window.scrollY >= (sectionTop - 100)) {
                currentSection = section.id;
            }
        });
        navLinks.forEach(link => {
            link.classList.remove('active');
            if (link.getAttribute('href') === `#${currentSection}`) {
                link.classList.add('active');
            }
        });
    }
    window.addEventListener('scroll', setActiveLink);
    setActiveLink(); // Set initial state
});
</script>
</file>

<file path="_includes/wiki_article_list.html">
{% assign pages = include.pages | sort: "weight" %}
<div class="wiki-grid">
    {% for article in pages %}
    <a href="{{ article.url }}" class="wiki-card">
        <h3>{{ article.title }}</h3>
        <p>{{ article.summary }}</p>
    </a>
    {% endfor %}
</div>
<style>
.wiki-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
}
.wiki-card {
    background: var(--light-gray);
    border-radius: 1rem;
    padding: 2rem;
    text-decoration: none;
    color: inherit;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.wiki-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
}
.wiki-card h3 {
    font-size: var(--font-size-lg);
    color: var(--text-color);
    margin: 0;
}
.wiki-card p {
    color: var(--text-secondary);
    margin: 0;
    flex-grow: 1;
}
</style>
</file>

<file path="_includes/wiki_breadcrumb.html">
{% assign url_parts = page.url | split: '/' %}
{% assign wiki_home = '/wiki/' %}
<nav class="wiki-breadcrumb" aria-label="Breadcrumb">
    <a href="{{ wiki_home }}" class="breadcrumb-home">
        <svg class="home-icon" viewBox="0 0 24 24" width="16" height="16">
            <path fill="currentColor" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        Wiki
    </a>
    {% if url_parts.size > 2 %}
        <span class="breadcrumb-separator">/</span>
        {% if page.category %}
            <a href="{{ wiki_home }}categories/{{ page.category }}/" class="breadcrumb-item">
                {{ page.category | capitalize }}
            </a>
        {% endif %}
        {% unless page.is_category_index or page.is_tag_index %}
            <span class="breadcrumb-separator">/</span>
            <span class="breadcrumb-item current">{{ page.title }}</span>
        {% endunless %}
    {% endif %}
</nav>
<style>
.wiki-breadcrumb {
    display: flex;
    align-items: center;
    padding: 0.75rem;
    background: var(--light-gray);
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    font-size: var(--font-size-sm);
    white-space: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
}
.wiki-breadcrumb a {
    color: var(--text-secondary);
    text-decoration: none;
    display: flex;
    align-items: center;
    gap: 0.25rem;
}
.wiki-breadcrumb a:hover {
    color: var(--brand-color);
}
.breadcrumb-home {
    font-weight: var(--font-weight-medium);
}
.breadcrumb-separator {
    margin: 0 0.5rem;
    color: var(--text-secondary);
    opacity: 0.5;
}
.breadcrumb-item {
    color: var(--text-secondary);
}
.breadcrumb-item.current {
    color: var(--text-color);
    font-weight: var(--font-weight-medium);
}
.home-icon {
    flex-shrink: 0;
}
</style>
</file>

<file path="_includes/wiki_breadcrumbs.html">
{% assign metadata = site.data.wiki_metadata %}
<nav class="wiki-breadcrumbs" aria-label="Breadcrumb">
  <ol>
    <li>
      <a href="/wiki">Wiki</a>
    </li>
    {% if page.category %}
    <li>
      {% assign category = metadata.categories[page.category] %}
      <a href="/wiki/categories/{{ page.category }}">{{ category.name }}</a>
    </li>
    {% endif %}
    {% if page.cluster and page.cluster != page.category %}
    <li>
      {% assign cluster = metadata.clusters[page.cluster] %}
      <a href="/wiki/clusters/{{ page.cluster }}">{{ cluster.name }}</a>
    </li>
    {% endif %}
    <li aria-current="page">
      {{ page.title }}
    </li>
  </ol>
  {% if page.learning_paths %}
  <div class="wiki-context">
    {% for path in page.learning_paths %}
    {% assign path_data = metadata.learning_paths[path] %}
    {% assign path_position = path_data.sequence | find_index: page.slug | plus: 1 %}
    <span class="learning-path-badge" style="background-color: {{ path_data.color }}">
      {{ path_data.name }} ({{ path_position }}/{{ path_data.sequence.size }})
    </span>
    {% endfor %}
  </div>
  {% endif %}
</nav>
</file>

<file path="_includes/wiki_graph.html">
<div class="wiki-graph">
  <div class="wiki-graph-controls">
    <select id="graph-view-mode" class="graph-select">
      <option value="force">Network View</option>
      <option value="tree">Hierarchy View</option>
      <option value="cluster">Cluster View</option>
    </select>
    <div class="graph-legend">
      <div class="legend-item">
        <span class="legend-color" style="background-color: var(--primary-color)"></span>
        <span class="legend-label">Current Page</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: var(--text-color-light)"></span>
        <span class="legend-label">Related Pages</span>
      </div>
      <div class="legend-item">
        <span class="legend-color" style="background-color: var(--border-color)"></span>
        <span class="legend-label">Connections</span>
      </div>
    </div>
  </div>
  <div id="wiki-graph" class="wiki-graph"></div>
</div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
// Graph data preparation
const graphData = {
  nodes: [],
  links: []
};
{% for page in site.wiki %}
graphData.nodes.push({
  id: "{{ page.slug }}",
  title: "{{ page.title }}",
  url: "{{ page.url }}",
  category: "{{ page.category }}",
  isCurrent: "{{ page.url }}" === "{{ page.url }}"
});
{% if page.related_terms %}
{% for related in page.related_terms %}
graphData.links.push({
  source: "{{ page.slug }}",
  target: "{{ related }}",
  type: "related"
});
{% endfor %}
{% endif %}
{% endfor %}
// Initialize force-directed graph
function initForceGraph() {
  const width = document.getElementById('wiki-graph').clientWidth;
  const height = document.getElementById('wiki-graph').clientHeight;
  const simulation = d3.forceSimulation(graphData.nodes)
    .force("link", d3.forceLink(graphData.links).id(d => d.id))
    .force("charge", d3.forceManyBody().strength(-100))
    .force("center", d3.forceCenter(width / 2, height / 2));
  const svg = d3.select("#wiki-graph")
    .append("svg")
    .attr("width", width)
    .attr("height", height);
  const link = svg.append("g")
    .selectAll("line")
    .data(graphData.links)
    .join("line")
    .attr("stroke", "var(--border-color)")
    .attr("stroke-width", 1);
  const node = svg.append("g")
    .selectAll("circle")
    .data(graphData.nodes)
    .join("circle")
    .attr("r", 5)
    .attr("fill", d => d.isCurrent ? "var(--primary-color)" : "var(--text-color-light)")
    .call(drag(simulation));
  node.append("title")
    .text(d => d.title);
  simulation.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);
    node
      .attr("cx", d => d.x)
      .attr("cy", d => d.y);
  });
}
// Initialize hierarchical tree
function initTreeGraph() {
  // Implementation for hierarchical tree view
}
// Initialize cluster view
function initClusterGraph() {
  // Implementation for cluster view
}
// Drag behavior
function drag(simulation) {
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }
  return d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended);
}
// Initialize graph based on selected view mode
function initGraph() {
  const mode = document.getElementById('graph-view-mode').value;
  d3.select("#wiki-graph").selectAll("*").remove();
  switch(mode) {
    case 'force':
      initForceGraph();
      break;
    case 'tree':
      initTreeGraph();
      break;
    case 'cluster':
      initClusterGraph();
      break;
  }
}
// Event listeners
document.getElementById('graph-view-mode').addEventListener('change', initGraph);
window.addEventListener('resize', initGraph);
// Initial render
initGraph();
</script>
</file>

<file path="_includes/wiki_metadata.html">
{% assign metadata = site.data.wiki_metadata %}
<div class="wiki-metadata-grid">
  <!-- Category -->
  <div class="metadata-item">
    <div class="metadata-label">Category</div>
    <div class="metadata-value">
      {% assign category = metadata.categories[page.category] %}
      <span class="tag" style="background-color: {{ metadata.clusters[page.cluster].color }}">
        {{ category.name }}
      </span>
    </div>
  </div>
  <!-- Difficulty -->
  <div class="metadata-item">
    <div class="metadata-label">Difficulty</div>
    <div class="metadata-value">
      {% assign difficulty = metadata.difficulty_levels[page.difficulty] %}
      <span class="tag" style="background-color: {{ difficulty.color }}">
        {{ difficulty.name }}
      </span>
    </div>
  </div>
  <!-- Status -->
  {% if page.status %}
  <div class="metadata-item">
    <div class="metadata-label">Status</div>
    <div class="metadata-value">
      {% assign status = metadata.status[page.status] %}
      <span class="tag" style="background-color: {{ status.color }}">
        {{ status.name }}
      </span>
    </div>
  </div>
  {% endif %}
  <!-- Tags -->
  {% if page.tags %}
  <div class="metadata-item">
    <div class="metadata-label">Tags</div>
    <div class="metadata-value">
      {% for tag in page.tags %}
      {% assign tag_data = metadata.tags[tag] %}
      <span class="tag" style="background-color: {{ tag_data.color }}">
        {{ tag_data.name }}
      </span>
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Prerequisites -->
  {% if page.prerequisites and page.prerequisites.size > 0 %}
  <div class="metadata-item">
    <div class="metadata-label">Prerequisites</div>
    <div class="metadata-value">
      {% for prereq in page.prerequisites %}
      {% assign prereq_page = site.wiki | where: "slug", prereq | first %}
      {% if prereq_page %}
      <a href="{{ prereq_page.url }}" class="wiki-link">{{ prereq_page.title }}</a>
      {% unless forloop.last %} • {% endunless %}
      {% endif %}
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Recommended Next -->
  {% if page.recommended_next and page.recommended_next.size > 0 %}
  <div class="metadata-item">
    <div class="metadata-label">Next Steps</div>
    <div class="metadata-value">
      {% for next in page.recommended_next %}
      {% assign next_page = site.wiki | where: "slug", next | first %}
      {% if next_page %}
      <a href="{{ next_page.url }}" class="wiki-link">{{ next_page.title }}</a>
      {% unless forloop.last %} • {% endunless %}
      {% endif %}
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Sources -->
  {% if page.sources %}
  <div class="metadata-item">
    <div class="metadata-label">Sources</div>
    <div class="metadata-value">
      {% for source in page.sources %}
      <div class="source-item">
        <span class="source-document">{{ source.document }}</span>
        {% if source.section %}
        <span class="source-section">{{ source.section }}</span>
        {% endif %}
        {% if source.quote %}
        <blockquote class="source-quote">{{ source.quote }}</blockquote>
        {% endif %}
      </div>
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Last Updated -->
  <div class="metadata-item">
    <div class="metadata-label">Last Updated</div>
    <div class="metadata-value">
      {{ page.last_updated | date: "%B %d, %Y" }}
    </div>
  </div>
</div>
</file>

<file path="_includes/wiki_nav.html">
{% assign categories = site.data.wiki_metadata.categories %}
<div class="wiki-nav">
  <!-- Search -->
  <div class="wiki-nav-search">
    <input type="text" placeholder="Search wiki..." id="wiki-search-input">
  </div>
  <!-- Navigation Sections -->
  <nav class="wiki-nav-sections">
    <!-- Categories -->
    <div class="wiki-nav-section">
      <h2 class="wiki-nav-title">Categories</h2>
      <ul class="wiki-nav-list">
        {% for category in categories %}
        {% assign cat = category[1] %}
        <li class="wiki-nav-item {% if page.category == category[0] %}active{% endif %}">
          <a href="/wiki/categories/{{ category[0] }}" class="wiki-nav-link">
            {{ cat.name }}
            <span class="wiki-nav-count">{{ cat.entries | size }}</span>
          </a>
        </li>
        {% endfor %}
      </ul>
    </div>
    <!-- Learning Paths -->
    <div class="wiki-nav-section">
      <h2 class="wiki-nav-title">Learning Paths</h2>
      <ul class="wiki-nav-list">
        {% for path in site.data.wiki_metadata.learning_paths %}
        {% assign path_data = path[1] %}
        <li class="wiki-nav-item {% if page.learning_path == path[0] %}active{% endif %}">
          <a href="/wiki/paths/{{ path[0] }}" class="wiki-nav-link">
            {{ path_data.name }}
            <span class="wiki-nav-count">{{ path_data.sequence | size }}</span>
          </a>
        </li>
        {% endfor %}
      </ul>
    </div>
  </nav>
</div>
<script>
document.getElementById('wiki-search-input').addEventListener('input', function(e) {
  const query = e.target.value.toLowerCase();
  // Implement search functionality
  // This will be connected to a search system like Lunr.js
});
</script>
</file>

<file path="_includes/wiki_navigation.html">
{% assign metadata = site.data.wiki_metadata %}
<nav class="wiki-navigation">
  <!-- Previous Page -->
  {% if page.prerequisites.size > 0 %}
  {% assign prev_page = site.wiki | where: "slug", page.prerequisites.last | first %}
  {% endif %}
  {% if prev_page %}
  <a href="{{ prev_page.url }}" class="nav-prev">
    <span class="nav-label">Previous</span>
    <span class="nav-title">{{ prev_page.title }}</span>
    {% if prev_page.summary %}
    <span class="nav-summary">{{ prev_page.summary | truncate: 80 }}</span>
    {% endif %}
  </a>
  {% endif %}
  <!-- Next Page -->
  {% if page.recommended_next.size > 0 %}
  {% assign next_page = site.wiki | where: "slug", page.recommended_next.first | first %}
  {% endif %}
  {% if next_page %}
  <a href="{{ next_page.url }}" class="nav-next">
    <span class="nav-label">Next</span>
    <span class="nav-title">{{ next_page.title }}</span>
    {% if next_page.summary %}
    <span class="nav-summary">{{ next_page.summary | truncate: 80 }}</span>
    {% endif %}
  </a>
  {% endif %}
  <!-- Learning Path Navigation -->
  {% if page.learning_paths %}
  {% for path in page.learning_paths %}
  {% assign path_data = metadata.learning_paths[path] %}
  {% assign current_index = path_data.sequence | find_index: page.slug %}
  {% if current_index > 0 %}
  {% assign path_prev = site.wiki | where: "slug", path_data.sequence[current_index | minus: 1] | first %}
  {% endif %}
  {% assign next_index = current_index | plus: 1 %}
  {% if next_index < path_data.sequence.size %}
  {% assign path_next = site.wiki | where: "slug", path_data.sequence[next_index] | first %}
  {% endif %}
  <div class="path-navigation" style="border-color: {{ path_data.color }}">
    <div class="path-info">
      <span class="path-name">{{ path_data.name }}</span>
      <span class="path-progress">{{ current_index | plus: 1 }}/{{ path_data.sequence.size }}</span>
    </div>
    <div class="path-controls">
      {% if path_prev %}
      <a href="{{ path_prev.url }}" class="path-prev" style="background-color: {{ path_data.color }}">
        Previous: {{ path_prev.title }}
      </a>
      {% endif %}
      {% if path_next %}
      <a href="{{ path_next.url }}" class="path-next" style="background-color: {{ path_data.color }}">
        Next: {{ path_next.title }}
      </a>
      {% endif %}
    </div>
  </div>
  {% endfor %}
  {% endif %}
</nav>
</file>

<file path="_includes/wiki_related.html">
{% assign metadata = site.data.wiki_metadata %}
{% assign relationships = site.data.wiki_relationships %}
<div class="wiki-related">
  <h2>Related Content</h2>
  <!-- Direct Relationships -->
  {% assign direct_relations = relationships.edges | where: "source", page.slug %}
  {% if direct_relations.size > 0 %}
  <div class="related-section">
    <h3>Related Pages</h3>
    <div class="related-grid">
      {% for relation in direct_relations %}
      {% assign target_page = site.wiki | where: "slug", relation.target | first %}
      {% if target_page %}
      <div class="related-item">
        <div class="related-type">
          {% assign relation_type = metadata.relationship_types[relation.type] %}
          <span class="relation-badge" style="background-color: {{ relation_type.color }}">
            {{ relation_type.name }}
          </span>
        </div>
        <a href="{{ target_page.url }}" class="related-link">
          <h4>{{ target_page.title }}</h4>
          {% if target_page.summary %}
          <p>{{ target_page.summary | truncate: 120 }}</p>
          {% endif %}
        </a>
      </div>
      {% endif %}
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Same Category -->
  {% assign category_pages = site.wiki | where: "category", page.category %}
  {% if category_pages.size > 1 %}
  <div class="related-section">
    <h3>More in {{ metadata.categories[page.category].name }}</h3>
    <div class="related-grid">
      {% for cat_page in category_pages %}
      {% if cat_page.url != page.url %}
      <div class="related-item">
        <a href="{{ cat_page.url }}" class="related-link">
          <h4>{{ cat_page.title }}</h4>
          {% if cat_page.summary %}
          <p>{{ cat_page.summary | truncate: 120 }}</p>
          {% endif %}
        </a>
      </div>
      {% endif %}
      {% endfor %}
    </div>
  </div>
  {% endif %}
  <!-- Learning Paths -->
  {% if page.learning_paths %}
  <div class="related-section">
    <h3>Learning Paths</h3>
    {% for path in page.learning_paths %}
    {% assign path_data = metadata.learning_paths[path] %}
    <div class="learning-path">
      <h4>{{ path_data.name }}</h4>
      <p>{{ path_data.description }}</p>
      <div class="path-sequence">
        {% assign current_index = path_data.sequence | find_index: page.slug %}
        {% for step in path_data.sequence %}
        {% assign step_page = site.wiki | where: "slug", step | first %}
        {% if step_page %}
        <a href="{{ step_page.url }}" 
           class="path-step {% if forloop.index0 == current_index %}current{% endif %}"
           style="background-color: {% if forloop.index0 <= current_index %}{{ path_data.color }}{% else %}#eee{% endif %}">
          {{ forloop.index }}
        </a>
        {% endif %}
        {% endfor %}
      </div>
    </div>
    {% endfor %}
  </div>
  {% endif %}
  <!-- Popular Tags -->
  {% if page.tags %}
  <div class="related-section">
    <h3>Related Tags</h3>
    <div class="tag-cloud">
      {% for tag in page.tags %}
      {% assign tag_data = metadata.tags[tag] %}
      <a href="/wiki/tags/{{ tag }}" class="tag" style="background-color: {{ tag_data.color }}">
        {{ tag_data.name }}
      </a>
      {% endfor %}
    </div>
  </div>
  {% endif %}
</div>
</file>

<file path="_includes/wiki_search.html">
<div class="wiki-search">
    <div class="search-input-wrapper">
        <svg class="search-icon" width="16" height="16" viewBox="0 0 16 16">
            <path fill="currentColor" d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0z"/>
        </svg>
        <input type="text" 
               id="wiki-search-input" 
               class="search-input"
               placeholder="Search wiki..."
               autocomplete="off"
               aria-label="Search wiki">
        <kbd class="search-shortcut">⌘K</kbd>
    </div>
    <div id="wiki-search-results" class="search-results">
        <div class="search-results-header">
            <span id="search-count" class="search-count">0 results</span>
        </div>
        <div class="search-results-list"></div>
        <div class="search-empty-state">
            <p>No results found</p>
        </div>
    </div>
</div>
<style>
.wiki-search {
    position: relative;
    margin-bottom: 1.5rem;
}
.search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}
.search-icon {
    position: absolute;
    left: 0.75rem;
    color: var(--text-secondary);
}
.search-input {
    width: 100%;
    padding: 0.75rem 2.5rem;
    font-size: var(--font-size-base);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    background: var(--background-color);
    transition: all 0.2s ease;
}
.search-input:focus {
    outline: none;
    border-color: var(--brand-color);
    box-shadow: 0 0 0 3px var(--brand-color-light);
}
.search-shortcut {
    position: absolute;
    right: 0.75rem;
    padding: 0.25rem 0.5rem;
    font-size: var(--font-size-xs);
    color: var(--text-secondary);
    background: var(--light-gray);
    border-radius: 0.25rem;
    pointer-events: none;
}
.search-results {
    display: none;
    position: absolute;
    top: calc(100% + 0.5rem);
    left: 0;
    right: 0;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    max-height: min(500px, calc(100vh - 12rem));
    overflow-y: auto;
    z-index: 100;
}
.search-results.active {
    display: block;
}
.search-results-header {
    padding: 0.5rem 0.75rem;
    border-bottom: 1px solid var(--border-color);
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
}
.search-result-item {
    padding: 0.75rem;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background 0.1s ease;
}
.search-result-item:last-child {
    border-bottom: none;
}
.search-result-item:hover,
.search-result-item.active {
    background: var(--light-gray);
}
/* Add a stronger visual indicator for keyboard navigation */
.search-result-item.active {
    background: var(--brand-color-light);
}
.result-title {
    font-weight: var(--font-weight-medium);
    color: var(--text-color);
    margin-bottom: 0.25rem;
}
.result-category {
    font-size: var(--font-size-xs);
    color: var(--text-secondary);
    background: var(--light-gray);
    padding: 0.125rem 0.375rem;
    border-radius: 1rem;
    display: inline-block;
}
.search-empty-state {
    padding: 1.5rem 0.75rem;
    text-align: center;
    color: var(--text-secondary);
    font-size: var(--font-size-sm);
    display: none;
}
.search-empty-state.active {
    display: block;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', function() {
    let searchIndex = [];
    let fuse = null;
    // Load search index
    fetch('{{ "/search-index.json" | relative_url }}')
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.text();
        })
        .then(text => {
            try {
                return JSON.parse(text);
            } catch (e) {
                console.error('Failed to parse search index:', e);
                throw e;
            }
        })
        .then(data => {
            searchIndex = data;
            fuse = new Fuse(searchIndex, {
                keys: [
                    { name: 'title', weight: 0.4 },
                    { name: 'summary', weight: 0.3 },
                    { name: 'content', weight: 0.2 },
                    { name: 'category', weight: 0.1 }
                ],
                includeMatches: true,
                threshold: 0.3,
                distance: 100
            });
        })
        .catch(error => {
            console.error('Error loading search index:', error);
            const searchInput = document.getElementById('wiki-search-input');
            searchInput.placeholder = 'Search unavailable';
            searchInput.disabled = true;
            searchInput.style.cursor = 'not-allowed';
        });
    const searchInput = document.getElementById('wiki-search-input');
    const searchResults = document.getElementById('wiki-search-results');
    const resultsList = searchResults.querySelector('.search-results-list');
    const searchCount = document.getElementById('search-count');
    const emptyState = searchResults.querySelector('.search-empty-state');
    function renderSearchResults(results) {
        resultsList.innerHTML = '';
        searchCount.textContent = `${results.length} result${results.length !== 1 ? 's' : ''}`;
        if (results.length === 0) {
            emptyState.classList.add('active');
            return;
        }
        emptyState.classList.remove('active');
        results.forEach(result => {
            const item = document.createElement('div');
            item.className = 'search-result-item';
            item.dataset.url = result.item.url;
            item.innerHTML = `
                <div class="result-title">${result.item.title}</div>
                <span class="result-category">${result.item.category}</span>
            `;
            item.addEventListener('click', () => {
                window.location.href = result.item.url;
            });
            resultsList.appendChild(item);
        });
    }
    searchInput.addEventListener('input', debounce(function(e) {
        const query = e.target.value;
        if (!query || query.length < 2) {
            searchResults.classList.remove('active');
            return;
        }
        if (fuse) {
            const results = fuse.search(query);
            searchResults.classList.add('active');
            renderSearchResults(results);
        }
    }, 200));
    // Close search results when clicking outside
    document.addEventListener('click', function(e) {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('active');
        }
    });
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
            e.preventDefault();
            searchInput.focus();
        }
        if (searchResults.classList.contains('active')) {
            const items = resultsList.querySelectorAll('.search-result-item');
            const activeItem = resultsList.querySelector('.search-result-item.active');
            let activeIndex = Array.from(items).indexOf(activeItem);
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (activeIndex < items.length - 1) {
                    if (activeItem) activeItem.classList.remove('active');
                    items[activeIndex + 1].classList.add('active');
                    items[activeIndex + 1].scrollIntoView({ block: 'nearest' });
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (activeIndex > 0) {
                    if (activeItem) activeItem.classList.remove('active');
                    items[activeIndex - 1].classList.add('active');
                    items[activeIndex - 1].scrollIntoView({ block: 'nearest' });
                }
            } else if (e.key === 'Enter' && activeItem) {
                e.preventDefault();
                window.location.href = activeItem.dataset.url;
            }
        }
    });
});
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}
</script>
</file>

<file path="_includes/wiki_sidebar.html">
{% assign all_categories = site.wiki | map: "category" | compact | uniq | sort %}
<aside class="wiki-sidebar">
    <nav class="wiki-nav">
        <!-- Breadcrumb Navigation -->
        {% include wiki_breadcrumb.html %}
        <!-- Search -->
        {% include wiki_search.html %}
        <!-- Categories -->
        <div class="wiki-nav-section">
            <h3>Categories</h3>
            <ul>
                {% for category in all_categories %}
                <li>
                    <a href="/wiki/categories/{{ category }}/" 
                       class="{% if page.category == category %}active{% endif %}">
                        {{ category | capitalize }}
                    </a>
                </li>
                {% endfor %}
            </ul>
        </div>
    </nav>
</aside>
<style>
.wiki-sidebar {
    position: sticky;
    top: 2rem;
    max-height: calc(100vh - 4rem);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border-color) transparent;
}
.wiki-sidebar::-webkit-scrollbar {
    width: 6px;
}
.wiki-sidebar::-webkit-scrollbar-track {
    background: transparent;
}
.wiki-sidebar::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}
.wiki-nav-section {
    margin-bottom: 2rem;
}
.wiki-nav-section h3 {
    font-size: var(--font-size-base);
    color: var(--text-secondary);
    margin-bottom: 1rem;
}
.wiki-nav-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
}
.wiki-nav-section a {
    display: block;
    padding: 0.5rem;
    color: var(--text-color);
    text-decoration: none;
    border-radius: 0.25rem;
}
.wiki-nav-section a:hover {
    background: var(--light-gray);
}
.wiki-nav-section a.active {
    background: var(--primary-light);
    color: var(--primary);
}
</style>
</file>

<file path="_layouts/base.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ page.title | default: "Common Ground" }}</title>
  {% include head.html %}
  <link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
  {% include header.html %}
  <main>
    {{ content }}
  </main>
  {% include footer.html %}
  <script src="/assets/js/vendor.bundle.js"></script>
  <script src="/assets/js/main.js"></script>
</body>
</html>
</file>

<file path="_layouts/default.html">
---
layout: base
---
{{ content }}
</file>

<file path="_layouts/home.html">
---
layout: default
title: Home
---
<div class="content-container">
    <div class="content">
        {{ content }}
    </div>
</div>
{% if site.posts.size > 0 %}
<div class="content-container">
    <div class="content-header">
        <h2 class="content-title">Latest Updates</h2>
    </div>
    <div class="content">
        <ul class="post-list">
            {% for post in site.posts limit:3 %}
            <li class="card">
                <span class="post-meta">{{ post.date | date: "%b %-d, %Y" }}</span>
                <h3>
                    <a class="post-link" href="{{ post.url | relative_url }}">{{ post.title | escape }}</a>
                </h3>
                {% if post.excerpt %}
                <p>{{ post.excerpt }}</p>
                {% endif %}
            </li>
            {% endfor %}
        </ul>
    </div>
</div>
{% endif %}
</file>

<file path="_layouts/page.html">
---
layout: default
title: {{ page.title }}
---
<div class="content-container">
    <div class="content">
        {{ content }}
    </div>
</div>
</file>

<file path="_layouts/stakeholder.html">
---
layout: default
---
<div class="content-container">
    <div class="content-header">
        <h1 class="content-title">
            <span class="stakeholder-emoji">{% if page.type == "person" %}👤{% else %}🏛️{% endif %}</span>
            {{ page.name }}
        </h1>
    </div>
    <hr>
    <div class="content">
        {% if page.type == "person" %}
            <p class="stakeholder-role"><strong>Role:</strong> {{ page.role }}</p>
            <p class="stakeholder-location"><strong>Location:</strong> {{ page.location }}</p>
            {% if page.expertise %}
            <h2>Expertise</h2>
            <ul>
                {% for skill in page.expertise %}
                <li>{{ skill }}</li>
                {% endfor %}
            </ul>
            {% endif %}
        {% else %}
            <p class="stakeholder-type"><strong>Type:</strong> {{ page.type_of_entity }}</p>
            <p class="stakeholder-legal"><strong>Legal Form:</strong> {{ page.legal_form }}</p>
            {% if page.jurisdiction %}
            <p class="stakeholder-jurisdiction"><strong>Jurisdiction:</strong> {{ page.jurisdiction }}</p>
            {% endif %}
            {% if page.founding_date %}
            <p class="stakeholder-founded"><strong>Founded:</strong> {{ page.founding_date }}</p>
            {% endif %}
        {% endif %}
        <h2>About</h2>
        <p>{{ page.bio | default: page.description }}</p>
        {% if page.representatives %}
        <h2>Representatives</h2>
        <ul class="stakeholder-representatives">
            {% for rep_id in page.representatives %}
            <li>{% stakeholder rep_id %}</li>
            {% endfor %}
        </ul>
        {% endif %}
        {% if page.social %}
        <h2>Connect</h2>
        <ul class="stakeholder-social">
            {% if page.social.twitter %}
            <li><a href="https://twitter.com/{{ page.social.twitter }}" target="_blank">Twitter</a></li>
            {% endif %}
            {% if page.social.github %}
            <li><a href="https://github.com/{{ page.social.github }}" target="_blank">GitHub</a></li>
            {% endif %}
        </ul>
        {% endif %}
        <div class="stakeholder-cta">
            <a href="https://app.cg/c/{{ page.id }}/" class="button primary">View on Common Ground</a>
        </div>
    </div>
</div>
</file>

<file path="_layouts/treasury.html">
---
layout: default
---
<div class="treasury-container">
    {% include treasury_sidebar.html %}
    <main class="treasury-content">
        {{ content }}
    </main>
</div>
<style>
.treasury-container {
    max-width: 1200px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 2rem;
    padding: 2rem;
}
.treasury-content {
    background: var(--background-color);
    border-radius: 1rem;
    padding: 2rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}
/* Responsive Design */
@media (max-width: 768px) {
    .treasury-container {
        grid-template-columns: 1fr;
        padding: 1rem;
    }
}
</style>
</file>

<file path="_layouts/wiki.html">
---
layout: default
---
<div class="wiki-container">
    {% include wiki_sidebar.html %}
    <main class="wiki-content">
        {% if page.is_category_index %}
            {% assign category_pages = site.wiki | where_exp:"item","item.category == page.category" | where_exp:"item","item.title != 'Index'" | sort: "weight" %}
            <h1>{{ page.category | capitalize }}</h1>
            {% include wiki_article_list.html pages=category_pages %}
        {% elsif page.is_tag_index %}
            {% assign tagged_pages = site.wiki | where_exp:"item","item.tags contains page.tag" | where_exp:"item","item.title != 'Index'" | sort: "weight" %}
            <h1>{{ page.tag | capitalize }}</h1>
            {% include wiki_article_list.html pages=tagged_pages %}
        {% else %}
            <div class="wiki-article-header">
                <h1 class="wiki-title">{{ page.title }}</h1>
                {% if page.summary %}
                <p class="wiki-summary">{{ page.summary }}</p>
                {% endif %}
                {% if page.difficulty %}
                <span class="wiki-difficulty {{ page.difficulty }}">{{ page.difficulty }}</span>
                {% endif %}
            </div>
            <div class="wiki-article-content">
                {{ content }}
            </div>
        {% endif %}
    </main>
</div>
<style>
.wiki-container {
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 2rem;
    padding: 2rem;
}
.wiki-article-header {
    background: var(--light-gray);
    border-radius: 1rem;
    padding: 2rem;
    margin-bottom: 2rem;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.wiki-article-header .wiki-title {
    margin: 0;
    font-size: var(--font-size-xl);
    color: var(--text-color);
}
.wiki-article-header .wiki-summary {
    margin: 0;
    color: var(--text-secondary);
    font-size: var(--font-size-md);
    line-height: 1.5;
}
.wiki-article-content {
    background: var(--background-color);
    border-radius: 1rem;
    padding: 2rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}
</style>
</file>

<file path="_pages/about.md">
---
layout: page
title: About Common Ground
summary: Learn about our mission, values, and the platform we're building to revolutionize web3 communication.
permalink: /about/
---

<header class="page-header">
    <h1 class="page-title">About Common Ground</h1>
    <p class="page-summary">Learn about our mission, values, and the platform we're building to revolutionize web3 communication.</p>
</header>

## Our Vision

Common Ground DAO is building the next generation of coordination tools across chats, calls, forums, and ecosystems. We believe the new web needs new ways of doing things, and we're here to make that happen. Our platform serves as the coordination layer for web3, enabling communities to connect, collaborate, and create in ways previously impossible.

## Our Values

### ☯️ Grounded Acceleration (g/acc)
We champion communities working together to harness technology for collective benefit. Our approach ensures technological advancement serves everyone, not just a select few. We believe in progress that lifts all boats.

### 🛡️ Defensive Acceleration (d/acc)
We're committed to developing technologies that act as safeguards, ensuring equitable progress distribution. Our focus is on decentralization, resilience, and building systems inherently resistant to coercion, monopolization, or exploitation.

### 🔗 Integrated Acceleration (i/acc)
While embracing decentralization, we believe in maintaining connections with broader societal frameworks. This integration enables resource and knowledge sharing, leading to more resilient and adaptive communities.

## Join Our Mission

Common Ground is more than a platform—it's a movement towards better digital coordination and communication. We're building a future where web3 communities can thrive through better tools and stronger connections.

Whether you're a developer, community leader, or web3 enthusiast, there's a place for you in the Common Ground ecosystem. Join our 65,000+ members in shaping the future of web3 communication.

<div class="social-links">
    <a href="https://app.cg/c/commonground" target="_blank" class="social-link">
        <img src="{{ '/assets/images/common-ground.png' | relative_url }}" alt="Common Ground App" class="social-icon cg">
    </a>
    <a href="https://twitter.com/CommonGround_cg" target="_blank" class="social-link">
        <svg viewBox="0 0 24 24" aria-hidden="true" class="social-icon twitter">
            <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"></path>
        </svg>
    </a>
    <a href="mailto:ola@dao.cg" class="social-link">
        <svg viewBox="0 0 24 24" aria-hidden="true" class="social-icon email">
            <path d="M1.5 8.67v8.58a3 3 0 003 3h15a3 3 0 003-3V8.67l-8.928 5.493a3 3 0 01-3.144 0L1.5 8.67z"></path>
            <path d="M22.5 6.908V6.75a3 3 0 00-3-3h-15a3 3 0 00-3 3v.158l9.714 5.978a1.5 1.5 0 001.572 0L22.5 6.908z"></path>
        </svg>
    </a>
</div>
</file>

<file path="_pages/community.md">
---
layout: page
title: Community
summary: Join the conversation, contribute to our mission, and help shape the future of web3 coordination.
permalink: /community/
---

<header class="page-header">
    <h1 class="page-title">Community</h1>
    <p class="page-summary">Join the conversation, contribute to our mission, and help shape the future of web3 coordination.</p>
</header>

<div class="hero">
    <h1>{{ page.title }}</h1>
    <p>Join a vibrant community of builders, creators, and innovators shaping the future of coordination.</p>
</div>

<div class="container">
    <div class="page-section">
        <h2>Get Started</h2>
        <p>Begin your journey with Common Ground through these entry points:</p>
        
        <div class="grid">
            <div class="card">
                <h3>Join Our Community</h3>
                <p>Connect with members, participate in discussions, and shape the future of coordination on our platform.</p>
                <a href="https://app.cg/c/commonground/" class="button primary">Join Community</a>
            </div>
            
            <div class="card">
                <h3>Create Your Space</h3>
                <p>Start your own community or bring your existing one to Common Ground.</p>
                <a href="https://app.cg" class="button primary">Launch App</a>
            </div>
            
            <div class="card">
                <h3>Twitter</h3>
                <p>Follow us for updates, insights, and community highlights.</p>
                <a href="https://twitter.com/CommonGround_cg" class="button primary">Follow Us</a>
            </div>
        </div>
    </div>
    
    <div class="page-section">
        <h2>Ways to Contribute</h2>
        <div class="grid">
            <div class="card">
                <h3>Integrations</h3>
                <p>Build an integration with our extension SDK, or use our API to bring Common Ground to your users.</p>
                <a href="https://github.com/Common-Ground-DAO" class="button secondary">View GitHub</a>
            </div>

            <div class="card">
                <h3>Open Source</h3>
                <p>Contribute to our open-source codebase and help build the future of coordination.</p>
                <a href="https://github.com/Common-Ground-DAO" class="button secondary">View GitHub</a>
            </div>
            
            <div class="card">
                <h3>Community Building</h3>
                <p>Help grow and nurture our community through events, content, and engagement.</p>
                <a href="#" class="button secondary">Learn More</a>
            </div>
            
            <div class="card">
                <h3>Governance</h3>
                <p>Participate in shaping the future of Common Ground through our dual-token governance system.</p>
                <a href="/governance" class="button secondary">View Governance</a>
            </div>
        </div>
    </div>
    
    <div class="page-section">
        <h2>Community Programs</h2>
        <p>Initiatives designed to empower and grow our community:</p>
        
        <div class="grid">
            <div class="card">
                <h3>Ambassador Program</h3>
                <p>Represent Common Ground in your local community and help spread our mission.</p>
                <a href="#" class="button primary">Apply Now</a>
            </div>
            
            <div class="card">
                <h3>Grants Program</h3>
                <p>Get funding for projects that enhance the Common Ground ecosystem.</p>
                <a href="#" class="button primary">Learn More</a>
            </div>
            
            <div class="card">
                <h3>Events</h3>
                <p>Join our virtual and in-person events to connect with the community.</p>
                <a href="#" class="button primary">View Calendar</a>
            </div>
        </div>
    </div>

    <div class="page-section">
        <h2>Community Resources</h2>
        <p>Tools and resources to help you make the most of Common Ground:</p>
        
        <div class="grid">
            <div class="card">
                <h3>Documentation</h3>
                <p>Comprehensive guides and tutorials for using Common Ground.</p>
                <a href="https://app.cg/c/commonground/docs" class="button secondary">View Docs</a>
            </div>
            
            <div class="card">
                <h3>Community Guidelines</h3>
                <p>Our values, code of conduct, and community standards.</p>
                <a href="https://app.cg/c/commonground/guidelines" class="button secondary">Read Guidelines</a>
            </div>
            
            <div class="card">
                <h3>Support</h3>
                <p>Get help directly in our community space.</p>
                <a href="https://app.cg/c/commonground/support" class="button secondary">Get Help</a>
            </div>
        </div>
    </div>

    <div class="page-section">
        <h2>Featured Communities</h2>
        <p>Discover some of the amazing communities building on Common Ground:</p>
        
        <div class="grid">
            <div class="card">
                <h3>DAOs</h3>
                <p>Decentralized organizations leveraging our coordination tools.</p>
                <a href="#" class="button primary">Explore DAOs</a>
            </div>
            
            <div class="card">
                <h3>Projects</h3>
                <p>Web3 projects and protocols using Common Ground for community coordination.</p>
                <a href="#" class="button primary">View Projects</a>
            </div>
            
            <div class="card">
                <h3>Start Your Community</h3>
                <p>Launch your own community on Common Ground.</p>
                <a href="#" class="button primary">Get Started</a>
            </div>
        </div>
    </div>
</div>
</file>

<file path="_pages/governance.md">
---
layout: page
title: Governance
summary: Join us in building the future of decentralized communication through progressive decentralization and community ownership.
permalink: /governance/
---

<header class="page-header">
    <h1 class="page-title">Governance</h1>
    <p class="page-summary">Shape the future of Common Ground through our progressive decentralization journey.</p>
</header>

<div class="governance-intro">
    <div class="container">
        <h2>Progressive Decentralization</h2>
        <p>Common Ground is on a journey from a community-driven platform to a fully decentralized, cooperatively owned communication protocol. Our governance model evolves with the platform, ensuring sustainable growth and true community ownership.</p>
    </div>
</div>

<div class="container">
    <section class="governance-section">
        <h2>Get Involved Today</h2>
        <div class="participation-grid">
            <div class="participation-card">
                <div class="card-icon">🐛</div>
                <h3>Report Issues</h3>
                <p>Help improve Common Ground by submitting bugs or feature requests through our official form.</p>
                <a href="https://forms.office.com/e/0iahZJHis4" class="button" target="_blank">Submit Report →</a>
            </div>

            <div class="participation-card">
                <div class="card-icon">💡</div>
                <h3>Propose Features</h3>
                <p>Share and discuss your ideas for new features in our dedicated feature proposal channel.</p>
                <a href="https://app.cg/c/commonground/channel/~pRHnEd6Ae5KbUfWwc3DM2B/" class="button" target="_blank">Propose Features →</a>
            </div>

            <div class="participation-card">
                <div class="card-icon">🤝</div>
                <h3>Get Support</h3>
                <p>Connect with our community and get help in our dedicated support channel.</p>
                <a href="https://app.cg/c/commonground/channel/~1KVhCmhzZYdShkRa3vnEoi/" class="button" target="_blank">Get Help →</a>
            </div>

            <div class="participation-card">
                <div class="card-icon">🌳</div>
                <h3>Ecosystem Partner</h3>
                <p>Bring your entire ecosystem to Common Ground, coordinating tens of thousands of people.</p>
                <a href="https://forms.office.com/e/uui0VViU7R" class="button" target="_blank">Inquire Today →</a>
            </div>            
        </div>
    </section>
    <section class="governance-section">
        <h2>Governance Roadmap</h2>
        <div class="timeline">
            <div class="timeline-item active">
                <div class="timeline-marker">1</div>
                <div class="timeline-content">
                    <h3>Token Holder Engagement</h3>
                    <p>Token holders can claim special roles on Common Ground, gaining access to exclusive features and recognition within the community.</p>
                    <a href="https://app.cg/token/" class="button verify-button" target="_blank">Verify Token Holdings →</a>
                </div>
            </div>

            <div class="timeline-item active">
                <div class="timeline-marker">2</div>
                <div class="timeline-content">
                    <h3>Enhanced Participation</h3>
                    <p>Access exclusive channels, content, and events. Engage directly with the team and help shape the platform's roadmap through privileged access and direct communication.</p>
                    <a href="https://app.cg/c/commonground/" class="button verify-button" target="_blank">Join Community →</a>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">3</div>
                <div class="timeline-content">
                    <h3>Token-Weighted Governance</h3>
                    <p>Implementation of formal governance through Snapshot voting and the Common Ground extension API, enabling token-weighted decision-making on key proposals.</p>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">4</div>
                <div class="timeline-content">
                    <h3>Open Source Transition</h3>
                    <p>Opening the Common Ground codebase under a community-oriented permissive license, enabling transparency and community contributions.</p>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">5</div>
                <div class="timeline-content">
                    <h3>Revenue Sustainability</h3>
                    <p>Establishment of sustainable revenue streams through the Common Ground app, ensuring long-term viability and community benefit.</p>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">6</div>
                <div class="timeline-content">
                    <h3>Cooperative Formation</h3>
                    <p>Incorporation of the Common Ground Cooperative to assume operational control of app.cg, establishing formal community ownership.</p>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">7</div>
                <div class="timeline-content">
                    <h3>Bicameral Governance</h3>
                    <p>Implementation of a two-chamber governance system between CG Cooperative and CG DAO, balancing operational needs with community direction.</p>
                </div>
            </div>

            <div class="timeline-item">
                <div class="timeline-marker">8</div>
                <div class="timeline-content">
                    <h3>DAO Dissolution</h3>
                    <p>Final transition to full cooperative ownership with the planned dissolution of CG DAO, completing the decentralization journey.</p>
                </div>
            </div>
        </div>
    </section>
</div>

<style>
.governance-intro {
    background: var(--primary-light);
    padding: 4rem 0;
    margin-bottom: 4rem;
}

.governance-section {
    margin-bottom: 4rem;
}

.timeline {
    position: relative;
    padding: 3rem 0;
    background-color: #f8f9fa;
}

.timeline::before {
    content: '';
    position: absolute;
    left: 2rem;
    top: 0;
    height: 100%;
    width: 2px;
    background: #d1d5da;
}

.timeline-item {
    position: relative;
    padding-left: 5rem;
    margin-bottom: 2rem;
    opacity: 0.8;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.timeline-item.active {
    opacity: 1;
}

.timeline-marker {
    position: absolute;
    left: 1rem;
    top: 0;
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    background: var(--brand-color);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    box-shadow: 0px 2px 4px rgba(0,0,0,0.1);
    transition: transform 0.3s ease;
}

.timeline-item:hover .timeline-marker {
    transform: scale(1.1);
}

.timeline-content {
    background: #fff;
    padding: 2rem;
    border-radius: 0.75rem;
    border: none;
    box-shadow: 0px 2px 8px rgba(0,0,0,0.05);
    transition: box-shadow 0.3s ease;
}

.timeline-content:hover {
    box-shadow: 0px 4px 12px rgba(0,0,0,0.1);
}

.timeline-content h3 {
    margin: 0 0 0.75rem 0;
    font-size: 1.25rem;
    color: var(--brand-color);
}

.timeline-content p {
    font-size: 1rem;
    line-height: 1.5;
    color: #333;
}

.verify-button {
    margin-top: 1rem;
    background: #0366d6;
    color: #fff;
    border: none;
    padding: 0.75rem 1.25rem;
    border-radius: 0.5rem;
    text-decoration: none;
    transition: background 0.3s ease;
    font-weight: bold;
}

.verify-button:hover {
    background: #0256b3;
}

/* Future Milestones Styling */
.timeline-item:not(.active) {
    opacity: 0.6;
}
.timeline-item:not(.active) .timeline-marker {
    background: #6c757d;
    box-shadow: none;
    animation: pulse 2s infinite;
}
.timeline-item:not(.active) .timeline-content {
    background: #fdfdfe;
    border: 2px dashed #d1d5da;
    box-shadow: none;
    transition: none;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(108,117,125, 0.5);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(108,117,125, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(108,117,125, 0);
    }
}

/* End Future Milestones Styling */

/* Additional Enhancements for Future Milestones */
.timeline-item:not(.active) .timeline-content {
    position: relative;
}
.timeline-item:not(.active) .timeline-content::before {
    /* Common styling for the pseudo-element */
    position: absolute;
    top: -1rem;
    right: 1rem;
    font-size: 0.75rem;
    background: #fff;
    color: #6c757d;
    font-weight: bold;
    padding: 0.2rem 0.5rem;
    border: 1px solid #6c757d;
    border-radius: 0.25rem;
}
/* For the first two future roadmap items (overall 3rd and 4th children, assuming first 2 are active) */
.timeline-item:not(.active):nth-child(3) .timeline-content::before,
.timeline-item:not(.active):nth-child(4) .timeline-content::before {
    content: 'Coming Soon';
}
/* For subsequent future roadmap items (5th child onward) */
.timeline-item:not(.active):nth-child(n+5) .timeline-content::before {
    content: 'Coming Eventually';
}

.participation-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 2rem;
    margin-top: 2rem;
}

.participation-card {
    background: var(--background);
    padding: 2rem;
    border-radius: 0.5rem;
    border: 1px solid var(--border-color);
    text-align: center;
}

.card-icon {
    font-size: 2.5rem;
    margin-bottom: 1rem;
}

.button {
    display: inline-block;
    padding: 0.5rem 1rem;
    background: var(--primary);
    color: white;
    text-decoration: none;
    border-radius: 0.25rem;
    margin-top: 1rem;
    transition: background 0.2s ease;
}

.button:hover {
    background: var(--primary-dark);
}

@media (max-width: 768px) {
    .timeline::before {
        left: 0.75rem;
    }
    
    .timeline-item {
        padding-left: 2.5rem;
    }
    
    .timeline-marker {
        width: 1.5rem;
        height: 1.5rem;
        font-size: 0.8rem;
    }
}
</style>
</file>

<file path="_pages/press.md">
---
layout: page
title: Press
summary: Latest news, announcements, and media coverage about Common Ground and our mission.
permalink: /press/
---

<header class="page-header">
    <h1 class="page-title">Press</h1>
    <p class="page-summary">Latest news, announcements, and media coverage about Common Ground and our mission.</p>
</header>

<div class="hero">
    <h1>{{ page.title }}</h1>
    <p>Resources and information for media coverage of Common Ground.</p>
</div>

<div class="container">
    <div class="page-section">
        <h2>Brand Assets</h2>
        <p>Official logos, colors, and visual elements of Common Ground.</p>
        
        <div class="grid">
            <div class="card">
                <h3>Logos</h3>
                <p>Download our logo in various formats and sizes, including light and dark versions.</p>
                <a href="{{ '/assets/files/brand-assets.zip' | relative_url }}" target="_blank" class="button primary">Download Logos</a>
            </div>
            
            <div class="card">
                <h3>Brand Guidelines</h3>
                <p>Our visual identity guidelines, including typography, colors, and usage rules.</p>
                <a href="#" class="button primary">View Guidelines</a>
            </div>
            
            <div class="card">
                <h3>Product Screenshots</h3>
                <p>High-resolution images of our platform and key features.</p>
                <a href="#" class="button primary">View Gallery</a>
            </div>
        </div>
    </div>
    
    <div class="page-section">
        <h2>Company Information</h2>
        <div class="grid">
            <div class="card">
                <h3>About Us</h3>
                <p>Common Ground is building the coordination layer for web3, enabling communities to connect, collaborate, and create in ways previously impossible.</p>
            </div>
            
            <div class="card">
                <h3>Key Facts</h3>
                <p>Founded in 2021 • 15,000+ Members • Headquartered in Switzerland • European Cooperative Structure</p>
            </div>
            
            <div class="card">
                <h3>Leadership</h3>
                <p>Profiles and headshots of our founders and key team members.</p>
                <a href="#" class="button secondary">View Team</a>
            </div>
        </div>
    </div>
    
    <div class="page-section">
        <h2>Our Story</h2>
        <p>Key milestones and achievements in Common Ground's journey.</p>
        
        <div class="grid">
            <div class="card">
                <h3>Mission & Vision</h3>
                <p>Building the future of decentralized communication and coordination through innovative technology and community-driven governance.</p>
            </div>
            
            <div class="card">
                <h3>Values</h3>
                <p>Grounded Acceleration (g/acc), Defensive Acceleration (d/acc), and Integrated Acceleration (i/acc) guide our development.</p>
            </div>
            
            <div class="card">
                <h3>Impact</h3>
                <p>How Common Ground is transforming web3 communication and community coordination.</p>
            </div>
        </div>
    </div>

    <div class="page-section">
        <h2>Media Resources</h2>
        <p>Additional materials for press and media coverage:</p>
        
        <div class="grid">
            <div class="card">
                <h3>Press Releases</h3>
                <p>Latest announcements and company news.</p>
                <a href="#" class="button primary">View News</a>
            </div>
            
            <div class="card">
                <h3>Media Coverage</h3>
                <p>Recent articles, interviews, and features about Common Ground.</p>
                <a href="#" class="button primary">View Coverage</a>
            </div>
            
            <div class="card">
                <h3>Contact</h3>
                <p>For press inquiries, please contact our media team.</p>
                <a href="mailto:press@dao.cg" class="button primary">Contact Us</a>
            </div>
        </div>
    </div>

    <div class="page-section">
        <h2>Technical Overview</h2>
        <p>Information about our technology and infrastructure:</p>
        
        <div class="grid">
            <div class="card">
                <h3>Platform Architecture</h3>
                <p>Overview of our decentralized communication infrastructure and key technologies.</p>
                <a href="#" class="button secondary">Learn More</a>
            </div>
            
            <div class="card">
                <h3>Governance Model</h3>
                <p>Our unique dual-token system and cooperative structure explained.</p>
                <a href="#" class="button secondary">View Details</a>
            </div>
            
            <div class="card">
                <h3>Security</h3>
                <p>Our approach to platform security and user data protection.</p>
                <a href="#" class="button secondary">Security Info</a>
            </div>
        </div>
    </div>
</div>
</file>

<file path="_pages/treasury-v2.md">
---
layout: treasury
title: Treasury
summary: A modern dashboard for tracking and analyzing our treasury data.
permalink: /treasury/
---

<header class="page-header">
    <h1 class="page-title">Treasury Dashboard</h1>
    <p class="page-summary">Real-time insights into our treasury activities and financial health.</p>
</header>

<link rel="stylesheet" href="/assets/css/treasury-v2.css">
<div class="dashboard-container">
    <!-- Overview Metrics -->
    <div id="metrics" class="dashboard-section">
        <div id="dashboard-metrics" class="metrics-grid">
            <!-- Metrics will be populated by JavaScript -->
        </div>
    </div>

    <!-- Treasury Components Section -->
    <div id="components" class="dashboard-section">
        <div class="chart-card">
            <h3>Treasury Components</h3>
            <div class="chart-container">
                <canvas id="treasury-components-chart"></canvas>
            </div>
        </div>
    </div>

    <!-- Liquid Assets Section -->
    <div id="liquid-assets" class="dashboard-section">
        <div class="section-content">
            <div class="chart-card">
                <h3>Liquid Portfolio</h3>
                <div class="chart-container">
                    <canvas id="liquid-portfolio-chart"></canvas>
                </div>
            </div>
            <div class="asset-list-card">
                <div class="card-header">
                    <h3>Liquid Assets</h3>
                    <div class="card-actions">
                        <select id="liquid-asset-sort" class="select-styled">
                            <option value="value">Sort by Value</option>
                            <option value="name">Sort by Name</option>
                        </select>
                    </div>
                </div>
                <div class="asset-list" id="liquid-asset-list">
                    <!-- Liquid asset items will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Illiquid Assets Section -->
    <div id="illiquid-assets" class="dashboard-section">
        <div class="section-content">
            <div class="chart-card">
                <h3>Illiquid Portfolio</h3>
                <div class="chart-container">
                    <canvas id="illiquid-portfolio-chart"></canvas>
                </div>
            </div>
            <div class="asset-list-card">
                <div class="card-header">
                    <h3>Illiquid Assets</h3>
                    <div class="card-actions">
                        <select id="illiquid-asset-sort" class="select-styled">
                            <option value="value">Sort by Value</option>
                            <option value="name">Sort by Name</option>
                        </select>
                    </div>
                </div>
                <div class="asset-list" id="illiquid-asset-list">
                    <!-- Illiquid asset items will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Token Distribution Section -->
    <div id="token-distribution" class="dashboard-section">
        <div class="chart-card">
            <h3>Token Distribution Across Wallets</h3>
            <div class="chart-container">
                <canvas id="token-distribution-chart"></canvas>
            </div>
        </div>
    </div>    

    <!-- Multisig Wallets Section -->
    <div id="multisig-wallets" class="dashboard-section">
        <div class="section-header">
            <h2>Multisig Wallets</h2>
        </div>
        <div class="multisig-grid" id="multisig-wallets">
            <!-- Multisig wallet cards will be populated by JavaScript -->
        </div>
    </div>

    <!-- Cost Analysis Section -->
    <div id="cost-analysis" class="dashboard-section">
        <div class="section-header">
            <h2>Cost Analysis</h2>
            <div class="section-controls">
                <select id="cost-year-filter" class="select-styled">
                    <option value="2025">2025</option>
                </select>
                <select id="cost-currency-display" class="select-styled">
                    <option value="USD">Show in USD</option>
                </select>
            </div>
        </div>

        <!-- Cost Overview -->
        <div class="cost-overview">
            <div class="cost-metrics-grid">
                <div class="metric-card">
                    <h3>Total Annual Cost</h3>
                    <div id="total-annual-cost" class="metric-value"></div>
                    <div class="metric-subtitle">Projected</div>
                </div>
                <div class="metric-card">
                    <h3>Monthly Burn Rate</h3>
                    <div id="monthly-burn-rate" class="metric-value"></div>
                    <div class="metric-subtitle">Average</div>
                </div>
                <div class="metric-card">
                    <h3>Infrastructure</h3>
                    <div id="infrastructure-cost" class="metric-value"></div>
                    <div class="metric-subtitle">Annual</div>
                </div>
                <div class="metric-card">
                    <h3>Corporate</h3>
                    <div id="corporate-cost" class="metric-value"></div>
                    <div class="metric-subtitle">Annual</div>
                </div>
            </div>
        </div>

        <!-- Cost Distribution -->
        <div class="cost-charts-grid">
            <!-- Main Category Distribution -->
            <div class="chart-card">
                <h3>Cost Distribution by Category</h3>
                <div class="chart-container">
                    <canvas id="cost-category-chart"></canvas>
                </div>
            </div>

            <!-- Infrastructure Costs -->
            <div class="chart-card">
                <h3>Infrastructure Cost Breakdown</h3>
                <div class="chart-container">
                    <canvas id="infrastructure-breakdown-chart"></canvas>
                </div>
            </div>

            <!-- Monthly Cost Trend -->
            <div class="chart-card full-width">
                <h3>Monthly Cost Projection</h3>
                <div class="chart-container">
                    <canvas id="monthly-cost-chart"></canvas>
                </div>
            </div>

            <!-- Entity Cost Comparison -->
            <div class="chart-card">
                <h3>Cost by Entity</h3>
                <div class="chart-container">
                    <canvas id="entity-cost-chart"></canvas>
                </div>
            </div>

            <!-- Currency Distribution -->
            <div class="chart-card">
                <h3>Currency Distribution</h3>
                <div class="chart-container">
                    <canvas id="currency-distribution-chart"></canvas>
                </div>
            </div>
        </div>

        <!-- Detailed Cost Table -->
        <div class="cost-details">
            <div class="card-header">
                <h3>Detailed Cost Breakdown</h3>
                <div class="card-actions">
                    <input type="text" id="cost-search" class="input-styled" placeholder="Search costs...">
                    <select id="cost-table-sort" class="select-styled">
                        <option value="category">Sort by Category</option>
                        <option value="amount">Sort by Amount</option>
                        <option value="entity">Sort by Entity</option>
                    </select>
                </div>
            </div>
            <div class="cost-table-container">
                <table id="cost-details-table" class="data-table">
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Entity</th>
                            <th>Description</th>
                            <th>Amount (USD)</th>
                            <th>Original Amount</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Cost details will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script type="module">
    import { treasuryDataService } from '{{ site.baseurl }}/assets/js/treasury-v2-data.js';
    window.treasuryDataService = treasuryDataService;
</script>
<script src="{{ '/assets/js/treasury-v2.js' | relative_url }}" type="module"></script>
</file>

<file path="_plugins/search_index_generator.rb">
require 'json'
require 'fileutils'
module Jekyll
  class SearchIndexGenerator < Generator
    safe true
    priority :low
    def generate(site)
      puts "Generating search index..."
      # Collect all wiki pages
      items = []
      site.collections['wiki'].docs.each do |doc|
        next if doc.data['is_category_index'] || doc.data['is_tag_index']
        puts "Processing: #{doc.url}"
        # Extract content without HTML and normalize whitespace
        content = doc.content.gsub(/<[^>]*>/, ' ')
                           .gsub(/\s+/, ' ')
                           .strip
        # Create search item
        item = {
          title: doc.data['title'],
          url: doc.url,
          category: doc.data['category'],
          summary: doc.data['summary'],
          content: content,
          difficulty: doc.data['difficulty'],
          tags: doc.data['tags'],
          weight: doc.data['weight']
        }
        items << item
      end
      # Write the search index file only to the destination
      dest_path = File.join(site.dest, 'search-index.json')
      puts "Writing search index to: #{dest_path}"
      # Generate pretty JSON
      search_index = JSON.pretty_generate(items)
      # Ensure the destination directory exists
      FileUtils.mkdir_p(File.dirname(dest_path))
      # Write to destination
      File.write(dest_path, search_index)
      puts "Search index generation complete!"
    end
  end
end
</file>

<file path="_wiki/categories/concepts/index.html">
---
layout: wiki
category: concepts
is_category_index: true
permalink: /wiki/categories/concepts/
---
</file>

<file path="_wiki/categories/glossary/index.html">
---
layout: wiki
category: glossary
is_category_index: true
permalink: /wiki/categories/glossary/
---
</file>

<file path="_wiki/categories/mechanics/index.html">
---
layout: wiki
category: mechanics
is_category_index: true
permalink: /wiki/categories/mechanics/
---
</file>

<file path="_wiki/categories/primitives/index.html">
---
layout: wiki
category: primitives
is_category_index: true
permalink: /wiki/categories/primitives/
---
</file>

<file path="_wiki/categories/index.md">

</file>

<file path="_wiki/concepts/community-hyperstructures.md">
---
title: "Community Hyperstructures"
slug: "community-hyperstructures"
aliases: ["hyperstructures", "community-infrastructure"]
summary: "Antifragile networks of web3 communities built on composable primitives and credibly neutral coordination infrastructure."

category: "concepts"
tags: ["infrastructure", "coordination", "web3", "community"]
weight: 1

related_terms:
  coordination:
    type: "enables"
    weight: 0.9
  convergence:
    type: "depends_on"
    weight: 0.8
  discourse_graphs:
    type: "utilizes"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["coordination", "convergence"]
recommended_next: ["discourse-graphs", "ai-hiveminds"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Community Hyperstructures

Community hyperstructures represent a new class of cryptographic coordination machines that combine three fundamental properties: composability through atomic primitives and modular architecture, antifragility via anti-monopolization safeguards and coercion resistance, and credible neutrality enforced by transparent participation rules. These persistent coordination layers emerge from the careful composition of identity systems, role management frameworks, and governance primitives into higher-order organizational logic.

The implementation stack comprises three layers: a base layer of cryptoeconomic primitives, a coordination layer with resource allocation mechanisms, and an application layer exposing community interfaces. This architecture enables novel network effects where communities gain antifragile properties through cross-protocol integration, creating emergent value that exceeds the sum of individual components.

The benefits manifest as enhanced coordination through reduced social friction, sustainable growth via value-aligned incentives, and combinatorial innovation through protocol interoperability. However, significant challenges remain in balancing technical complexity with social adoption, particularly around preventing governance capture while maintaining upgradeability.

Future development vectors point toward increased automation through zkML-powered governance optimizers and adaptive mechanism design that responds to community health metrics in real-time. The endgame involves hyperstructures evolving into self-assembling coordination fabrics that enable communities to fork and merge with the fluidity of git repositories.

## Core Principles

1. **Composability**
   - Atomic primitives (identity, roles, governance)
   - Higher-level objects
   - Cross-chain interoperability
   - Modular design

2. **Antifragility**
   - Resistance to coercion
   - Protection against monopolization
   - Exploitation prevention
   - Adaptive growth

3. **Credible Neutrality**
   - Fair participation rules
   - Transparent governance
   - Equal access rights
   - Unbiased mechanisms

## Implementation

Community hyperstructures are implemented through several key components:

### 1. Base Layer
- Identity systems
- Role management
- Permission frameworks
- Value exchange protocols

### 2. Coordination Layer
- Governance mechanisms
- Decision frameworks
- Resource allocation
- Conflict resolution

### 3. Application Layer
- Community interfaces
- Interaction tools
- Analytics dashboards
- Integration APIs

## Benefits

1. **Enhanced Coordination**
   - Efficient decision-making
   - Reduced friction
   - Clear accountability
   - Improved transparency

2. **Sustainable Growth**
   - Community-driven development
   - Cooperative ownership
   - Value alignment
   - Long-term viability

3. **Network Effects**
   - Cross-community collaboration
   - Resource sharing
   - Knowledge exchange
   - Collective intelligence

## Challenges

1. **Technical Complexity**
   - Integration difficulties
   - Performance optimization
   - Security considerations
   - Scalability issues

2. **Social Coordination**
   - Governance alignment
   - Incentive design
   - Cultural differences
   - Trust building

3. **Resource Management**
   - Token economics
   - Value distribution
   - Resource allocation
   - Sustainability

## Future Directions

The evolution of community hyperstructures will likely focus on:

1. **Enhanced Automation**
   - AI integration
   - Smart contracts
   - Autonomous processes
   - Predictive analytics

2. **Improved Interoperability**
   - Cross-chain bridges
   - Protocol standards
   - Data portability
   - Universal interfaces

3. **Advanced Governance**
   - Fluid democracy
   - Reputation systems
   - Dynamic incentives
   - Adaptive mechanisms
</file>

<file path="_wiki/concepts/community-sovereignty.md">
---
title: "Community Sovereignty"
slug: "community-sovereignty"
aliases: ["sovereign-communities", "community-autonomy"]
summary: "The principle and practice of communities maintaining independence and self-governance while participating in broader web3 ecosystems and networks."

category: "concepts"
tags: ["social", "governance", "autonomy", "community"]
weight: 4

related_terms:
  onchain_culture:
    type: "enables"
    weight: 0.9
  community_hyperstructures:
    type: "implements"
    weight: 0.8
  trust_networks:
    type: "builds"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["onchain-culture", "community-hyperstructures"]
recommended_next: ["trust-networks", "zero-friction-onboarding"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Community Sovereignty

Community sovereignty embodies the cryptographic realization of subsidiarity - the principle that social organization should occur at the most local level competent to handle it. This manifests through three axiomatic properties: autonomous governance via self-executing social contracts, economic independence through non-custodial treasuries, and cultural self-determination via immutable identity primitives.

The DUNA/Coop bicameral structure demonstrates a novel federalist model: while the Cooperative handles day-to-day operations through 1p1v governance, the DUNA maintains protocol-level sovereignty via token-weighted voting. This creates a checks-and-balances system where short-term operational needs balance against long-term protocol integrity - a blockchain analogue to constitutional review.

The true innovation lies in sovereignty-preserving interoperability. Through LUKSO's Universal Profiles and ERC-725 standards, communities maintain self-sovereignty while participating in cross-ecosystem value flows. It's the digital equivalent of EU member states retaining legal autonomy while participating in common markets - except enforced by smart contracts rather than bureaucratic apparatus.

## Core Principles

1. **Autonomous Governance**
   - Self-determination
   - Independent decision-making
   - Resource control
   - Value autonomy
   - Cultural independence

2. **Interconnected Systems**
   - Network participation
   - Resource sharing
   - Value exchange
   - Protocol integration
   - Cultural exchange

3. **Sovereign Identity**
   - Community brand
   - Shared values
   - Cultural norms
   - Collective purpose
   - Unique contribution

## Implementation Mechanisms

Community sovereignty is maintained through:

### 1. Governance Systems
- Decision frameworks
- Voting mechanisms
- Role structures
- Resource allocation
- Conflict resolution

### 2. Economic Independence
- Treasury management
- Value creation
- Resource control
- Financial autonomy
- Sustainable funding

### 3. Cultural Practices
- Identity formation
- Value systems
- Community rituals
- Knowledge management
- Social norms

## Benefits

1. **Community Empowerment**
   - Self-determination
   - Resource control
   - Value creation
   - Cultural autonomy

2. **Network Effects**
   - Ecosystem participation
   - Resource sharing
   - Value exchange
   - Knowledge transfer

3. **Sustainable Growth**
   - Independent development
   - Value retention
   - Cultural preservation
   - Long-term viability

## Challenges

1. **Balance Management**
   - Autonomy vs. integration
   - Resource allocation
   - Value alignment
   - Network participation

2. **Governance Complexity**
   - Decision-making
   - Role management
   - Resource control
   - Conflict resolution

3. **Ecosystem Integration**
   - Protocol alignment
   - Value exchange
   - Cultural preservation
   - Identity maintenance

## Future Directions

The evolution of community sovereignty will focus on:

1. **Advanced Governance**
   - Dynamic systems
   - Adaptive mechanisms
   - AI integration
   - Cultural preservation

2. **Enhanced Coordination**
   - Cross-community collaboration
   - Resource optimization
   - Value creation
   - Knowledge sharing

3. **Sovereign Innovation**
   - Custom models
   - Cultural experiments
   - Value systems
   - Growth patterns
</file>

<file path="_wiki/concepts/composite-primitives.md">
---
title: "Composite Primitives"
slug: "composite-primitives"
aliases: ["higher-level-primitives", "primitive-composition"]
summary: "Higher-level web3 building blocks composed of multiple atomic primitives, enabling complex community interactions and governance structures."

category: "concepts"
tags: ["infrastructure", "primitives", "web3", "composition"]
weight: 2

related_terms:
  meta_protocol:
    type: "implemented_by"
    weight: 0.9
  community_hyperstructures:
    type: "enables"
    weight: 0.8
  passport:
    type: "example"
    weight: 0.7
  onchain_community:
    type: "example"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["meta-protocol"]
recommended_next: ["passport", "onchain-community", "community-token"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Composite Primitives

Composite primitives represent the web3 equivalent of TCP/IP's layered model - modular abstractions that transform cryptographic raw materials into user-facing functionality. Their power emerges from three design constraints: atomic decomposition (any primitive can be reduced to constituent parts), interface standardization (EIP-based compatibility), and emergent properties (new capabilities arising from combinations).

The Passport system exemplifies this through its stratified architecture:
1) Base layer: ZK-SNARKs for identity proofs
2) Middleware: ERC-734 key management
3) Application layer: Social recovery via web-of-trust

This stratification enables innovation at each layer without breaking upstream functionality - much like how HTTP evolved while maintaining TCP compatibility. The implications are profound: communities can swap governance modules (Aragon-style voting vs. DAOstack holographic consensus) while maintaining shared identity and reputation layers.

## Core Characteristics

1. **Composition**
   - Atomic primitive integration
   - Standardized interfaces
   - Modular design
   - Extensible architecture

2. **Interoperability**
   - Cross-chain compatibility
   - Protocol alignment
   - State synchronization
   - Resource sharing

3. **Functionality**
   - Enhanced capabilities
   - Complex operations
   - Automated workflows
   - Advanced features

## Implementation Examples

Common Ground implements several key composite primitives:

### 1. Passport
- Passkey authentication
- Smart wallet integration
- Identity verification
- Trust markers

### 2. Onchain Community
- Community wallet
- Role management
- Governance mechanisms
- Resource allocation

### 3. Community Token
- Token standards
- Distribution mechanisms
- Utility design
- Value capture

## Benefits

1. **Enhanced Functionality**
   - Complex operations
   - Advanced features
   - Automated workflows
   - Integrated systems

2. **Simplified Usage**
   - User-friendly interfaces
   - Abstracted complexity
   - Consistent experience
   - Reduced friction

3. **Ecosystem Integration**
   - Cross-protocol compatibility
   - Resource optimization
   - Value alignment
   - Network effects

## Challenges

1. **Technical Integration**
   - Component coordination
   - State management
   - Error handling
   - Performance optimization

2. **Security Considerations**
   - Attack surface
   - Vulnerability assessment
   - Risk mitigation
   - Privacy protection

3. **User Experience**
   - Complexity management
   - Learning curve
   - Interface design
   - Feature discovery

## Future Directions

The evolution of composite primitives will focus on:

1. **Advanced Composition**
   - Dynamic assembly
   - Adaptive primitives
   - Smart optimization
   - Context awareness

2. **Enhanced Integration**
   - Cross-chain primitives
   - Protocol standards
   - Resource sharing
   - Value creation

3. **User Empowerment**
   - Custom composition
   - Template creation
   - Community extensions
   - Innovation enablement
</file>

<file path="_wiki/concepts/convergence.md">
---
title: "Convergence"
slug: "convergence"
aliases: ["converge", "converging"]
summary: "The trend of apps aggregating end users and commoditizing blockspace, enabled by the maturation of web3 primitives."

category: "concepts"
tags: ["adoption", "infrastructure", "scaling"]
weight: 3

related_terms:
  community_hyperstructures:
    type: "implements"
    weight: 0.8
  coordination:
    type: "related"
    weight: 0.8
  ecosystem:
    type: "implementation"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "convergence"
    quote: "Apps will tend to aggregate end users and commoditize blockspace over time. Common Ground empowers communities regardless of their technical skills to coordinate around shared purpose and take advantage of burgeoning onchain economies to accomplish their objectives."

difficulty: "intermediate"
prerequisites: ["coordination"]
recommended_next: ["ecosystem", "passport"]

graph_coordinates:
  x: 0.7
  y: 0.5
  cluster: "core"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Convergence

The convergence thesis posits an inevitable gravitational pull where applications aggregate users while blockspace becomes commoditized - a natural evolution mirroring the internet's progression from protocols to platforms. This manifests through three interlocking trends: the abstraction of cryptographic complexity into passkey-enabled UX, the maturation of smart contract standards into social primitives, and the emergence of global stablecoin networks as value rails.

Implementation requires solving the onboarding trilemma: frictionless access must coexist with self-sovereign security and cross-chain interoperability. Our LUKSO integration demonstrates this through Universal Profile logins that bundle ERC-725/735 standards with gasless transactions via ERC-4337 - reducing 12-step onboarding flows to single-click experiences.

The endgame sees applications becoming mere interfaces to a unified coordination layer, where community hyperstructures compose like TCP/IP stacks. Just as HTTP abstracted networking complexities, convergence will hide blockchain's machinery behind social primitives - identity becomes reputation, transactions become interactions, and blockspace becomes ambient infrastructure.

## Key Enablers

1. **Zero-Friction Onboarding**
   - Passkeys & biometric hardware
   - RIP7212 and optimized signing
   - Onchain account standards
   - Gas-relayer infrastructure
   - One-click fiat onramps

2. **Smart Contract Standards**
   - Multisig wallets (SAFE)
   - Onchain roles
   - Governance primitives
   - Voting mechanisms
   - Quadratic voting

3. **Infrastructure Maturity**
   - Affordable blockspace
   - Broad VM support
   - Global stablecoin adoption
   - DEX liquidity
   - DeFi lending markets

## Ecosystem Components

1. **Identity & Trust**
   - Proof of personhood
   - Decentralized verification
   - Social graph integration
   - Reputation systems

2. **Community Coordination**
   - Onchain culture
   - Coinship alignment
   - Cross-chain communication
   - Resource sharing

3. **Technical Integration**
   - PWA support
   - Native notifications
   - Mobile optimization
   - Cross-platform compatibility

## Impact

The convergence of these elements enables:

1. **User Adoption**
   - Simplified onboarding
   - Intuitive interfaces
   - Seamless experiences
   - Reduced friction

2. **Community Growth**
   - Enhanced coordination
   - Resource optimization
   - Value alignment
   - Collective action

3. **Ecosystem Development**
   - Protocol standardization
   - Infrastructure maturation
   - Market efficiency
   - Innovation acceleration
</file>

<file path="_wiki/concepts/coordination.md">
---
title: "Coordination"
slug: "coordination"
aliases: ["community-coordination", "collective-coordination"]
summary: "The fundamental challenge and opportunity of aligning diverse communities to achieve shared objectives through decentralized mechanisms."

category: "concepts"
tags: ["coordination", "community", "governance", "alignment"]
weight: 2

related_terms:
  community_hyperstructures:
    type: "enables"
    weight: 0.9
  convergence:
    type: "facilitates"
    weight: 0.8
  discourse_graphs:
    type: "implements"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "coordination"
    quote: "The coordination challenge lies at the heart of community interaction and value creation in web3."

difficulty: "intermediate"
prerequisites: ["community-hyperstructures"]
recommended_next: ["convergence", "discourse-graphs"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Coordination

The coordination problem in web3 presents a multidimensional challenge spanning technical, social, and economic layers. At its core lies the tension between individual incentive alignment and collective value creation - a modern incarnation of the socialist calculation problem enhanced by cryptographic primitives.

Technical implementations must navigate the trilemma of decentralization, scalability, and security. Smart contract-based voting systems provide auditability but risk ossification, while social layer solutions like discourse graphs enable fluid deliberation at the cost of formal accountability. The economic layer introduces additional complexity through tokenized incentive design where poorly calibrated mechanisms can lead to extractive short-termism.

Emerging solutions demonstrate promising approaches: non-plutocratic governance models using proof-of-participation, retroactive public goods funding with accountability graphs, and cross-community resource pooling through vault networks. However, the field remains early-stage, with most systems failing to surpass Dunbar's number in effective coordination capacity.

The path forward likely involves hybrid architectures combining:
1) Onchain execution guarantees for high-value decisions
2) Offchain deliberation systems with zk-reputation
3) AI-mediated mechanism design that dynamically optimizes incentive parameters

## Core Aspects

1. **Alignment Mechanisms**
   - Value alignment
   - Goal setting
   - Resource allocation
   - Decision making

2. **Community Dynamics**
   - Cross-community interaction
   - Stakeholder engagement
   - Collective action
   - Trust building

3. **Infrastructure Requirements**
   - Communication channels
   - Governance frameworks
   - Resource management
   - Impact measurement

## Implementation

1. **Technical Layer**
   - Smart contracts
   - Voting systems
   - Token mechanisms
   - Data structures

2. **Social Layer**
   - Community norms
   - Cultural alignment
   - Trust networks
   - Reputation systems

3. **Economic Layer**
   - Value distribution
   - Resource allocation
   - Incentive design
   - Market mechanisms

## Challenges

1. **Scale**
   - Network effects
   - Communication overhead
   - Decision complexity
   - Resource distribution

2. **Alignment**
   - Diverse interests
   - Goal conflicts
   - Value differences
   - Priority setting

3. **Implementation**
   - Technical barriers
   - Social friction
   - Economic constraints
   - Governance complexity

## Solutions

1. **Technical Tools**
   - Discourse graphs
   - Smart contracts
   - Token systems
   - Governance frameworks

2. **Social Mechanisms**
   - Trust networks
   - Reputation systems
   - Cultural norms
   - Community standards

3. **Economic Incentives**
   - Value sharing
   - Resource pooling
   - Reward systems
   - Market alignment
</file>

<file path="_wiki/concepts/cross-chain-interoperability.md">
---
title: "Cross-Chain Interoperability"
slug: "cross-chain-interoperability"
aliases: ["chain-interop", "blockchain-interoperability"]
summary: "The ability for different blockchain networks to communicate, share state, and transfer value seamlessly through standardized protocols and bridges."

category: "concepts"
tags: ["infrastructure", "blockchain", "protocols", "technical"]
weight: 7

related_terms:
  meta_protocol:
    type: "implements"
    weight: 0.9
  ecosystem:
    type: "enables"
    weight: 0.8
  game_of_chains:
    type: "facilitates"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "convergence"
    quote: "Cross-chain interoperability enables seamless value and state transfer across different blockchain ecosystems, creating a unified experience for communities."

difficulty: "advanced"
prerequisites: ["meta-protocol", "ecosystem"]
recommended_next: ["game-of-chains", "shared-coordination-resources"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Cross-Chain Interoperability

Cross-chain interoperability solves the blockchain trilemma's fourth dimension: network effects. Through a combination of state proofs (using zkBridge), liquidity routing (via cross-chain AMMs), and intent propagation (ERC-7687), communities can coordinate across chains without centralized custodians.

Our Fuel Ecosystem integration demonstrates three key innovations:
1) Light client bridges using Fuel's parallel execution model
2) MEV-resistant cross-chain swaps via time-locked commitments
3) Governance message passing with optimistic verification

This creates a "network of networks" effect where value accrues to the meta-protocol rather than individual chains. The endgame resembles internet peering agreements - competitive chains cooperate on interoperability standards because the rising tide lifts all boats. Vitalik's early vision of chain-agnostic dapps becomes reality as composite primitives abstract away underlying execution environments.

## Core Components

1. **Protocol Standards**
   - Message formats
   - State proofs
   - Bridge protocols
   - Security mechanisms

2. **Bridge Infrastructure**
   - Value transfer
   - State synchronization
   - Message passing
   - Security validation

3. **Integration Layer**
   - Protocol adapters
   - State management
   - Event handling
   - Error recovery

## Implementation

1. **Technical Layer**
   - Bridge contracts
   - Protocol interfaces
   - Security systems
   - State management

2. **Security Layer**
   - Validation mechanisms
   - Proof systems
   - Attack prevention
   - Risk mitigation

3. **Application Layer**
   - User interfaces
   - Integration APIs
   - Developer tools
   - Monitoring systems

## Applications

1. **Value Transfer**
   - Asset bridging
   - Token wrapping
   - State transfer
   - Message passing

2. **Protocol Integration**
   - Cross-chain governance
   - Resource sharing
   - State synchronization
   - Action coordination

3. **Ecosystem Development**
   - Network effects
   - Resource optimization
   - Market expansion
   - Innovation enablement

## Benefits

1. **Enhanced Functionality**
   - Unified experience
   - Resource sharing
   - Value transfer
   - Service integration

2. **Ecosystem Growth**
   - Network effects
   - Market expansion
   - Innovation potential
   - Resource optimization

3. **User Experience**
   - Seamless interaction
   - Reduced friction
   - Feature access
   - Value portability

## Challenges

1. **Technical Complexity**
   - Protocol differences
   - Security risks
   - Performance overhead
   - Scale requirements

2. **Integration Issues**
   - Standard adoption
   - Version management
   - Compatibility
   - Error handling

3. **Resource Management**
   - Network costs
   - Infrastructure needs
   - Maintenance overhead
   - Security requirements

## Future Directions

The evolution of cross-chain interoperability will focus on:

1. **Advanced Protocols**
   - Zero-knowledge proofs
   - Quantum resistance
   - Dynamic routing
   - Smart optimization

2. **Enhanced Integration**
   - Universal standards
   - Automated bridges
   - AI coordination
   - Security innovations

3. **Ecosystem Development**
   - Protocol discovery
   - Value networks
   - Resource sharing
   - Innovation platforms
</file>

<file path="_wiki/concepts/ecosystem-economics.md">
---
title: "Ecosystem Economics"
slug: "ecosystem-economics"
aliases: ["ecosystem-tokenomics", "chain-economics"]
summary: "The economic frameworks and mechanisms that govern value creation, capture, and distribution across blockchain ecosystems and their communities."

category: "concepts"
tags: ["economics", "ecosystem", "tokenomics", "infrastructure"]
weight: 3

related_terms:
  value_capture_models:
    type: "implements"
    weight: 0.9
  token_distribution_mechanisms:
    type: "utilizes"
    weight: 0.8
  meta_protocol:
    type: "enables"
    weight: 0.7

difficulty: "advanced"
prerequisites: ["value-capture-models", "token-distribution-mechanisms"]
recommended_next: ["onchain-culture", "community-sovereignty"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Ecosystem Economics

Ecosystem economics transcends traditional tokenomics by modeling communities as n-dimensional value networks. The CG token model introduces three novel mechanisms:
1) Liquidity-time derivatives (Spark's velocity-based conversions)
2) Protocol-owned liquidity via ERC-4626 vaults
3) Cross-ecosystem value accounting using hypercerts

These tools enable communities to practice cryptographic Keynesianism - protocol-level fiscal policies that stabilize markets while funding public goods. The CG Dollar's design particularly innovates by wrapping yield-bearing assets (sDAI) while socializing returns, creating a hybrid between central bank digital currencies and cooperative credit systems.

The next evolution involves AI-managed liquidity pools that optimize for both financial returns and community health metrics. Imagine Uniswap V4 hooks that adjust fees based on participation entropy and impact certificates - DeFi that grows more equitable as it scales.

## Core Components

1. **Infrastructure Economics**
   - Blockspace pricing
   - Gas mechanisms
   - Sequencer fees
   - Network costs
   - Resource allocation

2. **Community Economics**
   - Grant programs
   - Development funds
   - Community treasuries
   - Incentive systems
   - Value distribution

3. **Market Dynamics**
   - Token economics
   - Liquidity mechanisms
   - Price discovery
   - Market making
   - Trading infrastructure

## Implementation Mechanisms

The ecosystem economic framework operates through:

### 1. Value Creation
- Infrastructure development
- Protocol innovation
- Community building
- Market making
- Public goods

### 2. Value Capture
- Transaction fees
- Protocol revenue
- Treasury management
- Token appreciation
- Service fees

### 3. Value Distribution
- Community rewards
- Development funding
- Infrastructure grants
- Public goods funding
- Ecosystem growth

## Benefits

1. **Sustainable Growth**
   - Resource efficiency
   - Value retention
   - Market stability
   - Long-term viability

2. **Community Development**
   - Aligned incentives
   - Resource access
   - Innovation funding
   - Collective benefit

3. **Network Effects**
   - User adoption
   - Protocol integration
   - Market depth
   - Ecosystem expansion

## Challenges

1. **Economic Balance**
   - Resource allocation
   - Incentive design
   - Market stability
   - Value distribution

2. **Technical Complexity**
   - System integration
   - Scale requirements
   - Performance optimization
   - Security concerns

3. **Market Dynamics**
   - Competition
   - Value volatility
   - Liquidity management
   - User adoption

## Future Directions

The evolution of ecosystem economics will focus on:

1. **Advanced Systems**
   - Dynamic pricing
   - Adaptive mechanisms
   - AI optimization
   - Resource efficiency

2. **Enhanced Integration**
   - Cross-ecosystem coordination
   - Protocol interoperability
   - Market efficiency
   - Value flows

3. **Community Innovation**
   - Custom models
   - Experimental designs
   - Impact measurement
   - Value creation
</file>

<file path="_wiki/concepts/game-of-chains.md">
---
title: "Game of Chains"
slug: "game-of-chains"
aliases: ["chain-game", "blockchain-game-theory"]
summary: "A game-theoretic framework describing how communities compete and cooperate across different blockchain ecosystems to maximize value and impact."

category: "concepts"
tags: ["game-theory", "economics", "blockchain", "strategy"]
weight: 4

related_terms:
  ecosystem:
    type: "implements"
    weight: 0.9
  degen_value_capture:
    type: "utilizes"
    weight: 0.8
  regen_value_redistribution:
    type: "enables"
    weight: 0.8

sources:
  - document: "whitepaper"
    section: "game_of_chains"
    quote: "The Game of Chains describes how communities compete and cooperate across different blockchain ecosystems to maximize their value creation and impact."

difficulty: "advanced"
prerequisites: ["ecosystem", "degen-value-capture"]
recommended_next: ["regen-value-redistribution", "convergence"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Game of Chains

The Game of Chains framework reveals how token distribution mechanics act as DNA shaping community evolution. Through rigorous analysis of memecoin launches, DAO formations, and protocol treasuries, we observe three evolutionary patterns: 

1) **Velocity-Driven Communities** (high token velocity → rapid feature iteration)
2) **Stakeholder-Aligned Networks** (concentrated holdings → protocol ossification) 
3) **Participation-Maximized Ecosystems** (broad distribution → governance paralysis)

The $CG model introduces a fourth path: **Temporal Stake Segmentation**. By separating transient speculation ($CG Blue) from persistent stewardship ($CG Red), communities gain adaptive advantages - rapid capital formation combined with long-term orientation. This mirrors biological systems separating somatic and germ cells, enabling both immediate responsiveness and genetic continuity.

The breakthrough lies in decay curve mathematics: $CG Red's non-transferability combined with hyperbolic decay (1/(1 + kt)) creates time-binding social contracts. Participants must continually reinvest attention to maintain influence, preventing the tragedy of the commons that plagues static token models.

## Core Dynamics

1. **Competition**
   - Resource allocation
   - Market positioning
   - Value capture
   - User acquisition

2. **Cooperation**
   - Resource sharing
   - Value creation
   - Network effects
   - Protocol alignment

3. **Strategy**
   - Ecosystem selection
   - Resource deployment
   - Alliance formation
   - Value optimization

## Implementation

1. **Economic Layer**
   - Value flows
   - Token mechanics
   - Market dynamics
   - Resource allocation

2. **Social Layer**
   - Community alignment
   - Network building
   - Trust formation
   - Reputation systems

3. **Technical Layer**
   - Protocol integration
   - Cross-chain bridges
   - State management
   - Resource optimization

## Applications

1. **Ecosystem Growth**
   - Community building
   - Value creation
   - Network expansion
   - Resource optimization

2. **Value Creation**
   - Market development
   - Protocol integration
   - Resource allocation
   - Impact maximization

3. **Strategic Planning**
   - Ecosystem selection
   - Resource deployment
   - Partnership formation
   - Growth optimization
</file>

<file path="_wiki/concepts/identity-authentication.md">
---
title: "Identity and Authentication"
slug: "identity-authentication"
aliases: ["web3-identity", "blockchain-auth"]
summary: "The technical foundations and mechanisms for establishing, verifying, and managing digital identity and authentication in web3 communities."

category: "concepts"
tags: ["technical", "identity", "security", "authentication"]
weight: 5

related_terms:
  zero_friction_onboarding:
    type: "implements"
    weight: 0.9
  trust_networks:
    type: "enables"
    weight: 0.8
  cross_chain_interoperability:
    type: "facilitates"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["cross-chain-interoperability", "trust-networks"]
recommended_next: ["smart-contract-standards", "onchain-culture"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Identity and Authentication

Web3 identity systems solve the Zooko's triangle paradox through cryptographic stratification. The Passport system demonstrates this via:

1) **Base Layer**: Decentralized identifiers (DIDs) as immutable root keys
2) **Attestation Layer**: ERC-735 claims with adjustable trust horizons
3) **Application Layer**: Context-aware persona switching via ERC-5560

This architecture enables pseudonymity spectra - users fluidly adjust identity resolution based on context. A developer might use a high-resolution professional identity for DAO contributions while employing disposable personas for governance voting, all anchored to a single DID.

The LUKSO integration pioneers self-sovereign recovery through social graphs: 3-of-5 trusted contacts can regenerate keys via MPC ceremonies, eliminating single points of failure. This combines the security of multisig with the fluidity of social relationships, creating identity systems that are both robust and humane.

## Core Components

1. **Identity Systems**
   - Decentralized identifiers
   - Verifiable credentials
   - Identity aggregation
   - Profile management
   - Recovery mechanisms

2. **Authentication Methods**
   - Passkey standards
   - Biometric verification
   - Multi-factor auth
   - Social recovery
   - Hardware security

3. **Privacy Controls**
   - Data minimization
   - Selective disclosure
   - Zero-knowledge proofs
   - Encryption standards
   - Access control

## Implementation Mechanisms

Identity and authentication are implemented through:

### 1. Technical Standards
- DID protocols
- Credential formats
- Authentication flows
- Security protocols
- Privacy frameworks

### 2. User Systems
- Wallet integration
- Profile management
- Recovery options
- Permission controls
- Identity portability

### 3. Security Layers
- Cryptographic proofs
- Access management
- Threat prevention
- Audit systems
- Recovery protocols

## Benefits

1. **Enhanced Security**
   - Sovereign identity
   - Attack resistance
   - Privacy protection
   - Data control

2. **User Experience**
   - Seamless authentication
   - Identity portability
   - Profile management
   - Recovery options

3. **System Integration**
   - Standard compliance
   - Protocol compatibility
   - Service integration
   - Value preservation

## Challenges

1. **Technical Complexity**
   - Standard adoption
   - Integration issues
   - Performance needs
   - Security balance

2. **User Management**
   - Recovery processes
   - Privacy controls
   - Feature discovery
   - Mental models

3. **System Evolution**
   - Protocol updates
   - Standard changes
   - Security threats
   - Privacy requirements

## Future Directions

The evolution of identity and authentication will focus on:

1. **Advanced Systems**
   - Quantum-safe crypto
   - AI integration
   - Dynamic security
   - Context awareness

2. **Enhanced Privacy**
   - Zero-knowledge systems
   - Privacy computation
   - Data sovereignty
   - Access control

3. **User Innovation**
   - Custom identities
   - Social systems
   - Recovery networks
   - Trust frameworks
</file>

<file path="_wiki/concepts/meta-protocol.md">
---
title: "Meta Protocol"
slug: "meta-protocol"
aliases: ["orchestration-layer", "protocol-orchestration"]
summary: "A protocol layer that orchestrates and aligns multiple underlying protocols and primitives to enable complex community interactions."

category: "concepts"
tags: ["infrastructure", "protocols", "web3", "coordination"]
weight: 3

related_terms:
  community_hyperstructures:
    type: "implements"
    weight: 0.9
  composite_primitives:
    type: "enables"
    weight: 0.8
  coordination:
    type: "facilitates"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "introduction"
    quote: "Common Ground functions as a meta protocol that aligns emerging web3 primitives to enable fluid interaction, governance, and value exchange among communities."

difficulty: "advanced"
prerequisites: ["community-hyperstructures", "composite-primitives"]
recommended_next: ["coordination", "convergence"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Meta Protocol

The meta-protocol emerges as a Schelling point for decentralized coordination - a minimal set of rules that allow heterogeneous systems to align incentives without sacrificing sovereignty. Unlike monolithic protocols that enforce top-down standards, this orchestration layer employs mechanism design to create positive-sum games between communities.

Our implementation uses three key mechanisms:
1) Cross-protocol state proofs via zk-SNARKs
2) Liquidity-sensitive voting weights (LSVW) that balance token holdings with community participation
3) Harberger-taxed namespace markets for ecosystem slot allocation

The genius lies in negative feedback loops: protocols that extract disproportionate value see their governance influence decay exponentially, while those contributing public goods gain amplified voice. This creates an evolutionary pressure towards ecosystem symbiosis rather than parasitic relationships.

Future iterations will introduce re-staking mechanics where protocol security becomes a composable resource. Imagine communities "renting" Ethereum's validator set for critical decisions while using lighter consensus for routine operations - a hybrid model blending shared security with localized autonomy.

## Core Functions

1. **Protocol Orchestration**
   - Primitive alignment
   - State coordination
   - Interface standardization
   - Resource optimization

2. **Community Integration**
   - Interaction facilitation
   - Governance enablement
   - Value exchange
   - Resource sharing

3. **System Architecture**
   - Protocol bridges
   - State management
   - Security guarantees
   - Scalability design

## Implementation

1. **Technical Layer**
   - Protocol interfaces
   - State synchronization
   - Security mechanisms
   - Performance optimization

2. **Integration Layer**
   - Community systems
   - Governance frameworks
   - Value networks
   - Resource management

3. **Coordination Layer**
   - Cross-protocol communication
   - State alignment
   - Resource allocation
   - Value transfer

## Applications

1. **Community Operations**
   - Governance coordination
   - Resource management
   - Value exchange
   - State synchronization

2. **Protocol Integration**
   - System alignment
   - Resource optimization
   - State management
   - Security enhancement

3. **Value Networks**
   - Exchange facilitation
   - Resource allocation
   - Market creation
   - Network effects
</file>

<file path="_wiki/concepts/onchain-culture.md">
---
title: "Onchain Culture"
slug: "onchain-culture"
aliases: ["blockchain-culture", "web3-culture"]
summary: "The emergent social norms, values, and practices that develop within web3 communities through their interactions with blockchain systems and protocols."

category: "concepts"
tags: ["culture", "community", "social", "governance"]
weight: 8

related_terms:
  onchain_community:
    type: "shapes"
    weight: 0.9
  trust_networks:
    type: "influences"
    weight: 0.8
  coordination:
    type: "enables"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "coordination"
    quote: "Onchain culture emerges from the intersection of community values, governance mechanisms, and blockchain interactions, shaping how communities coordinate and create value."

difficulty: "intermediate"
prerequisites: ["onchain-community", "trust-networks"]
recommended_next: ["coordination", "game-of-chains"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Onchain Culture

Onchain culture emerges from the cryptoeconomic equivalent of Dunbar's layers - nested coordination games operating at different resolution levels:

1) **Microculture** (150 members): High-trust interactions enabled by pseudonymous reputation
2) **Mesoculture** (1500 members): Protocol-aligned incentives with quadratic voting
3) **Macroculture** (15k+): Liquid democracy guided by AI sentiment oracles

The Fuel Ecosystem's growth demonstrates mesoculture dynamics: their "contributor merit" system weights participation by both tenure (time-locked NFTs) and peer endorsement (ERC-5484). This creates emergent social norms where newcomers earn trust through verifiable contributions rather than capital alone.

The next frontier involves cultural DAOs that programmatically evolve social contracts. Imagine communities where constitutional amendments automatically trigger based on participation entropy metrics - digital nations that harden against stagnation through algorithmic checks and balances.

## Core Elements

1. **Community Values**
   - Decentralization
   - Transparency
   - Sovereignty
   - Collaboration

2. **Social Practices**
   - Governance participation
   - Value creation
   - Resource sharing
   - Trust building

3. **Cultural Norms**
   - Decision making
   - Conflict resolution
   - Resource allocation
   - Contribution recognition

## Implementation

1. **Social Layer**
   - Community formation
   - Value alignment
   - Norm development
   - Cultural evolution

2. **Governance Layer**
   - Decision processes
   - Role definition
   - Power distribution
   - Accountability systems

3. **Technical Layer**
   - Protocol interaction
   - Tool adoption
   - Resource management
   - Value exchange

## Applications

1. **Community Building**
   - Identity formation
   - Value alignment
   - Trust development
   - Cultural growth

2. **Governance Design**
   - Process creation
   - Role definition
   - Power balance
   - Conflict resolution

3. **Value Creation**
   - Resource allocation
   - Contribution rewards
   - Innovation support
   - Impact measurement
</file>

<file path="_wiki/concepts/protocol-discovery.md">
---
title: "Protocol Discovery"
slug: "protocol-discovery"
aliases: ["protocol-exploration", "blockchain-discovery"]
summary: "The process and mechanisms by which communities discover, evaluate, and integrate new protocols and primitives into their operations."

category: "concepts"
tags: ["protocols", "discovery", "integration", "innovation"]
weight: 9

related_terms:
  meta_protocol:
    type: "enables"
    weight: 0.9
  ecosystem:
    type: "facilitates"
    weight: 0.8
  cross_chain_interoperability:
    type: "supports"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "convergence"
    quote: "Protocol discovery mechanisms enable communities to find, evaluate, and integrate new protocols and primitives that enhance their capabilities and value creation potential."

difficulty: "intermediate"
prerequisites: ["meta-protocol", "ecosystem"]
recommended_next: ["cross-chain-interoperability", "shared-coordination-resources"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Protocol Discovery

Protocol Discovery encompasses the processes and mechanisms that enable communities to identify, evaluate, and integrate new protocols and primitives into their operational frameworks.

## Core Components

1. **Discovery Mechanisms**
   - Protocol registries
   - Integration guides
   - Evaluation frameworks
   - Community feedback

2. **Assessment Tools**
   - Security analysis
   - Performance metrics
   - Integration costs
   - Value potential

3. **Integration Support**
   - Technical guides
   - Best practices
   - Implementation patterns
   - Support resources

## Implementation

1. **Discovery Layer**
   - Protocol indexing
   - Search mechanisms
   - Filtering systems
   - Recommendation engines

2. **Evaluation Layer**
   - Analysis tools
   - Testing frameworks
   - Comparison metrics
   - Risk assessment

3. **Integration Layer**
   - Implementation guides
   - Technical support
   - Resource allocation
   - Performance monitoring

## Applications

1. **Community Growth**
   - Capability expansion
   - Value creation
   - Innovation support
   - Resource optimization

2. **Protocol Integration**
   - Technical assessment
   - Implementation planning
   - Resource allocation
   - Performance tracking

3. **Ecosystem Development**
   - Protocol adoption
   - Innovation fostering
   - Value creation
   - Network effects
</file>

<file path="_wiki/concepts/shared-coordination-resources.md">
---
title: "Shared Coordination Resources"
slug: "shared-coordination-resources"
aliases: ["coordination-resources", "shared-resources"]
summary: "Common infrastructure and tools that enable efficient coordination and value creation across multiple communities and ecosystems."

category: "concepts"
tags: ["infrastructure", "coordination", "resources", "community"]
weight: 5

related_terms:
  meta_protocol:
    type: "implements"
    weight: 0.9
  coordination:
    type: "enables"
    weight: 0.8
  ecosystem:
    type: "provides"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "shared_coordination_resources"
    quote: "Shared coordination resources provide the common infrastructure and tools that enable efficient coordination and value creation across communities."

difficulty: "intermediate"
prerequisites: ["meta-protocol", "coordination"]
recommended_next: ["ecosystem", "game-of-chains"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Shared Coordination Resources

Shared Coordination Resources represent the common infrastructure, tools, and mechanisms that enable efficient coordination and value creation across multiple communities and ecosystems.

## Core Components

1. **Infrastructure**
   - Communication channels
   - Governance frameworks
   - Resource management
   - Value exchange

2. **Tools**
   - Coordination platforms
   - Decision systems
   - Resource tracking
   - Impact measurement

3. **Mechanisms**
   - Value distribution
   - Resource allocation
   - Decision making
   - Impact assessment

## Implementation

1. **Technical Layer**
   - Protocol standards
   - Integration APIs
   - Data structures
   - Security systems

2. **Social Layer**
   - Community interfaces
   - Governance frameworks
   - Trust networks
   - Reputation systems

3. **Economic Layer**
   - Resource pools
   - Value flows
   - Market mechanisms
   - Incentive design

## Applications

1. **Community Coordination**
   - Resource sharing
   - Decision alignment
   - Value creation
   - Impact optimization

2. **Resource Management**
   - Asset allocation
   - Tool sharing
   - Infrastructure use
   - Cost optimization

3. **Value Creation**
   - Network effects
   - Resource efficiency
   - Impact scaling
   - Innovation enablement
</file>

<file path="_wiki/concepts/token-distribution-mechanisms.md">
---
title: "Token Distribution Mechanisms"
slug: "token-distribution-mechanisms"
aliases: ["token-distribution", "distribution-methods"]
summary: "Different approaches to distributing community tokens that shape community formation, member engagement, and long-term value creation."

category: "concepts"
tags: ["economics", "tokens", "distribution", "community"]
weight: 3

related_terms:
  community_token:
    type: "implements"
    weight: 0.9
  composite_primitives:
    type: "utilizes"
    weight: 0.7
  ecosystem:
    type: "context"
    weight: 0.6

difficulty: "intermediate"
prerequisites: ["composite-primitives", "community-token"]
recommended_next: ["value-capture-models", "ecosystem-economics"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Token Distribution Mechanisms

Token distribution mechanisms are the methods and strategies used to allocate community tokens to participants. The choice of distribution mechanism significantly impacts community formation, member behavior, and long-term sustainability.

## Core Components

1. **Distribution Methods**
   - Fair launches
   - Airdrops
   - Token sales
   - Earned distribution
   - Retroactive rewards

2. **Distribution Parameters**
   - Token supply
   - Allocation ratios
   - Vesting schedules
   - Lock-up periods
   - Distribution curves

3. **Community Considerations**
   - Target audience
   - Member lifecycle
   - Engagement metrics
   - Value alignment
   - Growth objectives

## Implementation Factors

The optimal distribution mechanism depends on several key factors:

### 1. Community Purpose
- Mission alignment
- Value proposition
- Target demographics
- Growth strategy

### 2. Token Design
- Token standard
- Utility functions
- Governance rights
- Economic model

### 3. Market Context
- Ecosystem dynamics
- Market conditions
- Liquidity requirements
- Competitive landscape

## Benefits

1. **Community Formation**
   - Aligned incentives
   - Fair participation
   - Value distribution
   - Sustainable growth

2. **Member Engagement**
   - Active participation
   - Long-term commitment
   - Value creation
   - Community ownership

3. **Economic Sustainability**
   - Resource allocation
   - Value capture
   - Market stability
   - Growth funding

## Challenges

1. **Design Complexity**
   - Parameter optimization
   - Incentive alignment
   - Game theory
   - Market dynamics

2. **Implementation Risks**
   - Technical execution
   - Market manipulation
   - Regulatory compliance
   - Community acceptance

3. **Long-term Management**
   - Supply management
   - Price stability
   - Community evolution
   - Value sustainability

## Future Directions

The evolution of distribution mechanisms will focus on:

1. **Advanced Models**
   - Dynamic distribution
   - Adaptive mechanisms
   - AI-driven optimization
   - Context awareness

2. **Enhanced Fairness**
   - Sybil resistance
   - Value attribution
   - Contribution measurement
   - Impact assessment

3. **Community Innovation**
   - Custom mechanisms
   - Hybrid models
   - Experimental designs
   - Cross-community coordination
</file>

<file path="_wiki/concepts/trust-networks.md">
---
title: "Trust Networks"
slug: "trust-networks"
aliases: ["web3-trust", "trust-systems"]
summary: "Decentralized systems of reputation and trust that enable secure and efficient coordination among community members and across ecosystems."

category: "concepts"
tags: ["trust", "reputation", "coordination", "security"]
weight: 6

related_terms:
  passport:
    type: "implements"
    weight: 0.9
  coordination:
    type: "enables"
    weight: 0.8
  onchain_community:
    type: "utilizes"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "coordination"
    quote: "Trust networks form the foundation of effective community coordination, enabling secure and efficient interaction among members and across ecosystem boundaries."

difficulty: "intermediate"
prerequisites: ["passport", "coordination"]
recommended_next: ["onchain-community", "shared-coordination-resources"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Trust Networks

Trust networks in web3 solve the Byzantine Generals Problem through economic topology. Our analysis reveals three trust geometries:

1) **Star Networks**: Centralized around protocol founders (high efficiency, low resilience)
2) **Mesh Networks**: Distributed peer-to-peer trust (high resilience, low coordination)
3) **Small-World Networks**: Optimized clusters with bridging nodes (balanced efficiency/resilience)

The CG reputation system implements small-world dynamics through:
- Local trust clusters (community-specific reputation)
- Bridging oracles (cross-community hypercerts)
- Adaptive decay rates (activity-sensitive trust metrics)

This creates a "trust L2" where local interactions scale globally without centralization. The breakthrough lies in zkReputation proofs - users can verify trust scores without exposing individual interactions, preserving privacy while enabling sybil resistance.

Future systems may employ neural trust models where AI agents predict reliability based on behavioral patterns, creating dynamic trust markets that price risk in real-time.

## Core Components

1. **Trust Mechanisms**
   - Reputation systems
   - Verification methods
   - Trust scoring
   - Identity validation

2. **Network Structure**
   - Trust relationships
   - Network topology
   - Connection patterns
   - Growth dynamics

3. **Security Features**
   - Sybil resistance
   - Attack prevention
   - Risk mitigation
   - Trust preservation

## Implementation

1. **Technical Layer**
   - Identity systems
   - Verification protocols
   - Trust algorithms
   - Security measures

2. **Social Layer**
   - Reputation building
   - Trust formation
   - Community norms
   - Social validation

3. **Integration Layer**
   - Protocol connections
   - Network bridges
   - Data sharing
   - Trust transfer

## Applications

1. **Community Building**
   - Member verification
   - Trust establishment
   - Relationship building
   - Network growth

2. **Coordination Enhancement**
   - Secure interaction
   - Efficient collaboration
   - Risk reduction
   - Trust optimization

3. **Ecosystem Development**
   - Cross-community trust
   - Network effects
   - Value creation
   - Growth facilitation
</file>

<file path="_wiki/concepts/value-capture-models.md">
---
title: "Value Capture Models"
slug: "value-capture-models"
aliases: ["value-capture", "degen-regen-mechanics"]
summary: "Dual approaches to value creation and distribution in web3 communities, balancing short-term value capture (Degen) with long-term value redistribution (Regen)."

category: "concepts"
tags: ["economics", "value", "sustainability", "mechanics"]
weight: 3

related_terms:
  token_distribution_mechanisms:
    type: "implements"
    weight: 0.9
  ecosystem_economics:
    type: "relates"
    weight: 0.8
  community_token:
    type: "utilizes"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["token-distribution-mechanisms"]
recommended_next: ["ecosystem-economics", "onchain-culture"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Value Capture Models

The Degen/Regen duality represents web3's answer to capitalism's innovation/distribution paradox. Our Spark tokenomics demonstrate a Hamiltonian synthesis: speculative liquidity pools fund protocol R&D (Degen), while algorithmically stabilized CG Dollars redistribute yield to public goods (Regen).

The innovation lies in time-wrapped value flows:
- Degen assets ($CG Blue) have linear vesting schedules
- Regen assets ($CG Red) follow inverse decay curves
- Protocol fees auto-convert between pools based on velocity metrics

This creates a self-balancing ecosystem where short-term speculation funds long-term infrastructure, while community contributions earn non-dilutive equity. The model draws inspiration from quadratic funding but adds temporal dimensions - recognizing that value creation and capture exist on different time horizons.

The next frontier involves AI-curated bonding curves that dynamically adjust parameters based on:
1) Community health metrics (participation entropy)
2) Market depth analysis (liquidity fractals)
3) Public goods ROI (impact derivatives)

## Core Mechanics

1. **Degen Value Capture**
   - Market making
   - Yield farming
   - Trading incentives
   - Liquidity provision
   - Short-term rewards

2. **Regen Value Redistribution**
   - Public goods funding
   - Impact investing
   - Community rewards
   - Sustainable development
   - Long-term alignment

3. **Hybrid Approaches**
   - Balanced incentives
   - Dual token systems
   - Adaptive mechanisms
   - Value cycling
   - Feedback loops

## Implementation Strategies

The implementation of value capture models involves:

### 1. Market Mechanisms
- Price discovery
- Liquidity pools
- Trading pairs
- Bonding curves
- Automated market makers

### 2. Community Incentives
- Contribution rewards
- Governance rights
- Staking benefits
- Impact certificates
- Reputation systems

### 3. Value Distribution
- Revenue sharing
- Impact funding
- Community treasury
- Grant programs
- Development funds

## Benefits

1. **Economic Sustainability**
   - Balanced growth
   - Sustainable funding
   - Value retention
   - Market stability

2. **Community Alignment**
   - Shared incentives
   - Long-term thinking
   - Value creation
   - Collective benefit

3. **Ecosystem Development**
   - Innovation funding
   - Public goods
   - Infrastructure
   - Research & Development

## Challenges

1. **Balance Management**
   - Incentive design
   - Value stability
   - Market dynamics
   - Community needs

2. **Implementation Complexity**
   - Technical requirements
   - Market integration
   - Regulatory compliance
   - User experience

3. **Sustainability Concerns**
   - Long-term viability
   - Market volatility
   - Community engagement
   - Value retention

## Future Directions

The evolution of value capture models will focus on:

1. **Advanced Mechanisms**
   - Dynamic balancing
   - AI-driven optimization
   - Adaptive systems
   - Context awareness

2. **Enhanced Integration**
   - Cross-chain value flows
   - Ecosystem alignment
   - Protocol synergies
   - Market efficiency

3. **Community Innovation**
   - Custom models
   - Experimental designs
   - Impact measurement
   - Value attribution
</file>

<file path="_wiki/concepts/zero-friction-onboarding.md">
---
title: "Zero-Friction Onboarding"
slug: "zero-friction-onboarding"
aliases: ["seamless-onboarding", "frictionless-entry"]
summary: "A comprehensive approach to removing technical barriers and simplifying the process of joining and participating in web3 communities."

category: "concepts"
tags: ["technical", "user-experience", "onboarding", "accessibility"]
weight: 5

related_terms:
  trust_networks:
    type: "enables"
    weight: 0.9
  cross_chain_interoperability:
    type: "facilitates"
    weight: 0.8
  identity_authentication:
    type: "implements"
    weight: 0.7

difficulty: "intermediate"
prerequisites: ["trust-networks"]
recommended_next: ["cross-chain-interoperability", "identity-authentication"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Zero-Friction Onboarding

Zero-friction onboarding represents a comprehensive technical and user experience approach that minimizes barriers to entry for new participants in web3 communities, making blockchain technology accessible to all users regardless of their technical expertise.

## Core Components

1. **Technical Infrastructure**
   - Passkey integration
   - Smart contract wallets
   - Gas abstraction
   - Transaction relayers
   - Fiat onramps

2. **User Experience**
   - One-click signup
   - Progressive disclosure
   - Intuitive interfaces
   - Mobile optimization
   - Error prevention

3. **Identity Management**
   - Social authentication
   - Credential portability
   - Recovery mechanisms
   - Privacy controls
   - Profile management

## Implementation Mechanisms

Zero-friction onboarding is achieved through:

### 1. Authentication Systems
- Biometric verification
- Passkey standards
- Social recovery
- Multi-device support
- Security layers

### 2. Transaction Management
- Gas sponsorship
- Batched transactions
- Meta-transactions
- Fee abstraction
- Smart wallets

### 3. User Interface
- Progressive web apps
- Native integration
- Push notifications
- Offline support
- Cross-platform compatibility

## Benefits

1. **Enhanced Accessibility**
   - Reduced complexity
   - Broader adoption
   - Lower barriers
   - Inclusive design

2. **Improved Security**
   - Built-in protection
   - Recovery options
   - Risk mitigation
   - User education

3. **Better Retention**
   - User satisfaction
   - Quick activation
   - Value discovery
   - Community integration

## Challenges

1. **Technical Integration**
   - System complexity
   - Standard adoption
   - Performance optimization
   - Security balance

2. **User Education**
   - Mental models
   - Feature discovery
   - Security awareness
   - Value proposition

3. **Resource Management**
   - Gas costs
   - Infrastructure scaling
   - Support requirements
   - Maintenance needs

## Future Directions

The evolution of zero-friction onboarding will focus on:

1. **Advanced Systems**
   - AI assistance
   - Predictive onboarding
   - Context awareness
   - Smart optimization

2. **Enhanced Integration**
   - Cross-chain onboarding
   - Protocol standards
   - Identity portability
   - Value preservation

3. **User Innovation**
   - Custom pathways
   - Social onboarding
   - Community tools
   - Growth patterns
</file>

<file path="_wiki/glossary/antifragility.md">
---
title: "Antifragility"
slug: "antifragility"
aliases: ["antifragile-systems", "system-resilience"]
summary: "The property of systems that not only resist shocks and disruptions but actually improve and grow stronger from them."

category: "glossary"
tags: ["systems", "resilience", "adaptation", "growth"]
weight: 8

related_terms:
  community_hyperstructures:
    type: "implements"
    weight: 0.9
  meta_protocol:
    type: "enables"
    weight: 0.8
  ecosystem:
    type: "exhibits"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "glossary"
    quote: "Antifragility describes systems that not only withstand shocks but actually improve and grow stronger from disruptions and challenges."

difficulty: "intermediate"
prerequisites: ["community-hyperstructures"]
recommended_next: ["meta-protocol", "ecosystem"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Antifragility

Antifragility represents a system property where exposure to shocks, volatility, and disruptions leads to strengthening and improvement rather than degradation or failure.

## Core Characteristics

1. **Adaptation**
   - Learning from stress
   - System evolution
   - Dynamic response
   - Growth through chaos

2. **Resilience**
   - Shock absorption
   - Recovery capacity
   - Stress tolerance
   - Failure resistance

3. **Enhancement**
   - Strength building
   - Capability growth
   - System improvement
   - Evolution acceleration

## Implementation

1. **System Design**
   - Redundancy
   - Modularity
   - Adaptability
   - Self-repair

2. **Response Mechanisms**
   - Stress detection
   - Adaptation triggers
   - Recovery processes
   - Growth pathways

3. **Learning Systems**
   - Pattern recognition
   - Knowledge capture
   - Evolution mechanisms
   - Improvement cycles

## Applications

1. **Protocol Design**
   - System architecture
   - Failure handling
   - Growth mechanisms
   - Evolution patterns

2. **Community Systems**
   - Governance adaptation
   - Resource resilience
   - Value preservation
   - Growth through challenge

3. **Ecosystem Development**
   - Network resilience
   - Value enhancement
   - Innovation fostering
   - Sustainable growth
</file>

<file path="_wiki/glossary/cg-token.md">
---
title: "CG Token"
slug: "cg-token"
aliases: ["$cg", "common-ground-token"]
summary: "The dual-flavored (blue and red) utility token of Common Ground that enables staking rewards, governance participation, and ecosystem cooperation."

category: "glossary"
tags: ["token", "governance", "staking", "ecosystem"]
weight: 9

related_terms:
  spark:
    type: "rewards"
    weight: 0.9
  community_sovereignty:
    type: "enables"
    weight: 0.8
  degen_value_capture:
    type: "implements"
    weight: 0.7

sources:
  - document: "token"
    section: "introduction"
    quote: "The $CG Token sits at the heart of Common Ground. It exists in two flavors, called red and blue."

difficulty: "intermediate"
prerequisites: ["spark"]
recommended_next: ["community-sovereignty", "degen-value-capture"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# CG Token

The CG Token ($CG) is the core utility token of Common Ground, featuring an innovative dual-flavor design that balances speculative and contributive value.

## Core Features

1. **Token Flavors**
   - Blue: Speculative, tradeable token
   - Red: Non-transferrable work token
   - Equal governance rights
   - Complementary functions

2. **Utility Functions**
   - Staking rewards
   - Governance power
   - Ecosystem cooperation
   - Value alignment

3. **Distribution Model**
   - Community fund (51%)
   - Team allocation (20%)
   - Investor distribution (7%)
   - Treasury reserve (22%)

## Implementation

1. **Token Design**
   - ERC20 standard
   - Dual contract system
   - Auto-decay mechanism
   - Governance integration

2. **Economic Model**
   - Value capture
   - Reward distribution
   - Staking mechanics
   - Market dynamics

3. **Governance Structure**
   - Voting rights
   - Proposal power
   - Decision making
   - Community control

## Applications

1. **Platform Governance**
   - Decision making
   - Resource allocation
   - Feature development
   - Ecosystem direction

2. **Value Creation**
   - Staking rewards
   - Contribution incentives
   - Market participation
   - Economic alignment

3. **Ecosystem Development**
   - Community building
   - Partnership formation
   - Innovation funding
   - Growth facilitation
</file>

<file path="_wiki/glossary/coinship.md">
---
title: "Coinship"
slug: "coinship"
aliases: ["token-coordination", "coin-coordination"]
summary: "A form of community coordination and alignment achieved through shared token ownership and participation in token-based activities."

category: "glossary"
tags: ["tokens", "coordination", "community", "alignment"]
weight: 2

related_terms:
  community_token:
    type: "implements"
    weight: 0.9
  degen_value_capture:
    type: "utilizes"
    weight: 0.8
  coordination:
    type: "mechanism"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "convergence"
    quote: "emergence of onchain culture and communities coordinating around coinship"

difficulty: "intermediate"
prerequisites: ["community-token"]
recommended_next: ["degen-value-capture", "regen-value-redistribution"]

graph_coordinates:
  x: 0.3
  y: 0.1
  cluster: "theory"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Coinship

Coinship represents a novel form of social coordination where communities align and organize around shared token ownership and participation in token-based activities. It's a fundamental concept in web3 that combines economic incentives with social coordination.

## Core Concepts

1. **Token-Based Alignment**
   - Shared ownership
   - Economic incentives
   - Value alignment
   - Community participation

2. **Coordination Mechanisms**
   - Token distribution
   - Governance rights
   - Value capture
   - Resource allocation

3. **Community Dynamics**
   - Social cohesion
   - Shared purpose
   - Collective action
   - Group identity

## Implementation

1. **Token Design**
   - Distribution models
   - Governance rights
   - Utility features
   - Value accrual

2. **Community Structure**
   - Participation rules
   - Decision making
   - Resource sharing
   - Value distribution

3. **Incentive Alignment**
   - Reward systems
   - Contribution tracking
   - Value recognition
   - Growth incentives

## Applications

1. **Community Building**
   - Member attraction
   - Value alignment
   - Participation incentives
   - Growth mechanisms

2. **Governance**
   - Decision rights
   - Resource allocation
   - Value distribution
   - Strategic direction

3. **Value Creation**
   - Token appreciation
   - Resource development
   - Community growth
   - Network effects
</file>

<file path="_wiki/glossary/common-dollar.md">
---
title: "Common Dollar"
slug: "common-dollar"
aliases: ["cg-dollar", "common-ground-stablecoin"]
summary: "A USD-referenced stablecoin that wraps yield-bearing stablecoins like sDAI, allowing Common Ground to capture yield for platform sustainability while providing users with stable value storage."

category: "glossary"
tags: ["stablecoin", "economics", "yield", "sustainability"]
weight: 7

related_terms:
  spark:
    type: "complements"
    weight: 0.9
  degen_value_capture:
    type: "implements"
    weight: 0.8
  regen_value_redistribution:
    type: "enables"
    weight: 0.7

sources:
  - document: "sustain"
    section: "value-capture"
    quote: "Common Ground could introduce an onchain version of Spark, in the form of a USD-referenced stablecoin, which wraps a yield-bearing stablecoin like sDAI."

difficulty: "intermediate"
prerequisites: ["spark"]
recommended_next: ["degen-value-capture", "regen-value-redistribution"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Common Dollar

The Common Dollar is an innovative stablecoin design that combines stable value storage with sustainable platform economics through yield capture mechanisms.

## Core Components

1. **Stablecoin Wrapper**
   - USD reference peg
   - Yield-bearing base asset
   - Seamless conversion
   - Stable value storage

2. **Yield Mechanism**
   - sDAI integration
   - Yield capture
   - Platform sustainability
   - Economic efficiency

3. **User Benefits**
   - Value stability
   - Easy conversion
   - Platform support
   - Economic alignment

## Implementation

1. **Technical Design**
   - Smart contract architecture
   - Yield collection
   - Conversion mechanisms
   - Security features

2. **Economic Model**
   - Yield distribution
   - Platform sustainability
   - Value flows
   - Market dynamics

3. **Integration**
   - Platform features
   - User interface
   - Payment systems
   - Treasury management

## Applications

1. **Platform Economics**
   - Sustainable funding
   - Feature development
   - Community support
   - Ecosystem growth

2. **User Experience**
   - Value storage
   - Payment medium
   - Platform interaction
   - Economic participation

3. **Ecosystem Development**
   - Liquidity provision
   - Market making
   - Protocol integration
   - Partnership enablement
</file>

<file path="_wiki/glossary/credible-neutrality.md">
---
title: "Credible Neutrality"
slug: "credible-neutrality"
aliases: ["protocol-neutrality", "system-neutrality"]
summary: "The principle that protocols and systems should operate with transparent, fair, and manipulation-resistant rules that treat all participants equally."

category: "glossary"
tags: ["governance", "fairness", "protocols", "principles"]
weight: 7

related_terms:
  meta_protocol:
    type: "implements"
    weight: 0.9
  community_sovereignty:
    type: "enables"
    weight: 0.8
  trust_networks:
    type: "supports"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "glossary"
    quote: "Credible neutrality is the principle that protocols should operate with transparent, fair rules that treat all participants equally and resist manipulation."

difficulty: "intermediate"
prerequisites: ["meta-protocol"]
recommended_next: ["community-sovereignty", "trust-networks"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Credible Neutrality

Credible Neutrality represents a fundamental design principle where protocols and systems operate with transparent, fair, and manipulation-resistant rules that ensure equal treatment of all participants.

## Core Principles

1. **Fairness**
   - Equal treatment
   - Transparent rules
   - Unbiased execution
   - Fair access

2. **Transparency**
   - Open systems
   - Clear rules
   - Visible processes
   - Auditable outcomes

3. **Resistance**
   - Manipulation prevention
   - Attack resistance
   - Capture prevention
   - Bias elimination

## Implementation

1. **Protocol Design**
   - Fair mechanisms
   - Equal access
   - Clear rules
   - Transparent execution

2. **Security Features**
   - Attack prevention
   - Manipulation resistance
   - Bias protection
   - Fairness guarantees

3. **Governance Systems**
   - Balanced power
   - Equal rights
   - Fair processes
   - Neutral arbitration

## Applications

1. **System Design**
   - Protocol architecture
   - Rule creation
   - Access control
   - Process implementation

2. **Community Governance**
   - Decision making
   - Resource allocation
   - Conflict resolution
   - Value distribution

3. **Trust Building**
   - Fairness demonstration
   - Trust development
   - Community confidence
   - System reliability
</file>

<file path="_wiki/glossary/duna.md">
---
title: "DUNA"
slug: "duna"
aliases: ["decentralized-unincorporated-association", "not-for-profit-association"]
summary: "Decentralized Unincorporated Not-for-profit Association, a Swiss legal structure that operates Common Ground with token-based governance."

category: "glossary"
tags: ["legal", "governance", "organization", "structure"]
weight: 7

related_terms:
  cg_token:
    type: "governs"
    weight: 0.9
  community_sovereignty:
    type: "enables"
    weight: 0.8
  credible_neutrality:
    type: "implements"
    weight: 0.7

sources:
  - document: "org"
    section: "structure"
    quote: "The CG Team operates as a Decentralized Unincorporated Not-for-profit Association or DUNA for short, in Switzerland."

difficulty: "intermediate"
prerequisites: ["cg-token"]
recommended_next: ["community-sovereignty", "credible-neutrality"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# DUNA

DUNA (Decentralized Unincorporated Not-for-profit Association) represents Common Ground's legal structure in Switzerland, combining traditional legal frameworks with web3 governance mechanisms.

## Core Components

1. **Legal Structure**
   - Swiss association
   - Not-for-profit status
   - Decentralized operation
   - Token governance

2. **Governance Model**
   - Token-based voting
   - Stakeholder rights
   - Decision processes
   - Resource control

3. **Operational Framework**
   - Development funding
   - Usage fee collection
   - Resource allocation
   - Team management

## Implementation

1. **Legal Framework**
   - Swiss jurisdiction
   - Association rules
   - Compliance measures
   - Governance structure

2. **Token Integration**
   - Voting mechanisms
   - Power distribution
   - Decision rights
   - Stakeholder alignment

3. **Operational Systems**
   - Resource management
   - Fee collection
   - Development funding
   - Team coordination

## Applications

1. **Project Governance**
   - Decision making
   - Resource allocation
   - Development direction
   - Stakeholder management

2. **Legal Compliance**
   - Regulatory alignment
   - Operational framework
   - Risk management
   - Stakeholder protection

3. **Ecosystem Development**
   - Partnership formation
   - Resource utilization
   - Growth facilitation
   - Value creation
</file>

<file path="_wiki/glossary/harberger-tax.md">
---
title: "Harberger Tax"
slug: "harberger-tax"
aliases: ["harberger-property", "partial-common-ownership"]
summary: "A property rights system where owners self-assess their property's value, pay taxes on that value, and must sell to any buyer willing to pay that price."

category: "glossary"
tags: ["economics", "property", "taxation", "innovation"]
weight: 7

related_terms:
  degen_value_capture:
    type: "implements"
    weight: 0.9
  regen_value_redistribution:
    type: "enables"
    weight: 0.8
  community_sovereignty:
    type: "supports"
    weight: 0.7

sources:
  - document: "sustain"
    section: "value-capture"
    quote: "Common Ground could start experimenting with novel systems like Harberger Taxes on memes and IP in the future."

difficulty: "advanced"
prerequisites: ["degen-value-capture"]
recommended_next: ["regen-value-redistribution", "community-sovereignty"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Harberger Tax

Harberger Tax represents an innovative property rights system that balances private ownership with public good through continuous self-assessment and taxation.

## Core Principles

1. **Self-Assessment**
   - Value declaration
   - Price setting
   - Market signaling
   - Ownership costs

2. **Continuous Taxation**
   - Regular payments
   - Value-based rates
   - Public revenue
   - Resource allocation

3. **Forced Sale**
   - Market access
   - Price enforcement
   - Ownership transfer
   - Value realization

## Implementation

1. **Economic Design**
   - Tax rate setting
   - Value assessment
   - Market dynamics
   - Transfer mechanisms

2. **Technical Systems**
   - Smart contracts
   - Payment processing
   - Transfer automation
   - Value tracking

3. **Governance Framework**
   - Tax collection
   - Revenue distribution
   - Rule enforcement
   - System maintenance

## Applications

1. **Digital Assets**
   - Meme ownership
   - IP rights
   - Digital property
   - Content licensing

2. **Resource Allocation**
   - Efficient use
   - Market access
   - Value optimization
   - Public benefit

3. **Economic Innovation**
   - Property systems
   - Value capture
   - Market design
   - Social benefit
</file>

<file path="_wiki/glossary/hyperobject.md">
---
title: "Hyperobject"
slug: "hyperobject"
aliases: ["hyperobjects"]
summary: "Entities massively distributed in time and space that transcend specific localities, making them almost incomprehensible in traditional terms."

category: "glossary"
tags: ["theory", "concepts", "scale"]
weight: 1

related_terms:
  community_hyperstructures:
    type: "implements"
    weight: 0.9
  coordination:
    type: "enables"
    weight: 0.8

sources:
  - document: "whitepaper"
    section: "hyperstructures"
    quote: "Hyperobjects are entities so massively distributed in time and space that they transcend specific localities, making them almost incomprehensible in traditional terms."

difficulty: "advanced"
prerequisites: []
recommended_next: ["community-hyperstructures"]

graph_coordinates:
  x: 0.1
  y: 0.1
  cluster: "theory"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Hyperobject

A hyperobject is a concept that describes phenomena or entities that are so massively distributed across time and space that they defy traditional understanding and localization. This term is fundamental to understanding the scale and scope of problems that Common Ground aims to address.

## Characteristics

1. **Scale**
   - Massive distribution
   - Temporal extension
   - Spatial dispersion
   - System-wide impact

2. **Perception**
   - Transcends localities
   - Defies comprehension
   - System-level effects
   - Emergent properties

3. **Examples**
   - Climate change
   - Global economies
   - Internet infrastructure
   - Social movements

## Implications

1. **Problem Solving**
   - Requires new approaches
   - Demands coordination
   - Needs systemic thinking
   - Requires collective action

2. **System Design**
   - Distributed architecture
   - Scalable solutions
   - Adaptive mechanisms
   - Resilient structures

3. **Community Impact**
   - Global coordination
   - Cross-border collaboration
   - Collective intelligence
   - Emergent solutions

## Applications

1. **Coordination**
   - Multi-stakeholder alignment
   - Resource allocation
   - Decision making
   - Impact measurement

2. **Technology**
   - Distributed systems
   - Network effects
   - Scaling solutions
   - Integration patterns

3. **Governance**
   - Collective decision-making
   - Resource management
   - Impact assessment
   - System adaptation
</file>

<file path="_wiki/glossary/intent-origination.md">
---
title: "Intent Origination"
slug: "intent-origination"
aliases: ["intent-creation", "intent-discovery"]
summary: "The process of discovering, creating, and curating user intents in crypto transactions, enabled by chain abstraction, account abstraction, and TEEs."

category: "glossary"
tags: ["intents", "ux", "transactions", "discovery"]
weight: 8

related_terms:
  zero_friction_onboarding:
    type: "enables"
    weight: 0.9
  smart_contract_standards:
    type: "implements"
    weight: 0.8
  degen_value_capture:
    type: "facilitates"
    weight: 0.7

sources:
  - document: "sustain"
    section: "value-capture"
    quote: "While everyone is talking about intent execution, we think about intent origination."

difficulty: "advanced"
prerequisites: ["zero-friction-onboarding"]
recommended_next: ["smart-contract-standards", "degen-value-capture"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Intent Origination

Intent Origination represents the future of crypto UX, focusing on how users discover, create, and express their transaction intentions before execution.

## Core Components

1. **Discovery Mechanisms**
   - User intent identification
   - Context awareness
   - Pattern recognition
   - Opportunity discovery

2. **Creation Tools**
   - Intent formulation
   - Parameter specification
   - Constraint definition
   - Outcome optimization

3. **Curation Systems**
   - Intent validation
   - Quality assessment
   - Solver matching
   - Execution optimization

## Implementation

1. **Technical Infrastructure**
   - Chain abstraction
   - Account abstraction
   - TEE integration
   - Protocol compatibility

2. **User Experience**
   - Intent expression
   - Parameter selection
   - Outcome specification
   - Solver choice

3. **Platform Integration**
   - Discovery tools
   - Creation interfaces
   - Curation mechanisms
   - Execution pathways

## Applications

1. **Transaction Design**
   - Intent specification
   - Parameter optimization
   - Outcome definition
   - Execution planning

2. **User Interaction**
   - Intent discovery
   - Creation tools
   - Curation interfaces
   - Solver selection

3. **Platform Development**
   - Tool integration
   - Interface design
   - Protocol compatibility
   - Solver coordination
</file>

<file path="_wiki/glossary/memecoin.md">
---
title: "Memecoin"
slug: "memecoin"
aliases: ["meme-token", "memetic-token"]
summary: "A Community Token that attempts to coordinate a community around a common goal through memetic value and social dynamics."

category: "glossary"
tags: ["tokens", "memes", "community", "coordination"]
weight: 3

related_terms:
  community_token:
    type: "type_of"
    weight: 0.9
  coinship:
    type: "implements"
    weight: 0.8
  game_of_chains:
    type: "participates_in"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "game_of_chains"
    quote: "A memecoin in the context of the Game of Chains is any Community Token that attempts to coordinate a community around a common goal."

difficulty: "beginner"
prerequisites: ["community-token", "coinship"]
recommended_next: ["game-of-chains"]

graph_coordinates:
  x: 0.5
  y: 0.1
  cluster: "theory"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Memecoin

A memecoin is a specific type of Community Token that leverages memetic value and social dynamics to coordinate community action around shared goals. In the context of Common Ground, memecoins play a crucial role in the Game of Chains.

## Core Concepts

1. **Memetic Value**
   - Cultural resonance
   - Social virality
   - Community engagement
   - Narrative power

2. **Coordination Mechanism**
   - Goal alignment
   - Community building
   - Value creation
   - Social dynamics

3. **Token Dynamics**
   - Distribution methods
   - Value capture
   - Community rewards
   - Growth incentives

## Implementation

1. **Community Building**
   - Social engagement
   - Value alignment
   - Participation incentives
   - Growth mechanisms

2. **Token Distribution**
   - Fair launch
   - Community mining
   - Social rewards
   - Activity incentives

3. **Value Creation**
   - Memetic spread
   - Community growth
   - Network effects
   - Utility development

## Applications

1. **Ecosystem Growth**
   - Community expansion
   - Protocol adoption
   - Value alignment
   - Network building

2. **Social Coordination**
   - Goal setting
   - Resource allocation
   - Action coordination
   - Impact measurement

3. **Value Evolution**
   - Token maturation
   - Utility development
   - Ecosystem integration
   - Governance implementation

## Example: $DEGEN

1. **Initial Phase**
   - Community points
   - Social engagement
   - Activity tracking
   - Value recognition

2. **Evolution**
   - Token conversion
   - Utility expansion
   - Ecosystem integration
   - Governance development

3. **Impact**
   - Community growth
   - Value creation
   - Protocol development
   - Ecosystem expansion
</file>

<file path="_wiki/glossary/sce.md">
---
title: "SCE"
slug: "sce"
aliases: ["european-cooperative-society", "common-ground-coop"]
summary: "A transnational European Cooperative Society legal structure that will operate Common Ground with a one-member-one-vote governance model."

category: "glossary"
tags: ["legal", "governance", "cooperative", "organization"]
weight: 7

related_terms:
  duna:
    type: "complements"
    weight: 0.9
  community_sovereignty:
    type: "implements"
    weight: 0.8
  credible_neutrality:
    type: "enables"
    weight: 0.7

sources:
  - document: "org"
    section: "structure"
    quote: "The Common Ground Coop, once formed, will be be a transnational European Cooperative Society or SCE for short, seated in the EU."

difficulty: "intermediate"
prerequisites: ["duna"]
recommended_next: ["community-sovereignty", "credible-neutrality"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# SCE (European Cooperative Society)

The European Cooperative Society (SCE) represents Common Ground's future cooperative legal structure, designed to enable true user ownership and democratic governance.

## Core Characteristics

1. **Legal Framework**
   - EU jurisdiction
   - Cooperative structure
   - Transnational operation
   - Democratic governance

2. **Governance Model**
   - One-member-one-vote
   - User ownership
   - Participatory decision-making
   - Community control

3. **Operational Structure**
   - Platform operations
   - Resource management
   - Community engagement
   - Value distribution

## Implementation

1. **Legal Design**
   - EU regulations
   - Cooperative laws
   - Member rights
   - Governance rules

2. **Membership System**
   - User participation
   - Voting rights
   - Resource access
   - Value sharing

3. **Operational Framework**
   - Platform management
   - Resource allocation
   - Community development
   - Value creation

## Applications

1. **Platform Governance**
   - Democratic control
   - Resource management
   - Development direction
   - Community empowerment

2. **User Ownership**
   - Participation rights
   - Value distribution
   - Decision making
   - Resource control

3. **Ecosystem Development**
   - Community building
   - Value creation
   - Sustainable growth
   - Innovation fostering
</file>

<file path="_wiki/glossary/smart-contract-standards.md">
---
title: "Smart Contract Standards"
slug: "smart-contract-standards"
aliases: ["contract-standards", "blockchain-standards"]
summary: "Standardized protocols and interfaces for smart contracts that enable interoperability, security, and consistent functionality across blockchain ecosystems."

category: "glossary"
tags: ["technical", "standards", "smart-contracts", "infrastructure"]
weight: 5

related_terms:
  onchain_community:
    type: "implements"
    weight: 0.9
  ecosystem:
    type: "provides"
    weight: 0.8
  meta_protocol:
    type: "utilizes"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "convergence"
    quote: "Smart contract standards like multisig wallets (SAFE), onchain roles, governance primitives, and voting mechanisms form the foundation of web3 community infrastructure."

difficulty: "intermediate"
prerequisites: []
recommended_next: ["onchain-community", "ecosystem"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Smart Contract Standards

Smart Contract Standards define the common protocols and interfaces that enable secure, interoperable, and consistent functionality across blockchain ecosystems and applications.

## Core Standards

1. **Wallet Standards**
   - Multisig implementations
   - Account abstraction
   - Recovery mechanisms
   - Access controls

2. **Governance Standards**
   - Voting systems
   - Proposal mechanisms
   - Execution frameworks
   - Role management

3. **Token Standards**
   - Fungible tokens
   - Non-fungible tokens
   - Semi-fungible tokens
   - Token interfaces

## Implementation

1. **Technical Specifications**
   - Interface definitions
   - Function signatures
   - Event specifications
   - State management

2. **Security Features**
   - Access control
   - Permission systems
   - Validation checks
   - Safety mechanisms

3. **Integration Points**
   - Protocol compatibility
   - Standard interfaces
   - Extension patterns
   - Upgrade paths

## Applications

1. **Community Infrastructure**
   - Governance systems
   - Treasury management
   - Role assignment
   - Resource control

2. **Protocol Development**
   - Standard compliance
   - Feature implementation
   - Security patterns
   - Integration methods

3. **Ecosystem Growth**
   - Interoperability
   - Composability
   - Innovation
   - Adoption
</file>

<file path="_wiki/glossary/spark.md">
---
title: "Spark"
slug: "spark"
aliases: ["cg-spark", "platform-currency"]
summary: "Common Ground's platform currency used for pro features and visibility, serving as a staking reward for $CG token holders and an alternative payment method for interface fees."

category: "glossary"
tags: ["currency", "rewards", "staking", "platform"]
weight: 6

related_terms:
  common_dollar:
    type: "complements"
    weight: 0.9
  cg_token:
    type: "rewards"
    weight: 0.8
  degen_value_capture:
    type: "implements"
    weight: 0.7

sources:
  - document: "sustain"
    section: "value-capture"
    quote: "Common Ground already charges fees for pro features and visibility via Spark, the platform's (offchain) currency."

difficulty: "beginner"
prerequisites: []
recommended_next: ["common-dollar", "cg-token"]

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Spark

Spark is Common Ground's native platform currency, designed to facilitate value exchange and reward participation within the ecosystem.

## Core Functions

1. **Platform Currency**
   - Pro feature access
   - Visibility enhancement
   - Fee payment
   - Value exchange

2. **Reward Mechanism**
   - Staking rewards
   - Participation incentives
   - Community engagement
   - Value distribution

3. **Payment System**
   - Interface fees
   - Feature access
   - Service payments
   - Platform transactions

## Implementation

1. **Economic Design**
   - Value flows
   - Reward distribution
   - Payment processing
   - Balance management

2. **Platform Integration**
   - Feature access
   - Payment systems
   - Reward mechanisms
   - User interface

3. **Utility Framework**
   - Service access
   - Feature unlocking
   - Value transfer
   - Reward distribution

## Applications

1. **Platform Features**
   - Pro access
   - Enhanced visibility
   - Premium services
   - Special functions

2. **Reward Systems**
   - Staking benefits
   - Participation rewards
   - Community incentives
   - Value sharing

3. **Economic Functions**
   - Payment processing
   - Value transfer
   - Service access
   - Feature unlocking
</file>

<file path="_wiki/mechanics/degen-value-capture.md">
---
title: "Degen Value Capture"
slug: "degen-value-capture"
aliases: ["degen-mechanics", "value-capture"]
summary: "A mechanism for capturing and distributing value through speculative market dynamics and community engagement in web3 ecosystems."

category: "mechanics"
tags: ["economics", "tokenomics", "markets", "speculation"]
weight: 1

related_terms:
  community_token:
    type: "utilizes"
    weight: 0.9
  regen_value_redistribution:
    type: "counterpart"
    weight: 0.9
  ecosystem:
    type: "operates_within"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "sustaining_common_ground"
    quote: "Different kinds of communities arise from different token distribution mechanisms."

difficulty: "intermediate"
prerequisites: ["community-token", "ecosystem"]
recommended_next: ["regen-value-redistribution"]

graph_coordinates:
  x: 0.2
  y: 0.3
  cluster: "mechanics"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Degen Value Capture

Degen Value Capture represents a set of mechanisms designed to harness speculative market dynamics and community engagement to generate and distribute value within web3 ecosystems.

## Core Concepts

1. **Market Dynamics**
   - Price discovery
   - Liquidity provision
   - Trading incentives
   - Market making

2. **Community Engagement**
   - Participation rewards
   - Staking mechanisms
   - Trading activities
   - Yield generation

3. **Value Distribution**
   - Token allocation
   - Reward systems
   - Fee structures
   - Incentive alignment

## Implementation

1. **Token Mechanics**
   - Distribution models
   - Vesting schedules
   - Lock-up periods
   - Trading pairs

2. **Market Infrastructure**
   - Exchange listings
   - Liquidity pools
   - Trading interfaces
   - Price oracles

3. **Incentive Design**
   - Reward structures
   - Staking benefits
   - Trading rewards
   - Participation bonuses

## Applications

1. **Community Building**
   - Token distribution
   - Engagement rewards
   - Community incentives
   - Value sharing

2. **Market Operations**
   - Trading activities
   - Liquidity provision
   - Price stabilization
   - Market making

3. **Value Creation**
   - Asset appreciation
   - Yield generation
   - Fee collection
   - Treasury growth

## Risk Management

1. **Market Risks**
   - Volatility management
   - Liquidity monitoring
   - Price stability
   - Market manipulation

2. **Community Risks**
   - Token concentration
   - Participation balance
   - Incentive alignment
   - Sustainability

3. **Operational Risks**
   - Smart contract security
   - Oracle reliability
   - Market infrastructure
   - Regulatory compliance
</file>

<file path="_wiki/mechanics/regen-value-redistribution.md">
---
title: "Regen Value Redistribution"
slug: "regen-value-redistribution"
aliases: ["regen-mechanics", "value-redistribution"]
summary: "A mechanism for sustainably redistributing captured value to support public goods, community development, and long-term ecosystem health."

category: "mechanics"
tags: ["sustainability", "public-goods", "redistribution", "community"]
weight: 2

related_terms:
  degen_value_capture:
    type: "counterpart"
    weight: 0.9
  hypercerts:
    type: "utilizes"
    weight: 0.8
  community_token:
    type: "implements"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "sustaining_common_ground"
    quote: "The optimal form of distribution for a given Community Token is contingent on the purpose, design & target audience of the community."

difficulty: "intermediate"
prerequisites: ["degen-value-capture", "hypercerts"]
recommended_next: ["community-hyperstructures"]

graph_coordinates:
  x: 0.4
  y: 0.3
  cluster: "mechanics"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Regen Value Redistribution

Regen Value Redistribution represents a sustainable approach to allocating captured value within web3 ecosystems, focusing on public goods funding, community development, and long-term sustainability.

## Core Concepts

1. **Value Allocation**
   - Public goods funding
   - Community development
   - Ecosystem sustainability
   - Impact measurement

2. **Distribution Mechanisms**
   - Quadratic funding
   - Impact certificates
   - Community grants
   - Retroactive funding

3. **Sustainability Focus**
   - Long-term alignment
   - Resource preservation
   - Community health
   - Ecosystem balance

## Implementation

1. **Funding Mechanisms**
   - Grant programs
   - Impact markets
   - Community pools
   - Development funds

2. **Distribution Systems**
   - Allocation frameworks
   - Impact assessment
   - Value tracking
   - Reward distribution

3. **Governance Structure**
   - Decision making
   - Proposal systems
   - Community input
   - Impact evaluation

## Applications

1. **Public Goods**
   - Infrastructure funding
   - Research support
   - Education initiatives
   - Community resources

2. **Community Development**
   - Skill building
   - Resource allocation
   - Capacity expansion
   - Knowledge sharing

3. **Ecosystem Health**
   - Sustainability programs
   - Resource management
   - Impact assessment
   - Value circulation

## Impact Measurement

1. **Metrics Framework**
   - Impact indicators
   - Success measures
   - Value assessment
   - Progress tracking

2. **Evaluation Systems**
   - Quality assessment
   - Impact verification
   - Value validation
   - Progress monitoring

3. **Feedback Loops**
   - Community input
   - Impact adjustment
   - Program refinement
   - Strategy adaptation
</file>

<file path="_wiki/primitives/ai-hiveminds.md">
---
title: "AI Hiveminds"
slug: "ai-hiveminds"
aliases: ["ai-collectives", "collective-intelligence"]
summary: "Decentralized networks of AI agents that collaborate with human communities to enhance coordination and decision-making capabilities."

category: "primitives"
tags: ["ai", "coordination", "intelligence", "community"]
weight: 7

related_terms:
  discourse_graphs:
    type: "utilizes"
    weight: 0.8
  subjectivocracy:
    type: "complements"
    weight: 0.8
  coordination:
    type: "implements"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "emerging_primitives"
    quote: "AI Hiveminds represent a new paradigm of human-AI collaboration, where decentralized networks of AI agents work alongside communities to enhance coordination and decision-making capabilities."

difficulty: "advanced"
prerequisites: ["discourse-graphs"]
recommended_next: ["subjectivocracy"]

graph_coordinates:
  x: 0.6
  y: 0.8
  cluster: "emerging"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# AI Hiveminds

AI Hiveminds represent a revolutionary approach to community coordination through decentralized networks of AI agents that collaborate with human communities to enhance collective intelligence and decision-making capabilities.

## Core Components

1. **Agent Networks**
   - Distributed AI systems
   - Coordination protocols
   - Task allocation
   - Resource management

2. **Human Integration**
   - Interface design
   - Interaction models
   - Feedback loops
   - Trust building

3. **Collective Intelligence**
   - Knowledge synthesis
   - Pattern recognition
   - Decision support
   - Learning systems

## Implementation

1. **Technical Architecture**
   - Agent frameworks
   - Communication protocols
   - Data structures
   - Integration APIs

2. **Coordination Mechanisms**
   - Task distribution
   - Resource allocation
   - Decision processes
   - Consensus building

3. **Learning Systems**
   - Knowledge capture
   - Pattern analysis
   - Model adaptation
   - Performance optimization

## Applications

1. **Community Support**
   - Decision assistance
   - Resource optimization
   - Knowledge management
   - Process automation

2. **Coordination Enhancement**
   - Task coordination
   - Resource allocation
   - Goal alignment
   - Impact assessment

3. **Knowledge Systems**
   - Information synthesis
   - Pattern recognition
   - Insight generation
   - Learning optimization
</file>

<file path="_wiki/primitives/community-token.md">
---
title: "Community Token"
slug: "community-token"
aliases: ["social-token", "community-currency"]
summary: "A tokenized representation of community value and participation that enables governance, incentive alignment, and resource allocation."

category: "primitives"
tags: ["token", "economics", "governance", "community"]
weight: 3

related_terms:
  onchain_community:
    type: "enables"
    weight: 0.9
  degen_value_capture:
    type: "implements"
    weight: 0.8
  regen_value_redistribution:
    type: "facilitates"
    weight: 0.8

sources:
  - document: "whitepaper"
    section: "existing_primitives"
    quote: "Community tokens represent value and participation within a community, enabling governance, incentive alignment, and resource allocation through token mechanics."

difficulty: "intermediate"
prerequisites: ["onchain-community"]
recommended_next: ["ecosystem", "degen-value-capture"]

graph_coordinates:
  x: 0.6
  y: 0.7
  cluster: "primitives"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Community Token

Community Tokens serve as the economic and governance backbone of web3 communities, enabling value alignment, participation incentives, and resource allocation through sophisticated token mechanics.

## Core Functions

1. **Value Representation**
   - Community ownership
   - Participation rights
   - Resource claims
   - Governance power

2. **Economic Mechanics**
   - Value capture
   - Resource allocation
   - Incentive design
   - Market dynamics

3. **Governance Tools**
   - Voting rights
   - Proposal power
   - Decision weight
   - Stake-based influence

## Implementation

1. **Token Design**
   - Supply mechanics
   - Distribution model
   - Utility features
   - Governance rights

2. **Economic Model**
   - Value accrual
   - Fee structures
   - Reward systems
   - Market mechanisms

3. **Integration Points**
   - Governance systems
   - Treasury management
   - Community roles
   - Resource allocation

## Applications

1. **Community Governance**
   - Decision making
   - Resource allocation
   - Proposal creation
   - Vote weighting

2. **Economic Alignment**
   - Value distribution
   - Incentive design
   - Market creation
   - Resource optimization

3. **Participation Incentives**
   - Contribution rewards
   - Engagement bonuses
   - Loyalty programs
   - Stake-based benefits
</file>

<file path="_wiki/primitives/discourse-graphs.md">
---
title: "Discourse Graphs"
slug: "discourse-graphs"
aliases: ["discourse-graph", "conversation-graphs"]
summary: "A structured data format for mapping conversations and viewpoints across communities, enabling collective sensemaking and coordination."

category: "primitives"
tags: ["sensemaking", "coordination", "knowledge", "communication"]
weight: 6

related_terms:
  hypercerts:
    type: "complements"
    weight: 0.8
  ai_hiveminds:
    type: "enables"
    weight: 0.7
  coordination:
    type: "implements"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "emerging_primitives"
    quote: "Discourse Graphs can help with sensemaking in decentralized ecosystems, by building a structured map of conversations across communities, identifying convergences and divergences in viewpoints."

difficulty: "advanced"
prerequisites: ["coordination"]
recommended_next: ["ai-hiveminds", "subjectivocracy"]

graph_coordinates:
  x: 0.4
  y: 0.9
  cluster: "emerging"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Discourse Graphs

Discourse Graphs provide a structured approach to mapping and analyzing conversations and viewpoints across decentralized communities. They enable collective sensemaking and coordinated problem-solving through standardized data structures.

## Core Concepts

1. **Structured Mapping**
   - Conversation tracking
   - Viewpoint identification
   - Relationship mapping
   - Pattern recognition

2. **Sensemaking Tools**
   - Convergence analysis
   - Divergence tracking
   - Consensus building
   - Knowledge synthesis

3. **Coordination Framework**
   - Cross-community dialogue
   - Viewpoint alignment
   - Action coordination
   - Resource allocation

## Technical Implementation

1. **Data Structure**
   - Graph schema
   - Node types
   - Edge relationships
   - Metadata framework

2. **Analysis Tools**
   - Pattern detection
   - Sentiment analysis
   - Consensus tracking
   - Impact measurement

3. **Integration Layer**
   - Community systems
   - Communication tools
   - Knowledge bases
   - Decision frameworks

## Applications

1. **Community Coordination**
   - Discussion mapping
   - Decision tracking
   - Consensus building
   - Action planning

2. **Knowledge Management**
   - Information organization
   - Context preservation
   - Relationship mapping
   - Knowledge discovery

3. **Problem Solving**
   - Issue identification
   - Solution development
   - Impact assessment
   - Implementation tracking

## Features

1. **Visualization**
   - Graph rendering
   - Relationship display
   - Pattern highlighting
   - Interactive exploration

2. **Analysis Tools**
   - Trend detection
   - Sentiment tracking
   - Influence mapping
   - Impact assessment

3. **Integration Points**
   - Community platforms
   - Knowledge bases
   - Decision systems
   - Action frameworks
</file>

<file path="_wiki/primitives/ecosystem.md">
---
title: "Ecosystem"
slug: "ecosystem"
aliases: ["blockchain-ecosystem", "chain-ecosystem"]
summary: "A gateway for broader adoption that acts as a Schelling Point for communities, providing infrastructure, funding, and coordination resources."

category: "primitives"
tags: ["infrastructure", "blockchain", "scaling", "coordination"]
weight: 4

related_terms:
  community_hyperstructures:
    type: "enables"
    weight: 0.9
  community_token:
    type: "supports"
    weight: 0.8
  passport:
    type: "provides_infrastructure"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "existing_primitives"
    quote: "Ecosystems are the gateway to broader adoption by acting as a Schelling Point for communities, which in turn conduct user outreach funded by ecosystem grants."

difficulty: "advanced"
prerequisites: ["community-token", "passport"]
recommended_next: ["hypercerts", "discourse-graphs"]

graph_coordinates:
  x: 0.8
  y: 0.7
  cluster: "primitives"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Ecosystem

An Ecosystem in Common Ground represents a comprehensive infrastructure layer that supports community development, token deployment, and user onboarding. It serves as a coordination point for communities and provides essential resources for growth.

## Core Functions

1. **Infrastructure Provision**
- Blockchain networks
   - Identity systems
   - Smart contract platforms
   - Scaling solutions

2. **Community Support**
   - Grant programs
   - Gas sponsorship
   - Technical resources
   - Growth initiatives

3. **Coordination Services**
   - Community outreach
   - User acquisition
   - Resource allocation
   - Network effects

## Technical Infrastructure

1. **Blockchain Layer**
   - Layer 1 networks
   - Layer 2 solutions
   - Layer n scaling
   - Cross-chain bridges

2. **Identity Stack**
   - Passport deployment
   - Chain-specific identities
   - Verification systems
   - Social graph integration

3. **Development Tools**
   - Smart contract frameworks
   - Development SDKs
   - Testing environments
   - Deployment tools

## Community Integration

1. **Onboarding Process**
   - Community deployment
   - Token integration
   - Resource allocation
   - User acquisition

2. **Resource Management**
   - Grant distribution
   - Gas optimization
   - Infrastructure access
   - Technical support

3. **Growth Support**
   - Marketing resources
   - Community building
   - Network expansion
- Value creation

## Applications

1. **Builder Support**
   - Distribution channels
   - Active communities
   - Engagement metrics
   - Reward systems

2. **User Benefits**
   - Cross-community access
   - Seamless communication
   - Resource sharing
   - Value alignment

3. **Ecosystem Development**
   - Protocol standards
   - Market infrastructure
   - Technical innovation
   - Community growth
</file>

<file path="_wiki/primitives/hypercerts.md">
---
title: "Hypercerts"
slug: "hypercerts"
aliases: ["impact-certificates", "impact-certs"]
summary: "A standardized format for representing and tracking impact claims, enabling the creation of impact markets and value attribution systems."

category: "primitives"
tags: ["impact", "coordination", "value", "markets"]
weight: 5

related_terms:
  discourse_graphs:
    type: "complements"
    weight: 0.8
  ecosystem:
    type: "enables"
    weight: 0.7
  community_token:
    type: "interacts_with"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "emerging_primitives"
    quote: "Hypercerts provide a standardized format for representing impact claims, enabling the creation of impact markets and value attribution systems."

difficulty: "advanced"
prerequisites: ["ecosystem", "community-token"]
recommended_next: ["discourse-graphs", "ai-hiveminds"]

graph_coordinates:
  x: 0.6
  y: 0.9
  cluster: "emerging"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Hypercerts

Hypercerts represent a breakthrough in impact tracking and value attribution, providing a standardized format for representing, verifying, and trading impact claims in web3 ecosystems.

## Core Features

1. **Impact Claims**
   - Standardized format
   - Verifiable metrics
   - Attribution tracking
   - Value assessment

2. **Market Mechanisms**
   - Impact trading
   - Value discovery
   - Price formation
   - Market liquidity

3. **Integration Points**
   - Community systems
   - Token economies
   - Governance frameworks
   - Value networks

## Implementation

1. **Technical Standards**
   - Data schema
   - Smart contracts
   - Integration APIs
   - Verification protocols

2. **Market Infrastructure**
   - Trading platforms
   - Price discovery
   - Liquidity provision
   - Settlement systems

3. **Governance Framework**
   - Claim verification
   - Dispute resolution
   - Standard setting
   - Protocol updates

## Applications

1. **Impact Markets**
   - Value attribution
   - Impact trading
   - Market making
   - Price discovery

2. **Community Integration**
   - Value tracking
   - Resource allocation
   - Impact assessment
   - Reward distribution

3. **Ecosystem Development**
   - Market creation
   - Value networks
   - Protocol integration
   - Standard adoption
</file>

<file path="_wiki/primitives/onchain-community.md">
---
title: "Onchain Community"
slug: "onchain-community"
aliases: ["dao-community", "blockchain-community"]
summary: "A web3-native community structure with integrated governance, treasury, and role management capabilities built on smart contract primitives."

category: "primitives"
tags: ["community", "governance", "web3", "organization"]
weight: 2

related_terms:
  passport:
    type: "requires"
    weight: 0.9
  community_token:
    type: "implements"
    weight: 0.8
  ecosystem:
    type: "participates_in"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "existing_primitives"
    quote: "Onchain communities are built on smart contract primitives that enable integrated governance, treasury management, and role-based access control."

difficulty: "intermediate"
prerequisites: ["passport"]
recommended_next: ["community-token", "ecosystem"]

graph_coordinates:
  x: 0.4
  y: 0.7
  cluster: "primitives"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Onchain Community

Onchain Communities represent web3-native organizational structures that leverage smart contract primitives to enable sophisticated governance, treasury management, and role-based coordination.

## Core Components

1. **Governance System**
   - Proposal mechanisms
   - Voting systems
   - Decision execution
   - Role management

2. **Treasury Management**
   - Asset control
   - Resource allocation
   - Spending policies
   - Financial tracking

3. **Role Framework**
   - Access control
   - Permission management
   - Responsibility definition
   - Task allocation

## Implementation

1. **Smart Contracts**
   - Governance logic
   - Treasury controls
   - Role definitions
   - Access management

2. **Integration Points**
   - Identity systems
   - Token mechanisms
   - Voting protocols
   - Resource management

3. **Security Features**
   - Access controls
   - Transaction signing
   - Multi-signature
   - Time locks

## Applications

1. **Community Operations**
   - Member management
   - Resource allocation
   - Decision making
   - Task coordination

2. **Resource Management**
   - Asset allocation
   - Budget control
   - Expense tracking
   - Investment decisions

3. **Governance Activities**
   - Proposal creation
   - Voting processes
   - Implementation tracking
   - Impact assessment
</file>

<file path="_wiki/primitives/passport.md">
---
title: "Passport"
slug: "passport"
aliases: ["cg-passport", "common-ground-passport"]
summary: "A composite primitive combining passkeys, smart wallets, and verified identities to create a unified web3 identity and authentication system."

category: "primitives"
tags: ["identity", "authentication", "wallet", "verification"]
weight: 1

related_terms:
  community_hyperstructures:
    type: "component_of"
    weight: 0.9
  onchain_community:
    type: "enables"
    weight: 0.8
  ecosystem:
    type: "interacts_with"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "existing_primitives"
    quote: "The Common Ground Passport, or CG Passport is a composite primitive of passkeys for user authentication, a personal SAFE wallet for each user, deployed on their favorite ecosystem's chain."

difficulty: "beginner"
prerequisites: []
recommended_next: ["onchain-community", "community-token"]

graph_coordinates:
  x: 0.2
  y: 0.7
  cluster: "primitives"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Passport

The Common Ground Passport (CG Passport) is a foundational primitive that combines multiple web3 technologies to create a unified identity and authentication system. It serves as the user's primary interface with the Common Ground ecosystem.

## Core Components

1. **Authentication System**
   - Passkey integration
   - Biometric verification
   - Device-based security
   - Cross-platform support

2. **Smart Wallet Infrastructure**
   - Personal SAFE wallet
   - Ecosystem chain deployment
   - Upgradable signing contracts
   - Gas relayer services

3. **Identity Verification**
   - Onchain identity integration
     - Farcaster
     - Lens
     - Universal Profile
   - Social graph import
   - PFP display
   - Trust markers

## Features

1. **Authentication Capabilities**
   - App login
   - Transaction signing
   - Proof generation
   - Cross-platform verification

2. **Asset Management**
   - Send/receive functionality
   - Multi-chain support
   - Asset viewing
   - Transaction history

3. **Identity Management**
   - Verified identity aggregation
   - Trust marker collection
   - Reputation building
   - Social graph integration

## Technical Implementation

1. **Wallet Architecture**
   - SAFE contract deployment
   - RIP7212 compatibility
   - Upgradable contracts
   - Multi-chain support

2. **Authentication Flow**
   - Passkey registration
   - Biometric verification
   - Device management
   - Recovery mechanisms

3. **Identity Integration**
   - Protocol connections
   - Verification systems
   - Data aggregation
   - Privacy controls

## Applications

1. **User Onboarding**
   - Zero-friction signup
   - Identity verification
   - Wallet creation
   - Ecosystem integration

2. **Community Access**
   - Role verification
   - Permission management
   - Trust establishment
   - Community participation

3. **Asset Operations**
   - Transaction execution
   - Asset transfer
   - Contract interaction
   - Gas management
</file>

<file path="_wiki/primitives/subjectivocracy.md">
---
title: "Subjectivocracy"
slug: "subjectivocracy"
aliases: ["subjective-governance", "subjective-systems"]
summary: "A conceptual framework that leverages subjective decision-making at the boundaries of objective systems to enhance resilience and adaptability."

category: "primitives"
tags: ["governance", "decision-making", "subjectivity", "resilience"]
weight: 8

related_terms:
  ai_hiveminds:
    type: "complements"
    weight: 0.8
  discourse_graphs:
    type: "supports"
    weight: 0.7
  coordination:
    type: "implements"
    weight: 0.7

sources:
  - document: "whitepaper"
    section: "emerging_primitives"
    quote: "Subjectivocracy provides a defense against the vulnerabilities of purely objective systems. While more of a conceptual framework than a primitive, the benefits of subjectivity at the boundaries of objective decision-making mechanisms are already being explored."

difficulty: "advanced"
prerequisites: ["ai-hiveminds", "discourse-graphs"]
recommended_next: ["degen-value-capture", "regen-value-redistribution"]

graph_coordinates:
  x: 0.8
  y: 0.9
  cluster: "emerging"

created_at: "2024-01-30"
last_updated: "2024-01-30"
version: 1
---

# Subjectivocracy

Subjectivocracy represents a novel approach to governance and decision-making that strategically incorporates subjective human judgment to complement and enhance objective systems.

## Core Concepts

1. **Subjective Decision-Making**
   - Human judgment
   - Context awareness
   - Value consideration
   - Adaptive reasoning

2. **System Boundaries**
   - Interface definition
   - Integration points
   - Transition zones
   - Interaction models

3. **Resilience Enhancement**
   - Vulnerability mitigation
   - Adaptability increase
   - System flexibility
   - Error correction

## Applications

1. **Oracle Systems**
   - Data validation
   - Truth verification
   - Context interpretation
   - Value judgment

2. **Dispute Resolution**
   - Conflict mediation
   - Solution finding
   - Fairness assessment
   - Context consideration

3. **Work Evaluation**
   - Quality assessment
   - Value determination
   - Impact measurement
   - Contribution rating

## Implementation

1. **Framework Design**
   - Decision boundaries
   - Integration points
   - Process flows
   - Feedback loops

2. **Governance Mechanisms**
   - Decision protocols
   - Voting systems
   - Consensus building
   - Dispute handling

3. **System Integration**
   - Objective interfaces
   - Subjective inputs
   - Process coordination
   - Outcome validation

## Benefits

1. **System Enhancement**
   - Flexibility increase
   - Adaptability improvement
   - Resilience building
   - Error reduction

2. **Decision Quality**
   - Context consideration
   - Value alignment
   - Fairness improvement
   - Outcome optimization

3. **Community Impact**
   - Trust building
   - Participation increase
   - Engagement enhancement
   - Satisfaction improvement
</file>

<file path="_wiki/tag/community/index.html">
---
layout: wiki
tag: community
is_tag_index: true
permalink: /wiki/tag/community/
---
</file>

<file path="_wiki/tag/coordination/index.html">
---
layout: wiki
tag: coordination
is_tag_index: true
permalink: /wiki/tag/coordination/
---
</file>

<file path="_wiki/tag/infrastructure/index.html">
---
layout: wiki
tag: infrastructure
is_tag_index: true
permalink: /wiki/tag/infrastructure/
---
</file>

<file path="_wiki/tag/web3/index.html">
---
layout: wiki
tag: web3
is_tag_index: true
permalink: /wiki/tag/web3/
---
</file>

<file path="assets/css/base.css">
/* base.css - Reset, CSS Variables, and Typography Defaults */
/* CSS Reset */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
/* CSS Variables for breakpoints and theming */
:root {
  --breakpoint-xs: 480px;
  --breakpoint-sm: 768px;
  --breakpoint-md: 992px;
  --breakpoint-lg: 1200px;
  --primary-color: #333;
  --secondary-color: #666;
  --font-family-base: Arial, sans-serif;
}
/* Typography Defaults */
body {
  font-family: var(--font-family-base);
  font-size: 16px;
  line-height: 1.5;
  color: var(--primary-color);
}
</file>

<file path="assets/css/components.css">
/* components.css - Reusable Component Styles */
/* Card Component */
.card {
  background: #fff;
  border: 1px solid #ddd;
  padding: 1rem;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  margin: 1rem 0;
}
/* Button Component */
.button {
  background-color: var(--primary-color);
  color: #fff;
  border: none;
  border-radius: 4px;
  padding: 0.5rem 1rem;
  cursor: pointer;
  transition: background-color 0.3s;
}
.button:hover {
  background-color: var(--secondary-color);
}
/* Navigation Component */
.nav {
  list-style: none;
  display: flex;
  padding: 0;
}
.nav li {
  margin-right: 1rem;
}
</file>

<file path="assets/css/layout.css">
/* layout.css - Layout Structures: Grid System, Containers, Header, Footer, etc. */
.container {
  width: 90%;
  max-width: 1200px;
  margin: 0 auto;
}
.header, .footer {
  padding: 1em;
  background-color: var(--secondary-color);
  color: #fff;
}
.row {
  display: flex;
  flex-wrap: wrap;
  margin: 0 -15px; /* gutter adjustment */
}
.col {
  flex: 1;
  padding: 0 15px;
}
/* Clearfix for floated elements */
.clearfix::after {
  content: "";
  display: block;
  clear: both;
}
/* Responsive adjustments using breakpoints from base.css */
@media (max-width: var(--breakpoint-sm)) {
  .header, .footer {
    text-align: center;
  }
}
/* --- Consolidated Core Layout Styles from templates.css --- */
/* Header Styles */
header nav {
  height: 80px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}
header .logo {
  height: 40px;
  display: flex;
  align-items: center;
}
header .logo img {
  height: 100%;
  width: auto;
}
header .nav-links {
  display: flex;
  gap: 2rem;
  align-items: center;
}
header .nav-links a {
  color: var(--text-color);
  text-decoration: none;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  padding: 0.5rem 0;
  position: relative;
}
header .nav-links a::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  width: 0;
  height: 2px;
  background: var(--brand-color);
  transition: width 0.3s;
}
header .nav-links a:hover::after {
  width: 100%;
}
header .nav-links a.active::after {
  width: 100%;
}
/* Mobile Navigation */
.burger-menu {
  display: none;
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0.5rem;
  color: var(--text-color);
}
@media (max-width: 768px) {
  .burger-menu {
    display: block;
  }
  header .nav-links {
    flex-direction: column;
    display: none;
  }
  header .nav-links.open {
    display: flex;
  }
}
/* Main Content Styles */
main {
  padding: 1rem;
}
.content-container {
  margin: 1rem 0;
}
/* Footer Styles */
footer {
  background: var(--secondary-color);
  color: #fff;
  padding: 1rem;
}
</file>

<file path="assets/css/main.css">
/* main.css - Modular CSS Imports */
@import "base.css";
@import "layout.css";
@import "components.css";
@import "utilities.css";
@import "templates.css";
/* Variables */
:root {
  --brand-color: rgb(123, 181, 223);
  --text-color: #2C353D;
  --text-secondary: #57606a;
  --background-color: #FFFFFF;
  --light-gray: #F5F7F9;
  --border-color: #E1E8ED;
  --code-bg: #f6f8fa;
  /* Typography Scale - Updated with fluid typography */
  --font-size-xs: clamp(0.75rem, 0.7rem + 0.25vw, 0.85rem);
  --font-size-sm: clamp(0.85rem, 0.8rem + 0.25vw, 0.95rem);
  --font-size-base: clamp(1rem, 0.95rem + 0.25vw, 1.125rem);
  --font-size-md: clamp(1.125rem, 1.1rem + 0.25vw, 1.25rem);
  --font-size-lg: clamp(1.25rem, 1.2rem + 0.25vw, 1.5rem);
  --font-size-xl: clamp(1.5rem, 1.4rem + 0.5vw, 2rem);
  --font-size-2xl: clamp(2rem, 1.8rem + 1vw, 2.5rem);
  /* Font Weights */
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  /* Line Heights */
  --line-height-tight: 1.25;
  --line-height-base: 1.6;
  /* Typography */
  --base-font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen-Sans, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
  --mono-font: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
}
/* Base styles */
body {
  font-family: var(--base-font-family);
  font-size: 16px;
  line-height: 1.6;
  color: var(--text-color);
  background-color: var(--background-color);
  margin: 0;
  padding: 0;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  position: relative;
}
/* Layout - Updated for better mobile support */
.container {
  max-width: min(1200px, 95%);
  margin: 0 auto;
  padding: 0 1rem;
}
/* Mobile Navigation */
.burger-menu {
  display: none;
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0.5rem;
  color: var(--text-color);
}
/* Header - Updated for mobile */
header nav {
  height: 80px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}
header .logo {
  height: 40px;
  display: flex;
  align-items: center;
}
header .logo img {
  height: 100%;
  width: auto;
}
header .nav-links {
  display: flex;
  gap: 2rem;
  align-items: center;
}
header .nav-links a {
  color: var(--text-color);
  text-decoration: none;
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-medium);
  padding: 0.5rem 0;
  position: relative;
}
header .nav-links a::after {
  content: '';
  position: absolute;
  width: 0;
  height: 2px;
  bottom: 0;
  left: 0;
  background-color: var(--brand-color);
  transition: width 0.2s ease-in-out;
}
header .nav-links a:hover::after {
  width: 100%;
}
header .nav-links a.active {
  color: var(--brand-color);
}
header .nav-links a.active::after {
  width: 100%;
}
/* Join button in navigation */
header .nav-links .join-button {
  background: #000;
  color: #fff;
  padding: 10px 20px;
  border-radius: 100px;
  font-weight: var(--font-weight-medium);
  transition: all 0.2s ease-in-out;
}
header .nav-links .join-button::after {
  display: none;
}
header .nav-links .join-button:hover {
  background: #333;
  transform: translateY(-1px);
}
header .nav-links .join-button .arrow {
  display: inline-block;
  margin-left: 4px;
  font-size: 1.1em;
  line-height: 0;
  position: relative;
  top: 2px;
}
/* Main content */
main {
  position: relative;
  z-index: 1;
  min-height: calc(100vh - 80px - 300px);
  background-color: var(--light-gray);
  padding: 4rem 0;
}
/* Content Container - THE ONE AND ONLY WAY to style content */
.content-container {
  border-radius: 1rem;
  padding: 2rem;
  max-width: 800px;
  margin: 0 auto;
  box-shadow: 0 4px 12px rgba(44, 53, 61, 0.1);
  background: linear-gradient(135deg, var(--background-color) 0%, var(--light-gray) 100%);
}
.content-header {
  margin-bottom: 2rem;
}
.content-title {
  margin: 0;
  color: var(--text-color);
  font-size: var(--font-size-2xl);
  font-weight: var(--font-weight-bold);
  line-height: var(--line-height-tight);
}
/* Content Typography */
.content {
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
  position: relative;
  z-index: 1;
}
.content > * {
  margin-top: 0;
}
.content > *:last-child {
  margin-bottom: 0;
}
/* Headings */
.content h1 {
  padding-bottom: 0.3em;
  font-size: var(--font-size-xl);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
.content h2 {
  padding-bottom: 0.3em;
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
.content h3 {
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
.content h4 {
  font-size: var(--font-size-base);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
.content h5 {
  font-size: var(--font-size-sm);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
.content h6 {
  font-size: var(--font-size-xs);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
  margin-top: 24px;
  margin-bottom: 16px;
}
/* Paragraphs and Lists */
.content p {
  margin-top: 0;
  margin-bottom: 16px;
}
.content ul,
.content ol {
  margin-top: 0;
  margin-bottom: 16px;
  padding-left: 2em;
}
.content ul ul,
.content ul ol,
.content ol ul,
.content ol ol {
  margin-top: 0;
  margin-bottom: 0;
}
.content li {
  margin: 0.25em 0;
}
.content li > p {
  margin-top: 16px;
}
.content li + li {
  margin-top: 0.25em;
}
/* Links */
.content a {
  color: var(--brand-color);
  text-decoration: none;
  transition: color 0.2s;
}
.content a:hover {
  text-decoration: underline;
}
/* Blockquotes */
.content blockquote {
  margin: 16px 0;
  padding: 0 1em;
  color: var(--text-secondary);
  border-left: 0.25em solid var(--border-color);
}
.content blockquote > :first-child {
  margin-top: 0;
}
.content blockquote > :last-child {
  margin-bottom: 0;
}
/* Code */
.content code {
  padding: 0.2em 0.4em;
  margin: 0;
  font-size: var(--font-size-xs);
  font-family: var(--mono-font);
  background-color: var(--code-bg);
  border-radius: 6px;
}
.content pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: var(--code-bg);
  border-radius: 6px;
  margin-bottom: 16px;
}
.content pre code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}
/* Tables */
.content table {
  display: block;
  width: 100%;
  width: max-content;
  max-width: 100%;
  overflow: auto;
  margin-top: 0;
  margin-bottom: 16px;
  border-spacing: 0;
  border-collapse: collapse;
}
.content table th {
  font-weight: 600;
  padding: 6px 13px;
  border: 1px solid var(--border-color);
}
.content table td {
  padding: 6px 13px;
  border: 1px solid var(--border-color);
}
.content table tr {
  background-color: var(--background-color);
  border-top: 1px solid var(--border-color);
}
.content table tr:nth-child(2n) {
  background-color: var(--light-gray);
}
/* Images */
.content img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: var(--background-color);
  border-radius: 6px;
}
/* Horizontal Rule */
.content hr {
  height: 1px;
  padding: 0;
  margin: 24px 0;
  background-color: var(--border-color);
  border: 0;
}
/* Task Lists */
.content .task-list {
  list-style-type: none;
  padding-left: 0;
}
.content .task-list-item {
  display: flex;
  align-items: center;
  gap: 0.5em;
}
.content .task-list-item input[type="checkbox"] {
  margin: 0;
}
/* Callouts */
.content .callout {
  padding: 16px;
  margin-bottom: 16px;
  border-radius: 6px;
  border-left: 4px solid var(--brand-color);
  background-color: var(--light-gray);
}
.content .callout > :last-child {
  margin-bottom: 0;
}
/* Cards */
.card {
  background: var(--background-color);
  border: 1px solid var(--border-color);
  border-radius: 1rem;
  padding: 2rem;
  transition: transform 0.2s, box-shadow 0.2s;
}
.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 12px 24px rgba(44, 53, 61, 0.1);
}
/* Grid system */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}
/* Footer */
footer {
  background-color: rgba(255, 255, 255, 0.98);
  backdrop-filter: blur(8px);
  border-top: 1px solid var(--border-color);
  padding: 3rem 0;
  font-size: var(--font-size-base);
  line-height: var(--line-height-base);
}
footer .footer-content {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr;
  gap: 4rem;
}
.footer-logo {
  display: block;
  margin-bottom: 1rem;
}
.footer-logo img {
  height: 40px;
  width: auto;
}
.social-links {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
}
.social-link {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--light-gray);
  transition: all 0.2s ease;
}
.social-link:hover {
  transform: translateY(-2px);
  background: var(--border-color);
}
.social-icon {
  width: 20px;
  height: 20px;
  fill: var(--text-color);
}
.social-icon.cg {
  width: 24px;
  height: 24px;
}
.social-icon.twitter {
  fill: #000;
}
.social-icon.github {
  fill: #000;
}
footer .footer-info h3 {
  margin-top: 0;
  font-size: var(--font-size-lg);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
}
footer .footer-info p {
  color: rgba(44, 53, 61, 0.8);
}
footer .footer-links h4 {
  margin-top: 0;
  font-size: var(--font-size-md);
  font-weight: var(--font-weight-semibold);
  line-height: var(--line-height-tight);
}
footer .footer-links ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
footer .footer-links li {
  margin-bottom: 0.75rem;
}
footer .footer-links a {
  color: rgba(44, 53, 61, 0.8);
  text-decoration: none;
  transition: color 0.2s;
}
footer .footer-links a:hover {
  color: var(--brand-color);
}
/* Buttons */
.button {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  border-radius: 0.5rem;
  font-weight: 500;
  text-decoration: none;
  transition: all 0.2s;
}
.button.primary {
  background-color: var(--brand-color);
  color: white;
}
.button.primary:hover {
  background-color: rgb(98, 145, 178); /* Darker brand color */
  transform: translateY(-2px);
}
.button.secondary {
  background-color: var(--light-gray);
  color: var(--text-color);
}
.button.secondary:hover {
  background-color: #E8EDF2; /* Darker light gray */
  transform: translateY(-2px);
}
/* Responsive Design */
@media (max-width: 1024px) {
  .container {
    max-width: 100%;
    padding: 0 1rem;
  }
  main {
    padding: 2rem 0;
  }
  .content-container {
    padding: 1.5rem;
    margin: 0 1rem;
  }
}
@media (max-width: 768px) {
  .burger-menu {
    display: block;
    order: 1;
  }
  header .logo {
    order: 0;
  }
  header .nav-links {
    display: none;
    position: absolute;
    top: 80px;
    left: 0;
    right: 0;
    background: var(--background-color);
    flex-direction: column;
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
  }
  header .nav-links.open {
    display: flex;
  }
  header .nav-links a {
    padding: 1rem;
    width: 100%;
    text-align: center;
    font-size: var(--font-size-base);
  }
  header .nav-links .join-button {
    margin: 0.5rem 1rem;
  }
  /* Improve touch targets */
  button,
  .nav-links a,
  .social-link {
    min-height: 44px;
    padding: 0.75rem 1rem;
  }
  /* Typography adjustments */
  .content-title {
    font-size: var(--font-size-xl);
  }
  /* Form elements */
  input,
  select,
  textarea {
    font-size: 16px;
    min-height: 44px;
  }
  /* Performance optimizations */
  .content-container {
    content-visibility: auto;
    contain-intrinsic-size: 0 500px;
  }
}
@media (max-width: 480px) {
  header {
    height: auto;
  }
  header nav {
    height: 60px;
  }
  header .logo {
    height: 32px;
  }
  .content-container {
    padding: 1rem;
    border-radius: 0.5rem;
  }
  .content h1 {
    font-size: var(--font-size-lg);
  }
  .content h2 {
    font-size: var(--font-size-md);
  }
}
/* Remove all hero-specific and page-specific styling */
.hero, .page {
  /* Remove all specific styling - use content-container instead */
}
/* Stakeholder Links */
.stakeholder-link {
  color: var(--brand-color);
  text-decoration: none;
  transition: color 0.2s;
}
.stakeholder-link:hover {
  text-decoration: underline;
}
/* Remove the emoji and padding from inline links */
.content .stakeholder-link {
  padding-right: 0;
}
.content .stakeholder-link[data-type="person"]::after,
.content .stakeholder-link[data-type="entity"]::after {
  content: none;
}
/* Keep the emoji only in the stakeholder page header */
.content-title .stakeholder-emoji {
  margin-right: 0.5em;
}
/* Hero Section */
.hero.full-screen {
    min-height: 70vh;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-color);
    position: relative;
    overflow: hidden;
}
.hero-content {
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
    text-align: center;
    position: relative;
    z-index: 2;
}
.hero-title {
    font-size: clamp(2.5rem, 4vw + 1rem, 4rem);
    line-height: 1.2;
    /*margin: 0 0 1rem;*/
    color: var(--text-color);
}
.gradient-text {
    background: linear-gradient(45deg, var(--brand-color), rgb(98, 145, 178));
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    display: inline-block;
}
.hero-subtitle {
    font-size: clamp(1.25rem, 2vw + 0.5rem, 1.75rem);
    line-height: 1.4;
    margin: 0 0 2rem;
    color: var(--text-secondary);
    max-width: 800px;
}
.feature-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 2rem;
    margin: 3rem 0;
    max-width: 800px;
    margin-left: auto;
    margin-right: auto;
}
.feature-card {
    background: var(--background-color);
    border-radius: 12px;
    padding: 2rem;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 12px rgba(44, 53, 61, 0.05);
}
.feature-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 24px rgba(44, 53, 61, 0.1);
}
.feature-icon {
    font-size: 2.5rem;
    margin-bottom: 1rem;
}
.feature-card h3 {
    font-size: 1.25rem;
    margin-bottom: 0.5rem;
    color: var(--text-color);
}
.feature-card p {
    font-size: 0.9rem;
    color: var(--text-secondary);
}
.hero-cta {
    margin-top: 3rem;
}
.button {
    display: inline-block;
    padding: 1rem 2rem;
    border-radius: 8px;
    font-weight: 600;
    text-decoration: none;
    transition: all 0.2s ease;
    margin: 0 1rem;
}
.button:hover {
    transform: translateY(-2px);
}
.button.primary {
    background: var(--brand-color);
    color: white;
}
.button.secondary {
    background: var(--light-gray);
    color: var(--text-color);
    border: 1px solid var(--border-color);
}
.stats-banner {
    display: flex;
    justify-content: center;
    gap: 4rem;
    padding: 2rem;
}
.stat {
    text-align: center;
}
.stat h3 {
    font-size: 2rem;
    color: var(--brand-color);
    margin-bottom: 0.5rem;
}
.stat p {
    color: var(--text-secondary);
    font-size: 0.9rem;
}
/* Vision Section */
.vision-section {
    padding: 6rem 0;
}
.section-header {
    text-align: center;
    margin-bottom: 4rem;
}
.section-header h2 {
    font-size: var(--font-size-2xl);
    color: var(--text-color);
    margin-bottom: 1rem;
    font-weight: var(--font-weight-bold);
}
.section-subtitle {
    font-size: var(--font-size-lg);
    color: var(--text-secondary);
    max-width: 600px;
    margin: 0 auto;
}
.vision-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 2rem;
    margin-bottom: 4rem;
}
.vision-card {
    background: var(--light-gray);
    border-radius: 16px;
    padding: 2rem;
    text-align: center;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}
.vision-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 24px rgba(44, 53, 61, 0.1);
}
.vision-icon {
    font-size: 2.5rem;
    margin-bottom: 1rem;
}
.vision-card h3 {
    color: var(--text-color);
    font-size: var(--font-size-md);
    margin-bottom: 1rem;
    font-weight: var(--font-weight-semibold);
}
.vision-card p {
    color: var(--text-secondary);
    font-size: var(--font-size-base);
    line-height: var(--line-height-base);
}
.vision-feature {
    display: grid;
    grid-template-columns: 1fr;
    gap: 3rem;
    margin-top: 6rem;
    background: var(--light-gray);
    border-radius: 24px;
    padding: 4rem;
    max-width: 1000px;
    margin-left: auto;
    margin-right: auto;
}
.vision-content {
    max-width: 700px;
    margin: 0 auto;
}
.vision-content h3 {
    font-size: var(--font-size-xl);
    color: var(--text-color);
    margin-bottom: 1rem;
    font-weight: var(--font-weight-semibold);
}
.vision-content p {
    color: var(--text-secondary);
    font-size: var(--font-size-md);
    line-height: var(--line-height-base);
    margin-bottom: 2rem;
}
.feature-list {
    list-style: none;
    padding: 0;
    margin: 0 0 2rem 0;
}
.feature-list li {
    color: var(--text-color);
    font-size: var(--font-size-base);
    margin-bottom: 1rem;
    padding-left: 2rem;
    position: relative;
}
.feature-list li::before {
    content: "→";
    position: absolute;
    left: 0;
    color: var(--brand-color);
}
.network-visualization {
    width: 100%;
    height: 500px;
}
/* Responsive adjustments for vision section */
@media (max-width: 1200px) {
    .vision-feature {
        padding: 3rem;
        gap: 3rem;
    }
}
@media (max-width: 768px) {
    .vision-grid {
        grid-template-columns: 1fr;
    }
    .vision-feature {
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 2rem;
    }
    .vision-content {
        max-width: none;
    }
    .network-visualization {
        height: 400px;
    }
}
/* Wiki Layout */
.wiki-container {
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 2rem;
    max-width: 1200px;
    margin: 0 auto;
    padding: 2rem;
}
@media (max-width: 768px) {
    .wiki-container {
        grid-template-columns: 1fr;
    }
}
/* Wiki Sidebar */
.wiki-sidebar {
    position: sticky;
    top: 100px;
    height: calc(100vh - 120px);
    overflow-y: auto;
    padding-right: 1rem;
}
.wiki-nav-section {
    margin-bottom: 2rem;
}
.wiki-nav-section h3 {
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 1rem;
}
.wiki-nav-section ul {
    list-style: none;
    padding: 0;
    margin: 0;
}
.wiki-nav-section li {
    margin-bottom: 0.5rem;
}
.wiki-nav-section a {
    color: var(--text-color);
    text-decoration: none;
    font-size: var(--font-size-sm);
    display: block;
    padding: 0.5rem;
    border-radius: 0.5rem;
    transition: all 0.2s;
}
.wiki-nav-section a:hover {
    background: var(--light-gray);
    color: var(--brand-color);
}
/* Wiki Content */
.wiki-content {
    background: var(--background-color);
    border-radius: 1rem;
    padding: 2rem;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    position: relative;
    z-index: 1;
}
.wiki-header {
    margin-bottom: 2rem;
    padding-bottom: 2rem;
    border-bottom: 1px solid var(--border-color);
    position: relative;
}
.wiki-metadata {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
}
.wiki-category {
    background: var(--light-gray);
    color: var(--text-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: var(--font-size-xs);
    text-decoration: none;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.wiki-difficulty {
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: var(--font-size-xs);
    text-transform: uppercase;
    letter-spacing: 0.05em;
}
.wiki-difficulty.basic {
    background: #E1F5E1;
    color: #2F7A2F;
}
.wiki-difficulty.intermediate {
    background: #FFF3E1;
    color: #B77C1B;
}
.wiki-difficulty.advanced {
    background: #FFE1E1;
    color: #C42B2B;
}
.wiki-title {
    font-size: var(--font-size-2xl);
    color: var(--text-color);
    margin: 0 0 1rem 0;
    line-height: 1.2;
}
.wiki-summary {
    font-size: var(--font-size-lg);
    color: var(--text-secondary);
    margin: 0 0 1rem 0;
    line-height: 1.4;
}
.wiki-aliases {
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
}
.wiki-alias {
    background: var(--light-gray);
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
}
.wiki-body {
    font-size: var(--font-size-base);
    line-height: var(--line-height-base);
}
.wiki-footer {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
}
.wiki-learning-path {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-bottom: 2rem;
}
@media (max-width: 480px) {
    .wiki-learning-path {
        grid-template-columns: 1fr;
    }
}
.wiki-learning-path h3 {
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}
.wiki-learning-path ul {
    list-style: none;
    padding: 0;
    margin: 0;
}
.wiki-learning-path li {
    margin-bottom: 0.5rem;
}
.wiki-learning-path a {
    color: var(--brand-color);
    text-decoration: none;
}
.wiki-learning-path a:hover {
    text-decoration: underline;
}
.wiki-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: var(--font-size-xs);
    color: var(--text-secondary);
}
.wiki-dates {
    display: flex;
    gap: 1rem;
}
.wiki-version {
    background: var(--light-gray);
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
}
/* Wiki Tags */
.wiki-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}
.wiki-tag {
    background: var(--light-gray);
    color: var(--text-secondary);
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-size: var(--font-size-xs);
    text-decoration: none;
    transition: all 0.2s;
}
.wiki-tag:hover {
    background: var(--brand-color);
    color: white;
}
/* Page Header */
.page-header {
  margin-bottom: 3rem;
  text-align: left;
  position: relative;
}
.page-title {
  font-size: var(--font-size-2xl);
  color: var(--text-color);
  margin: 0 0 1rem 0;
  line-height: 1.2;
}
.page-summary {
  font-size: var(--font-size-lg);
  color: var(--text-secondary);
  margin: 0;
  line-height: 1.4;
  max-width: 800px;
}
/* Container Mobile Adjustments */
@media (max-width: 768px) {
    .container {
         padding: 0 15px;
    }
}
@media (max-width: 480px) {
    .container {
         padding: 0 10px;
    }
}
/* Mobile Footer Adjustments */
@media (max-width: 768px) {
    footer .footer-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
        gap: 1rem;
    }
    footer .social-links {
        justify-content: center;
    }
}
/* Custom Mobile Override: Force one box per line for cards */
@media (max-width: 768px) {
  .post-list,
  .feature-grid,
  .stats-grid {
    display: block !important;
  }
  .post-list .card,
  .feature-card,
  .stat {
    width: 100% !important;
    margin-bottom: 1rem !important;
    display: block !important;
    height: auto !important;
    position: static !important;
  }
}
/* Mobile override for stats-banner: Stack stats vertically */
@media (max-width: 768px) {
  .stats-banner {
    display: block !important;
  }
  .stats-banner .stat {
    width: 100% !important;
    margin-bottom: 1rem !important;
    display: block !important;
    height: auto !important;
    position: static !important;
  }
}
</file>

<file path="assets/css/templates.css">
/* templates.css - Template-Specific Overrides */
/* Core layout styles have been moved to layout.css */
/* Add template-specific overrides here if necessary */
/* Base styles */
body {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* Content Container */
.content-container {
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
  width: 100%;
  box-sizing: border-box;
}
.content {
  background: var(--background-color);
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  width: 100%;
  box-sizing: border-box;
  overflow-wrap: break-word;
  word-wrap: break-word;
  word-break: break-word;
  hyphens: auto;
}
/* Content Typography and Elements */
.content h1 {
  font-size: var(--font-size-2xl);
  margin-bottom: 1.5rem;
  line-height: 1.2;
  max-width: 100%;
}
.content h2 {
  font-size: var(--font-size-xl);
  margin: 2rem 0 1rem;
  line-height: 1.3;
  max-width: 100%;
}
.content h3 {
  font-size: var(--font-size-lg);
  margin: 1.5rem 0 0.75rem;
  line-height: 1.4;
  max-width: 100%;
}
.content p {
  margin-bottom: 1rem;
  line-height: var(--line-height-base);
  max-width: 100%;
}
.content ul, .content ol {
  margin: 1rem 0;
  padding-left: 1.5rem;
  max-width: 100%;
  box-sizing: border-box;
}
.content li {
  margin-bottom: 0.5rem;
  max-width: 100%;
}
.content img {
  max-width: 100%;
  height: auto;
  border-radius: 4px;
  margin: 1.5rem 0;
  display: block;
}
.content pre {
  max-width: 100%;
  overflow-x: auto;
  padding: 1rem;
  background: var(--code-bg);
  border-radius: 4px;
  box-sizing: border-box;
}
.content code {
  word-break: break-all;
  word-wrap: break-word;
  white-space: pre-wrap;
  font-size: 0.9em;
  padding: 0.2em 0.4em;
  background: var(--code-bg);
  border-radius: 3px;
}
.content a {
  word-break: break-all;
  overflow-wrap: break-word;
}
.content-header {
  margin-bottom: 1.5rem;
  max-width: 100%;
}
.content-title {
  font-size: var(--font-size-xl);
  color: var(--text-color);
  margin: 0;
  max-width: 100%;
}
/* Post List Styling */
.post-list {
  list-style: none;
  padding: 0;
  margin: 0;
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Default to 3 columns on desktop */
  gap: 2rem;
  width: 100%;
  box-sizing: border-box;
}
.post-list .card {
  height: 100%;
  display: flex;
  flex-direction: column;
  background: var(--light-gray);
  padding: 1.5rem;
  border-radius: 8px;
  transition: transform 0.2s ease-in-out;
  box-sizing: border-box;
  width: 100%;
  overflow-wrap: break-word;
  word-wrap: break-word;
}
.post-list .card:hover {
  transform: translateY(-4px);
}
.post-list .card h3 {
  margin: 0.5rem 0;
  font-size: var(--font-size-lg);
  max-width: 100%;
}
.post-list .card p {
  margin: 0.5rem 0;
  flex-grow: 1;
  max-width: 100%;
}
.post-meta {
  color: var(--text-secondary);
  font-size: var(--font-size-sm);
  max-width: 100%;
}
/* Tables */
.content table {
  width: 100%;
  max-width: 100%;
  border-collapse: collapse;
  margin: 1.5rem 0;
  box-sizing: border-box;
}
.content table th,
.content table td {
  padding: 0.75rem;
  border: 1px solid var(--border-color);
  text-align: left;
  word-break: break-word;
}
.content table th {
  background: var(--light-gray);
}
/* Feature/Stats Cards Grid */
.feature-grid,
.stats-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr); /* Default to 3 columns on desktop */
  gap: 1.5rem;
  margin: 1.5rem 0;
  width: 100%;
  box-sizing: border-box;
}
.feature-card,
.stats-card {
  background: var(--light-gray);
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  width: 100%;
}
.stats-card {
  text-align: center;
}
.stats-number {
  font-size: var(--font-size-2xl);
  font-weight: var(--font-weight-bold);
  color: var(--brand-color);
  margin-bottom: 0.5rem;
}
.stats-label {
  font-size: var(--font-size-sm);
  color: var(--text-secondary);
}
/* Responsive Adjustments */
@media (max-width: 768px) {
  .content-container {
    margin: 0.75rem auto;
    padding: 0 0.5rem;
  }
  .content {
    padding: 1rem;
  }
  .content h1 {
    font-size: var(--font-size-xl);
    margin-bottom: 1rem;
  }
  .content h2 {
    font-size: var(--font-size-lg);
    margin: 1.5rem 0 0.75rem;
  }
  .content h3 {
    font-size: var(--font-size-md);
    margin: 1.25rem 0 0.5rem;
  }
  .content p, .content li {
    font-size: var(--font-size-base);
  }
  .content ul, .content ol {
    padding-left: 1.25rem;
  }
  .content img {
    margin: 1rem 0;
  }
  /* Force ONE box per line on mobile */
  .post-list,
  .feature-grid,
  .stats-grid {
    display: block !important; /* Stack grids on mobile */
  }
  .post-list .card,
  .feature-card,
  .stats-card {
    width: 100% !important;
    margin-bottom: 1rem !important;
    display: block !important;
  }
  /* Remove any fancy positioning */
  .post-list .card {
    height: auto !important;
    position: static !important;
  }
  .feature-card,
  .stats-card {
    position: static !important;
  }
  /* Handle table overflow on mobile */
  .content table {
    display: block;
    width: 100%;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    border: 0;
  }
  /* Convert table to cards on mobile */
  .content table, 
  .content table thead, 
  .content table tbody, 
  .content table tr, 
  .content table th, 
  .content table td {
    display: block;
    width: 100%;
    box-sizing: border-box;
  }
  .content table tr {
    margin-bottom: 1rem;
    border: 1px solid var(--border-color);
    border-radius: 4px;
  }
  .content table th {
    display: none;
  }
  .content table td {
    border: none;
    border-bottom: 1px solid var(--border-color);
    position: relative;
    padding-left: 0.5rem;
    padding-right: 0.5rem;
  }
  .content table td:last-child {
    border-bottom: 0;
  }
  /* Handle code blocks on mobile */
  .content pre {
    padding: 0.75rem;
    font-size: var(--font-size-sm);
    margin: 1rem -1rem;
    border-radius: 0;
    white-space: pre-wrap;
  }
  .content pre code {
    white-space: pre-wrap;
  }
  .content code {
    font-size: var(--font-size-sm);
    word-break: break-word;
    white-space: normal;
  }
  /* Ensure all inline elements wrap */
  .content * {
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
    hyphens: auto;
  }
  /* Handle long URLs and text */
  .content a,
  .content code,
  .content pre {
    max-width: 100%;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }
}
</file>

<file path="assets/css/treasury-v2.css">
/* Dashboard Container */
.dashboard-container {
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
}
/* Metrics Grid */
.metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}
.metric-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    min-width: 0; /* Prevent overflow */
}
.metric-card h3 {
    margin: 0;
    font-size: 0.9rem;
    color: #666;
    font-weight: 500;
}
.metric-value {
    font-size: 1.8rem;
    font-weight: 600;
    margin: 10px 0;
    color: #2c3e50;
    word-break: break-word; /* Allow long numbers to break */
    overflow-wrap: break-word;
}
.metric-change {
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 4px;
}
.metric-change.positive {
    color: #10b981;
}
.metric-change.negative {
    color: #ef4444;
}
/* Dashboard Sections */
.dashboard-section {
    background: white;
    border-radius: 12px;
    margin-bottom: 30px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}
.section-content {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}
.chart-card {
    background: white;
    border-radius: 8px;
    padding: 15px;
}
.chart-container {
    height: 300px;
    position: relative;
}
/* Asset Lists */
.asset-list-card {
    background: white;
    border-radius: 8px;
    padding: 15px;
}
.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
.card-header h3 {
    margin: 0;
    font-size: 1.1rem;
    font-weight: 600;
}
.select-styled {
    padding: 8px 12px;
    border-radius: 6px;
    border: 1px solid #e2e8f0;
    background: white;
    color: #2c3e50;
    font-size: 0.9rem;
    cursor: pointer;
}
.button-styled {
    padding: 8px 16px;
    border-radius: 6px;
    border: none;
    background: #3b82f6;
    color: white;
    font-size: 0.9rem;
    cursor: pointer;
    transition: background 0.2s ease;
}
.button-styled:hover {
    background: #2563eb;
}
.asset-list {
    max-height: 270px;
    overflow-y: auto;
}
.asset-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    border-radius: 8px;
    background: #f8fafc;
    margin-bottom: 8px;
}
.asset-info {
    display: flex;
    align-items: center;
    gap: 12px;
}
.asset-icon {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: #e2e8f0;
}
.asset-name {
    font-weight: 500;
    color: #2c3e50;
}
.asset-amount {
    color: #64748b;
    font-size: 0.9rem;
}
.asset-value {
    text-align: right;
}
.asset-price {
    font-weight: 500;
    color: #2c3e50;
}
.asset-change {
    font-size: 0.9rem;
}
/* Activity List */
.activity-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.activity-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    border-radius: 8px;
    background: #f8fafc;
    transition: background 0.2s ease;
}
.activity-item:hover {
    background: #f1f5f9;
}
.activity-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.activity-type {
    font-weight: 500;
    color: #2c3e50;
}
.activity-details {
    font-size: 0.9rem;
    color: #64748b;
}
.activity-time {
    font-size: 0.9rem;
    color: #94a3b8;
}
/* Error States */
.error-message {
    background: #fee2e2;
    border: 1px solid #ef4444;
    border-radius: 8px;
    padding: 20px;
    text-align: center;
    margin: 20px 0;
}
.error-message h3 {
    color: #dc2626;
    margin: 0 0 10px 0;
}
.error-message button {
    background: #dc2626;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 10px;
}
.error-message button:hover {
    background: #b91c1c;
}
/* Loading States */
.loading-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: #6b7280;
}
.loading-indicator::after {
    content: '';
    width: 20px;
    height: 20px;
    border: 2px solid #e5e7eb;
    border-top: 2px solid #3b82f6;
    border-radius: 50%;
    margin-left: 10px;
    animation: spin 1s linear infinite;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
/* Multisig Grid */
.multisig-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-bottom: 1.5rem;
}
.multisig-wallet {
    background: #f8fafc;
    border-radius: 8px;
    padding: 1.5rem;
    margin-top: 1.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    transition: transform 0.2s ease;
}
.multisig-wallet:hover {
    transform: translateY(-2px);
}
.multisig-wallet-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}
.multisig-wallet-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: #2c3e50;
}
.multisig-wallet-total {
    font-size: 1.2rem;
    font-weight: 700;
    color: #3b82f6;
}
.token-list {
    margin-top: 1rem;
}
.token-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 0;
    border-bottom: 1px solid #e2e8f0;
}
.token-item:last-child {
    border-bottom: none;
}
.token-name {
    color: #64748b;
    font-size: 0.9rem;
}
.token-amount {
    font-weight: 500;
    color: #2c3e50;
}
/* Dashboard Section Headers */
.dashboard-section h2 {
    margin: 0 0 1.5rem 0;
    font-size: 1.5rem;
    font-weight: 600;
    color: #2c3e50;
}
/* Responsive Design */
@media (max-width: 1200px) {
    .metrics-grid {
        grid-template-columns: repeat(3, 1fr);
    }
}
@media (max-width: 768px) {
    .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
    }
    .section-content {
        grid-template-columns: 1fr;
    }
}
@media (max-width: 480px) {
    .metrics-grid {
        grid-template-columns: 1fr;
    }
    .chart-container {
        height: 250px;
    }
    .metric-card h3 {
        font-size: 0.8rem;
    }
    .metric-value {
        font-size: 1.6rem;
    }
    .button-styled {
        padding: 10px 18px;
        font-size: 1rem;
    }
    .asset-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
    }
}
/* Token Distribution Chart */
.token-distribution-legend {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
    padding: 1rem;
    background: #f8fafc;
    border-radius: 8px;
}
.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}
.legend-color {
    width: 12px;
    height: 12px;
    border-radius: 2px;
}
.legend-label {
    font-size: 0.9rem;
    color: #64748b;
}
/* Make the charts more compact */
#liquid-portfolio-chart,
#illiquid-portfolio-chart,
#overall-distribution-chart,
#token-distribution-chart,
#treasury-components-chart {
    max-height: 300px;
}
/* Loading State */
.dashboard-container.loading {
    position: relative;
    min-height: 200px;
    opacity: 0.7;
    pointer-events: none;
}
.dashboard-loader {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    z-index: 1000;
}
.dashboard-loader .spinner {
    width: 50px;
    height: 50px;
    border: 3px solid #f3f3f3;
    border-top: 3px solid #3498db;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 10px;
}
.dashboard-loader p {
    margin: 0;
    color: #666;
    font-size: 14px;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
/* Error State */
.dashboard-error {
    padding: 20px;
    margin: 20px 0;
    background-color: #fff3f3;
    border: 1px solid #ffcdd2;
    border-radius: 4px;
    color: #d32f2f;
}
.dashboard-error h3 {
    margin: 0 0 10px;
    font-size: 16px;
}
.dashboard-error p {
    margin: 0;
    font-size: 14px;
}
/* Cost Analysis Section */
.cost-overview {
    margin-bottom: 2rem;
}
.cost-metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
}
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
}
.section-controls {
    display: flex;
    gap: 1rem;
}
.cost-charts-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
    margin-bottom: 2rem;
}
.cost-charts-grid .chart-card.full-width {
    grid-column: 1 / -1;
}
.metric-subtitle {
    font-size: 0.875rem;
    color: #64748b;
    margin-top: 0.25rem;
}
.cost-details {
    background: white;
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
.data-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
}
.data-table th,
.data-table td {
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 1px solid #e2e8f0;
}
.data-table th {
    background: #f8fafc;
    font-weight: 600;
    color: #475569;
}
.data-table tbody tr:hover {
    background: #f8fafc;
}
.cost-table-container {
    max-height: 400px;
    overflow-y: auto;
    margin-top: 1rem;
}
.input-styled {
    padding: 0.5rem 1rem;
    border: 1px solid #e2e8f0;
    border-radius: 6px;
    font-size: 0.875rem;
    color: #1e293b;
    min-width: 200px;
}
.input-styled:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 1px #3b82f6;
}
/* Responsive adjustments */
@media (max-width: 1024px) {
    .cost-charts-grid {
        grid-template-columns: 1fr;
    }
    .section-controls {
        flex-direction: column;
        gap: 0.5rem;
    }
}
@media (max-width: 640px) {
    .cost-metrics-grid {
        grid-template-columns: 1fr;
    }
    .data-table {
        display: block;
        overflow-x: auto;
        white-space: nowrap;
    }
}
/* Chart Tooltips */
.chart-tooltip {
    background: rgba(255, 255, 255, 0.95) !important;
    border-radius: 4px !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
    padding: 8px 12px !important;
    border: 1px solid #e2e8f0 !important;
    font-family: system-ui, -apple-system, sans-serif !important;
}
.chart-tooltip-label {
    color: #1e293b !important;
    font-weight: 500 !important;
    margin-bottom: 4px !important;
}
.chart-tooltip-value {
    color: #64748b !important;
    font-size: 0.875rem !important;
}
/* Animation for chart transitions */
.chart-container canvas {
    transition: opacity 0.2s ease;
}
.chart-container.loading canvas {
    opacity: 0.5;
}
/* Cost table sorting indicators */
.data-table th.sort-asc::after {
    content: "↑";
    margin-left: 4px;
}
.data-table th.sort-desc::after {
    content: "↓";
    margin-left: 4px;
}
/* Currency toggle styles */
.currency-toggle {
    display: inline-flex;
    background: #f1f5f9;
    border-radius: 6px;
    padding: 2px;
}
.currency-toggle button {
    padding: 4px 12px;
    border: none;
    background: none;
    border-radius: 4px;
    font-size: 0.875rem;
    color: #64748b;
    cursor: pointer;
}
.currency-toggle button.active {
    background: white;
    color: #1e293b;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}
/* Mobile Styles for Treasury Dashboard */
@media (max-width: 768px) {
  .dashboard-container {
      padding: 10px;
  }
  .metrics-grid {
      gap: 10px;
  }
  .section-content {
      grid-template-columns: 1fr;
  }
  .chart-container {
      height: auto;
  }
  .card-header {
      flex-direction: column;
      align-items: flex-start;
      gap: 8px;
  }
  .asset-item {
      padding: 8px;
  }
}
/* Mobile Styles for Multisig Section */
@media (max-width: 768px) {
    .multisig-grid {
         grid-template-columns: 1fr;
    }
    .multisig-wallet {
         padding: 1rem;
         margin-top: 1rem;
    }
    .multisig-wallet-header {
         flex-direction: column;
         align-items: flex-start;
         gap: 8px;
    }
}
</file>

<file path="assets/css/utilities.css">
/* utilities.css - Utility Classes for Spacing, Typography, and Quick Styling Adjustments */
/* Margin Utilities */
.m-0 { margin: 0 !important; }
.mt-1 { margin-top: 0.25rem !important; }
.mb-1 { margin-bottom: 0.25rem !important; }
.mt-2 { margin-top: 0.5rem !important; }
.mb-2 { margin-bottom: 0.5rem !important; }
/* Padding Utilities */
.p-0 { padding: 0 !important; }
.pt-1 { padding-top: 0.25rem !important; }
.pb-1 { padding-bottom: 0.25rem !important; }
.pt-2 { padding-top: 0.5rem !important; }
.pb-2 { padding-bottom: 0.5rem !important; }
/* Text Utilities */
.text-center { text-align: center !important; }
.text-right { text-align: right !important; }
.text-left { text-align: left !important; }
/* Display Utilities */
.d-block { display: block !important; }
.d-flex { display: flex !important; }
/* Overflow */
.overflow-hidden { overflow: hidden !important; }
/* Other generic utilities can be added here as needed */
</file>

<file path="assets/css/wiki-components.css">
/* Breadcrumbs */
.wiki-breadcrumbs {
  margin-bottom: 1.5rem;
}
.wiki-breadcrumbs ol {
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}
.wiki-breadcrumbs li {
  display: flex;
  align-items: center;
}
.wiki-breadcrumbs li:not(:last-child)::after {
  content: "/";
  margin: 0 0.5rem;
  color: #999;
}
.wiki-breadcrumbs a {
  color: #666;
  text-decoration: none;
  transition: color 0.2s;
}
.wiki-breadcrumbs a:hover {
  color: #333;
}
.wiki-context {
  margin-top: 0.5rem;
}
.learning-path-badge {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.8rem;
  color: white;
  margin-right: 0.5rem;
}
/* Related Content */
.wiki-related {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 2px solid #eee;
}
.wiki-related h2 {
  font-size: 1.8rem;
  margin-bottom: 1.5rem;
}
.related-section {
  margin-bottom: 2rem;
}
.related-section h3 {
  font-size: 1.4rem;
  margin-bottom: 1rem;
  color: #333;
}
.related-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}
.related-item {
  border: 1px solid #eee;
  border-radius: 8px;
  padding: 1rem;
  transition: box-shadow 0.2s;
}
.related-item:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
.related-type {
  margin-bottom: 0.5rem;
}
.relation-badge {
  display: inline-block;
  padding: 0.125rem 0.375rem;
  border-radius: 4px;
  font-size: 0.8rem;
  color: white;
}
.related-link {
  text-decoration: none;
  color: inherit;
}
.related-link h4 {
  font-size: 1.1rem;
  margin: 0 0 0.5rem;
  color: #333;
}
.related-link p {
  font-size: 0.9rem;
  color: #666;
  margin: 0;
}
/* Learning Paths */
.learning-path {
  margin-bottom: 1.5rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 8px;
}
.learning-path h4 {
  margin: 0 0 0.5rem;
  color: #333;
}
.learning-path p {
  font-size: 0.9rem;
  color: #666;
  margin: 0 0 1rem;
}
.path-sequence {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}
.path-step {
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  color: white;
  text-decoration: none;
  font-weight: 500;
  transition: transform 0.2s;
}
.path-step:hover {
  transform: scale(1.1);
}
.path-step.current {
  box-shadow: 0 0 0 2px white, 0 0 0 4px currentColor;
}
/* Navigation */
.wiki-navigation {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 2px solid #eee;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
}
.nav-prev,
.nav-next {
  text-decoration: none;
  color: inherit;
  padding: 1rem;
  border: 1px solid #eee;
  border-radius: 8px;
  transition: box-shadow 0.2s;
  display: flex;
  flex-direction: column;
}
.nav-prev:hover,
.nav-next:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}
.nav-label {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 0.25rem;
}
.nav-title {
  font-size: 1.1rem;
  font-weight: 500;
  color: #333;
  margin-bottom: 0.25rem;
}
.nav-summary {
  font-size: 0.9rem;
  color: #666;
}
.path-navigation {
  grid-column: 1 / -1;
  border: 1px solid;
  border-radius: 8px;
  padding: 1rem;
}
.path-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}
.path-name {
  font-weight: 500;
  color: #333;
}
.path-progress {
  font-size: 0.9rem;
  color: #666;
}
.path-controls {
  display: flex;
  gap: 1rem;
}
.path-prev,
.path-next {
  flex: 1;
  padding: 0.5rem 1rem;
  border-radius: 4px;
  color: white;
  text-decoration: none;
  text-align: center;
  transition: opacity 0.2s;
}
.path-prev:hover,
.path-next:hover {
  opacity: 0.9;
}
/* Tag Cloud */
.tag-cloud {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}
/* Responsive Design */
@media (max-width: 768px) {
  .wiki-navigation {
    grid-template-columns: 1fr;
  }
  .path-controls {
    flex-direction: column;
  }
}
</file>

<file path="assets/css/wiki.css">
/* Wiki Layout */
.wiki-container {
  display: grid;
  grid-template-columns: 250px minmax(0, 1fr) 300px;
  gap: 2rem;
  max-width: 1800px;
  margin: 0 auto;
  padding: 2rem;
  min-height: calc(100vh - var(--header-height));
}
/* Sidebar Navigation */
.wiki-sidebar {
  position: sticky;
  top: calc(var(--header-height) + 2rem);
  height: calc(100vh - var(--header-height) - 4rem);
  overflow-y: auto;
  padding-right: 1rem;
  border-right: 1px solid var(--border-color);
  scrollbar-width: thin;
  scrollbar-color: var(--border-color) transparent;
}
.wiki-nav-search {
  position: sticky;
  top: 0;
  background: var(--bg-color);
  padding: 1rem 0;
  margin-bottom: 1rem;
  z-index: 10;
}
.wiki-nav-search input {
  width: 100%;
  padding: 0.75rem 1rem;
  border: 1px solid var(--border-color);
  border-radius: 6px;
  font-size: 0.9rem;
  transition: border-color 0.2s, box-shadow 0.2s;
}
.wiki-nav-search input:focus {
  border-color: var(--primary-color);
  box-shadow: 0 0 0 2px var(--primary-color-alpha);
  outline: none;
}
.wiki-nav-sections {
  margin-bottom: 2rem;
}
.wiki-nav-section {
  margin-bottom: 1.5rem;
}
.wiki-nav-title {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-color);
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--border-color);
}
.wiki-nav-list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.wiki-nav-item {
  margin-bottom: 0.25rem;
}
.wiki-nav-link {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  color: var(--text-color-light);
  text-decoration: none;
  border-radius: 8px;
  font-size: 0.95rem;
  transition: all 0.2s ease;
}
.wiki-nav-link:hover {
  background-color: var(--hover-color);
  color: var(--text-color);
}
.wiki-nav-item.active .wiki-nav-link {
  background-color: var(--active-color);
  color: var(--primary-color);
  font-weight: 500;
}
.wiki-nav-count {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 1.5rem;
  height: 1.5rem;
  padding: 0 0.5rem;
  background: var(--bg-color-dark);
  color: var(--text-color-light);
  border-radius: 100px;
  font-size: 0.75rem;
  font-weight: 500;
}
/* Main Content */
.wiki-content {
  min-width: 0;
  padding: 0 2rem;
}
.wiki-header {
  margin-bottom: 3rem;
}
.wiki-title {
  font-size: 2.5rem;
  font-weight: 700;
  color: var(--text-color);
  margin-bottom: 1rem;
  line-height: 1.2;
}
.wiki-summary {
  font-size: 1.2rem;
  color: var(--text-color-light);
  margin-bottom: 2rem;
  line-height: 1.6;
}
/* Entry Cards */
.entry-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
  margin: 1.5rem 0;
}
.entry-card {
  background: var(--card-bg);
  padding: 1.75rem;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  transition: all 0.2s ease;
}
.entry-card:hover {
  border-color: var(--primary-color);
  background: var(--card-hover-bg);
  box-shadow: 0 4px 20px var(--shadow-color-hover);
  transform: translateY(-2px);
}
.entry-card h3 {
  margin: 0 0 1rem;
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-color);
}
.entry-card h3 a {
  color: var(--text-color);
  text-decoration: none;
}
.entry-card h3 a:hover {
  color: var(--primary-color);
}
.entry-card p {
  color: var(--text-color-light);
  margin: 0 0 1.25rem;
  line-height: 1.6;
  font-size: 0.95rem;
}
/* Learning Paths */
.path-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1.5rem;
  margin: 1.5rem 0;
}
.path-card {
  background: var(--bg-color-light);
  padding: 1.75rem;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  transition: all 0.2s ease;
}
.path-card:hover {
  border-color: var(--primary-color);
  background: var(--card-bg);
  box-shadow: 0 4px 20px var(--shadow-color-hover);
}
.path-card h3 {
  color: var(--text-color);
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0 0 0.75rem;
}
.path-card p {
  color: var(--text-color-light);
  font-size: 0.95rem;
  line-height: 1.6;
  margin-bottom: 1.25rem;
}
.path-steps {
  display: flex;
  flex-wrap: wrap;
  gap: 0.75rem;
  margin: 1.25rem 0;
}
.path-step {
  width: 2.5rem;
  height: 2.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: var(--primary-color);
  color: white;
  text-decoration: none;
  font-weight: 500;
  font-size: 0.9rem;
  transition: all 0.2s ease;
}
.path-step:hover {
  transform: scale(1.1);
  background: var(--primary-color-dark);
}
.path-step.active {
  background: var(--primary-color-dark);
  box-shadow: 0 0 0 3px var(--primary-color-alpha);
}
.path-link {
  display: inline-block;
  padding: 0.75rem 1.5rem;
  background: var(--primary-color);
  color: white;
  text-decoration: none;
  border-radius: 8px;
  font-weight: 500;
  font-size: 0.95rem;
  transition: all 0.2s ease;
}
.path-link:hover {
  background: var(--primary-color-dark);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px var(--shadow-color);
}
/* Graph Sidebar */
.wiki-graph-sidebar {
  position: sticky;
  top: calc(var(--header-height) + 2rem);
  height: calc(100vh - var(--header-height) - 4rem);
  overflow-y: auto;
  padding-left: 1rem;
  border-left: 1px solid var(--border-color);
}
/* Badges and Tags */
.badge {
  display: inline-flex;
  align-items: center;
  padding: 0.35rem 0.75rem;
  border-radius: 100px;
  font-size: 0.8rem;
  font-weight: 500;
  color: white;
  line-height: 1;
}
.difficulty-badge {
  composes: badge;
}
.status-badge {
  composes: badge;
}
.wiki-tag {
  display: inline-flex;
  align-items: center;
  padding: 0.35rem 0.75rem;
  background: var(--bg-color-dark);
  color: var(--text-color-light);
  border-radius: 100px;
  font-size: 0.8rem;
  font-weight: 500;
  text-decoration: none;
  transition: all 0.2s ease;
  margin-right: 0.5rem;
  margin-bottom: 0.5rem;
}
.wiki-tag:hover {
  background: var(--hover-color);
  color: var(--text-color);
  transform: translateY(-1px);
}
/* Metadata */
.wiki-metadata-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-radius: 8px;
}
.metadata-item {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.metadata-label {
  font-size: 0.9rem;
  font-weight: 500;
  color: #666;
}
.metadata-value {
  font-size: 1rem;
  color: #333;
}
/* Tags */
.tag {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 4px;
  font-size: 0.9rem;
  color: white;
  margin-right: 0.5rem;
  margin-bottom: 0.5rem;
}
/* Wiki Body */
.wiki-body {
  font-size: 1.1rem;
  line-height: 1.6;
  color: #333;
}
.wiki-body h2 {
  font-size: 1.8rem;
  margin: 2rem 0 1rem;
  padding-bottom: 0.5rem;
  border-bottom: 2px solid #eee;
}
.wiki-body h3 {
  font-size: 1.4rem;
  margin: 1.5rem 0 1rem;
}
.wiki-body ul {
  padding-left: 1.5rem;
  margin-bottom: 1rem;
}
.wiki-body li {
  margin-bottom: 0.5rem;
}
/* Graph Container */
#graph-container {
  flex-grow: 1;
  background-color: #f8f9fa;
  border-radius: 8px;
  overflow: hidden;
}
/* Responsive Design */
@media (max-width: 1200px) {
  .wiki-container {
    grid-template-columns: 220px minmax(0, 1fr);
  }
  .wiki-graph-sidebar {
    display: none;
  }
}
@media (max-width: 768px) {
  .wiki-container {
    grid-template-columns: 1fr;
    padding: 1rem;
    gap: 1rem;
  }
  .wiki-sidebar {
    position: fixed;
    left: -100%;
    top: var(--header-height);
    bottom: 0;
    width: 100%;
    max-width: 300px;
    background: var(--background-color);
    border-right: 1px solid var(--border-color);
    transition: left 0.3s ease;
    z-index: 100;
  }
  .wiki-sidebar.open {
    left: 0;
  }
  .wiki-content {
    padding: 0;
  }
  .wiki-title {
    font-size: var(--font-size-xl);
    margin-bottom: 0.75rem;
  }
  .wiki-summary {
    font-size: var(--font-size-base);
    margin-bottom: 1.5rem;
  }
  .entry-grid,
  .path-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  .entry-card,
  .path-card {
    padding: 1.25rem;
  }
  .wiki-nav-search input {
    font-size: 16px;
    height: 44px;
  }
  .wiki-nav-link {
    padding: 0.75rem;
    min-height: 44px;
  }
}
@media (max-width: 480px) {
  .wiki-container {
    padding: 0.5rem;
  }
  .wiki-header {
    margin-bottom: 2rem;
  }
  .entry-card,
  .path-card {
    padding: 1rem;
    border-radius: 0.5rem;
  }
  .path-steps {
    gap: 0.5rem;
  }
  .path-step {
    width: 2rem;
    height: 2rem;
    font-size: 0.8rem;
  }
}
/* CSS Variables */
:root {
  --header-height: 60px;
  /* Primary Colors */
  --primary-color: #2563eb;
  --primary-color-light: #eff6ff;
  --primary-color-dark: #1e40af;
  --primary-color-alpha: rgba(37, 99, 235, 0.1);
  /* Text Colors */
  --text-color: #111827;
  --text-color-light: #4b5563;
  --text-color-lighter: #6b7280;
  /* Background Colors */
  --bg-color: #ffffff;
  --bg-color-light: #f9fafb;
  --bg-color-dark: #f3f4f6;
  /* Border Colors */
  --border-color: #e5e7eb;
  --border-color-dark: #d1d5db;
  /* Card Colors */
  --card-bg: #ffffff;
  --card-hover-bg: #f9fafb;
  /* Interactive Colors */
  --hover-color: #f3f4f6;
  --active-color: #eff6ff;
  --shadow-color: rgba(0, 0, 0, 0.05);
  --shadow-color-hover: rgba(0, 0, 0, 0.1);
  /* Status Colors */
  --success-color: #059669;
  --warning-color: #d97706;
  --info-color: #2563eb;
  --draft-color: #6b7280;
}
</file>

<file path="assets/images/logo-black-transparent.svg">
<svg width="200" height="200" viewBox="0 0 200 200" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="105.064" cy="100.004" r="65.2328" stroke="#181818" stroke-width="9.40432"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M104.37 36.2394C69.1549 36.2394 40.6074 64.7869 40.6074 100.002C40.6074 135.217 69.1549 163.765 104.37 163.765H105.067V36.2394H104.37ZM49.6783 95.5907C55.4623 89.1793 62.8264 83.9317 71.2453 82.1895C79.8303 80.4129 89.0262 82.3875 98.007 89.5488L93.3164 95.431C85.9136 89.528 78.9608 88.2757 72.7699 89.5568C66.4127 90.8724 60.3735 94.9671 55.2645 100.63L49.6783 95.5907Z" fill="#181818"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M139.615 82.1858C148.034 83.928 155.398 89.1757 161.182 95.587L155.596 100.627C150.487 94.9635 144.448 90.8687 138.091 89.5532C131.9 88.272 124.947 89.5244 117.544 95.4274L112.853 89.5451C121.834 82.3839 131.03 80.4093 139.615 82.1858Z" fill="#181818"/>
<path d="M66.2809 102L105.497 169.925H27.0644L66.2809 102Z" fill="#181818"/>
</svg>
</file>

<file path="assets/js/mobile-nav.js">
// Mobile Navigation
document.addEventListener('DOMContentLoaded', function() {
    const burgerMenu = document.querySelector('.burger-menu');
    const navLinks = document.querySelector('.nav-links');
    const wikiSidebar = document.querySelector('.wiki-sidebar');
    // Toggle navigation menu
    if (burgerMenu && navLinks) {
        burgerMenu.addEventListener('click', function(e) {
            e.preventDefault();
            navLinks.classList.toggle('open');
            burgerMenu.textContent = navLinks.classList.contains('open') ? '✕' : '☰';
        });
    }
    // Close navigation when clicking outside
    document.addEventListener('click', function(e) {
        if (navLinks && navLinks.classList.contains('open')) {
            if (!navLinks.contains(e.target) && !burgerMenu.contains(e.target)) {
                navLinks.classList.remove('open');
                burgerMenu.textContent = '☰';
            }
        }
    });
    // Handle wiki sidebar on mobile
    if (wikiSidebar) {
        const wikiToggle = document.createElement('button');
        wikiToggle.className = 'wiki-sidebar-toggle';
        wikiToggle.innerHTML = '☰ Menu';
        wikiToggle.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 101;
            background: var(--brand-color);
            color: white;
            border: none;
            border-radius: 100px;
            padding: 12px 24px;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            display: none;
        `;
        document.body.appendChild(wikiToggle);
        // Show/hide toggle button based on screen size
        const mediaQuery = window.matchMedia('(max-width: 768px)');
        function handleScreenChange(e) {
            wikiToggle.style.display = e.matches ? 'block' : 'none';
        }
        mediaQuery.addListener(handleScreenChange);
        handleScreenChange(mediaQuery);
        // Toggle wiki sidebar
        wikiToggle.addEventListener('click', function() {
            wikiSidebar.classList.toggle('open');
            wikiToggle.innerHTML = wikiSidebar.classList.contains('open') ? '✕ Close' : '☰ Menu';
        });
        // Close sidebar when clicking outside
        document.addEventListener('click', function(e) {
            if (wikiSidebar.classList.contains('open')) {
                if (!wikiSidebar.contains(e.target) && !wikiToggle.contains(e.target)) {
                    wikiSidebar.classList.remove('open');
                    wikiToggle.innerHTML = '☰ Menu';
                }
            }
        });
    }
});
</file>

<file path="assets/js/network-viz.js">
// Network visualization using D3.js
class NetworkVisualization {
    constructor(selector) {
        this.container = d3.select(selector);
        this.width = this.container.node().getBoundingClientRect().width;
        this.height = this.container.node().getBoundingClientRect().height;
        this.simulation = null;
        this.svg = null;
        this.nodes = [];
        this.links = [];
        // Initialize the visualization
        this.init();
        this.generateData();
        this.render();
    }
    init() {
        this.svg = this.container.append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", [0, 0, this.width, this.height]);
        // Define larger forces for more spread
        this.simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(100)) // Increased distance
            .force("charge", d3.forceManyBody().strength(-400)) // Stronger repulsion
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collision", d3.forceCollide().radius(60)); // Increased collision radius
        // Add gradient definitions
        const defs = this.svg.append("defs");
        // Node gradient
        const nodeGradient = defs.append("linearGradient")
            .attr("id", "nodeGradient")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "100%");
        nodeGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "var(--brand-color)");
        nodeGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "rgb(98, 145, 178)");
        // Link gradient
        const linkGradient = defs.append("linearGradient")
            .attr("id", "linkGradient")
            .attr("gradientUnits", "userSpaceOnUse");
        linkGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", "rgba(98, 145, 178, 0.3)");
        linkGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", "rgba(98, 145, 178, 0.1)");
    }
    generateData() {
        // Core concepts with larger nodes
        const coreNodes = [
            { id: "Identity", size: 40 },
            { id: "Governance", size: 40 },
            { id: "Value Exchange", size: 40 },
            { id: "Community", size: 40 }
        ];
        // Features with smaller nodes
        const featureNodes = [
            { id: "Roles", size: 25 },
            { id: "Chat", size: 25 },
            { id: "Tokens", size: 25 },
            { id: "Forums", size: 25 },
            { id: "Treasury", size: 25 },
            { id: "Voting", size: 25 }
        ];
        this.nodes = [...coreNodes, ...featureNodes];
        // Create more connections between nodes
        this.links = [
            { source: "Identity", target: "Roles" },
            { source: "Identity", target: "Chat" },
            { source: "Identity", target: "Community" },
            { source: "Governance", target: "Voting" },
            { source: "Governance", target: "Treasury" },
            { source: "Governance", target: "Community" },
            { source: "Value Exchange", target: "Tokens" },
            { source: "Value Exchange", target: "Treasury" },
            { source: "Community", target: "Forums" },
            { source: "Community", target: "Chat" },
            { source: "Governance", target: "Value Exchange" },
            { source: "Identity", target: "Value Exchange" },
            { source: "Identity", target: "Governance" }            
        ];
    }
    render() {
        // Create links with gradient
        const links = this.svg.append("g")
            .selectAll("line")
            .data(this.links)
            .join("line")
            .style("stroke", "url(#linkGradient)")
            .style("stroke-width", 2);
        // Create nodes with varying sizes
        const nodes = this.svg.append("g")
            .selectAll("circle")
            .data(this.nodes)
            .join("circle")
            .attr("r", d => d.size)
            .style("fill", "url(#nodeGradient)")
            .style("opacity", 0.8)
            .call(this.drag(this.simulation));
        // Add labels with improved positioning and styling
        const labels = this.svg.append("g")
            .selectAll("text")
            .data(this.nodes)
            .join("text")
            .text(d => d.id)
            .attr("class", d => d.size > 30 ? "core-label" : "feature-label")
            .attr("font-size", d => d.size > 30 ? "16px" : "14px")
            .attr("font-weight", d => d.size > 30 ? "600" : "500")
            .attr("text-anchor", "middle")
            .attr("dy", d => d.size > 30 ? "45px" : "35px")  // Position below nodes
            .style("fill", "var(--text-color)")
            .style("pointer-events", "none")
            .style("text-shadow", "2px 2px 4px rgba(255,255,255,0.8), -2px -2px 4px rgba(255,255,255,0.8), 2px -2px 4px rgba(255,255,255,0.8), -2px 2px 4px rgba(255,255,255,0.8)")  // Add white glow for better readability
            .style("user-select", "none");
        // Update simulation
        this.simulation
            .nodes(this.nodes)
            .on("tick", () => {
                links
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                nodes
                    .attr("cx", d => d.x = Math.max(d.size, Math.min(this.width - d.size, d.x)))
                    .attr("cy", d => d.y = Math.max(d.size, Math.min(this.height - d.size, d.y)));
                labels
                    .attr("x", d => d.x)
                    .attr("y", d => d.y);
            });
        this.simulation.force("link").links(this.links);
        // Add zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.5, 2])
            .on("zoom", (event) => {
                this.svg.selectAll("g").attr("transform", event.transform);
            });
        this.svg.call(zoom);
    }
    drag(simulation) {
        function dragstarted(event) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }
        function dragged(event) {
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }
        function dragended(event) {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }
        return d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended);
    }
}
// Initialize visualization when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new NetworkVisualization('.network-visualization');
});
</file>

<file path="assets/js/price-updates.js">
// Debug logging system
const Debug = {
  SSE: {
    log: (msg) => console.log(`[SSE] ${msg}`),
    error: (msg) => console.error(`[SSE] ${msg}`)
  },
  Progress: {
    group(title, fn) {
      console.group(`📊 Progress: ${title}`);
      try {
        fn();
      } finally {
        console.groupEnd();
      }
    },
    log: (...args) => console.log('📊 Progress:', ...args),
    error: (...args) => console.error('❌ Progress:', ...args),
    warn: (...args) => console.warn('⚠️ Progress:', ...args)
  },
  Updates: {
    log: (msg) => console.log(`[Updates] ${msg}`),
    error: (msg) => console.error(`[Updates] ${msg}`)
  },
  Dashboard: {
    group(title, fn) {
      console.group(`📈 Dashboard: ${title}`);
      try {
        fn();
      } finally {
        console.groupEnd();
      }
    },
    log: (...args) => console.log('📈 Dashboard:', ...args),
    error: (...args) => console.error('❌ Dashboard:', ...args),
    warn: (...args) => console.warn('⚠️ Dashboard:', ...args)
  }
};
(function() {
  // Price update progress component
  class PriceUpdateProgress {
    constructor() {
      // Create progress container
      this.container = document.createElement('div');
      this.container.style.cssText = `
        position: absolute;
        top: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px 12px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 1000;
        font-size: 0.9rem;
        display: none;
        max-width: 250px;
      `;
      // Create status text
      this.statusText = document.createElement('div');
      this.statusText.style.marginBottom = '6px';
      this.container.appendChild(this.statusText);
      // Create progress bar container
      const progressBarContainer = document.createElement('div');
      progressBarContainer.style.cssText = `
        background: #f0f0f0;
        border-radius: 2px;
        height: 3px;
        width: 100%;
        overflow: hidden;
      `;
      // Create progress bar
      this.progressBar = document.createElement('div');
      this.progressBar.style.cssText = `
        background: #4CAF50;
        height: 100%;
        width: 0;
        transition: width 0.3s ease;
      `;
      progressBarContainer.appendChild(this.progressBar);
      this.container.appendChild(progressBarContainer);
      // Add to the content header instead of dashboard
      const contentHeader = document.querySelector('.content-header');
      if (contentHeader) {
        contentHeader.style.position = 'relative';
        contentHeader.appendChild(this.container);
      } else {
        const header = document.querySelector('h1, h2');
        if (header) {
          header.style.position = 'relative';
          header.appendChild(this.container);
        } else {
          document.body.appendChild(this.container);
        }
      }
      // State tracking
      this.isVisible = false;
      this.queuedTransactions = 0;
      this.validTokens = 0;
      this.invalidTokens = 0;
      this.completedUpdates = 0;
      this.lastUpdateTime = null;
      this.inactivityTimer = null;
      this.inactivityTimeout = 5000; // 5 seconds
      this.state = 'initializing';
      this.hasActiveUpdates = false;
    }
    show() {
      if (this.hasActiveUpdates && !this.isVisible) {
        this.container.style.display = 'block';
        this.isVisible = true;
      }
    }
    hide() {
      if (this.isVisible) {
        this.container.style.display = 'none';
        this.isVisible = false;
        this.resetState();
      }
    }
    resetState() {
      this.queuedTransactions = 0;
      this.validTokens = 0;
      this.invalidTokens = 0;
      this.completedUpdates = 0;
      this.state = 'initializing';
      this.hasActiveUpdates = false;
    }
    clearInactivityTimer() {
      if (this.inactivityTimer) {
        clearTimeout(this.inactivityTimer);
        this.inactivityTimer = null;
      }
    }
    setQueuedTransactions(count) {
      if (count > 0) {
        this.hasActiveUpdates = true;
        this.queuedTransactions = count;
        this.state = 'validating';
        this.updateDisplay();
      }
    }
    updateTokenValidation(valid, invalid) {
      this.validTokens = valid;
      this.invalidTokens = invalid;
      if (this.state === 'validating') {
        this.state = 'processing';
      }
      this.updateDisplay();
    }
    trackUpdate(token, timestamp) {
      this.completedUpdates++;
      this.lastUpdateTime = Date.now();
      if (this.completedUpdates >= this.validTokens) {
        this.state = 'completed';
        setTimeout(() => this.hide(), 2000);
      }
      this.updateDisplay();
    }
    updateDisplay() {
      this.show();
      let statusText;
      let progressPercent = 0;
      switch (this.state) {
        case 'initializing':
          statusText = 'Initializing price updates...';
          break;
        case 'validating':
          const validatedCount = this.validTokens + this.invalidTokens;
          progressPercent = this.queuedTransactions > 0 ? 
            (validatedCount / this.queuedTransactions) * 100 : 0;
          statusText = `Validating tokens (${validatedCount}/${this.queuedTransactions})`;
          break;
        case 'processing':
          progressPercent = this.validTokens > 0 ? 
            (this.completedUpdates / this.validTokens) * 100 : 0;
          statusText = `Updated ${this.completedUpdates} of ${this.validTokens} valid tokens`;
          if (this.invalidTokens > 0) {
            statusText += ` (${this.invalidTokens} invalid)`;
          }
          break;
        case 'completed':
          statusText = `Updated ${this.completedUpdates} tokens`;
          if (this.invalidTokens > 0) {
            statusText += ` (${this.invalidTokens} invalid)`;
          }
          progressPercent = 100;
          break;
        case 'error':
          statusText = 'Error updating prices';
          break;
      }
      this.statusText.textContent = statusText;
      this.progressBar.style.width = `${progressPercent}%`;
    }
    updateProgress(progress) {
      if (!progress || typeof progress !== 'object') {
        Debug.Progress.warn('Invalid progress update:', progress);
        return;
      }
      const { status, valid, invalid, completed } = progress;
      switch (status) {
        case 'connecting':
          if (this.hasActiveUpdates) {
            this.state = 'initializing';
          }
          break;
        case 'validating':
          if (valid === 0 && invalid === 0) {
            this.hide();
            return;
          }
          this.updateTokenValidation(valid || 0, invalid || 0);
          break;
        case 'processing':
          if (completed) this.completedUpdates = completed;
          break;
        case 'error':
          this.state = 'error';
          setTimeout(() => this.hide(), 3000);
          break;
        case 'completed':
          this.state = 'completed';
          setTimeout(() => {
            this.hide();
            this.hasActiveUpdates = false;
          }, 2000);
          break;
        case 'idle':
          if (!this.hasActiveUpdates) {
            this.hide();
          }
          break;
      }
      this.updateDisplay();
    }
  }
  // Initialize progress component
  const priceUpdateProgress = new PriceUpdateProgress();
  let eventSource = null;
  let reconnectAttempts = 0;
  const MAX_RECONNECT_ATTEMPTS = 5;
  const INITIAL_RECONNECT_DELAY = 1000;
  // API base URL
  const API_BASE_URL = 'http://localhost:3000';
  // Queue transactions for price updates
  function queueTransactionsForUpdate(transactions, skipIfQueued = false) {
    if (!Array.isArray(transactions) || transactions.length === 0) return;
    // Filter out stablecoins as they're always $1
    const STABLECOINS = ['USDC', 'USDT', 'DAI', 'xDAI'];
    const transactionsToUpdate = transactions.filter(tx => !STABLECOINS.includes(tx.token));
    Debug.Updates.log(`Queueing ${transactionsToUpdate.length} non-stablecoin transactions for update`);
    const updates = transactionsToUpdate.map(tx => ({
      token: tx.token,
      timestamp: Math.floor(new Date(tx.date).getTime() / 1000),
      amount: parseFloat(tx.amount)
    }));
    // Set initial queued count
    priceUpdateProgress.setQueuedTransactions(updates.length);
    fetch(`${API_BASE_URL}/api/prices/queue`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ transactions: updates })
    })
    .then(response => {
      Debug.Updates.log(`Queue response status: ${response.status}`);
      return response.json();
    })
    .catch(error => {
      Debug.Updates.error(`Failed to queue updates: ${error.message}`);
      priceUpdateProgress.updateProgress({ status: 'error' });
    });
  }
  // Debounce function for dashboard updates
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  // Batch dashboard updates
  const refreshDashboard = debounce(() => {
    Debug.Dashboard.group('Refresh', () => {
      Debug.Dashboard.log('Starting dashboard refresh');
      window.treasury.calculateMetrics();
      window.treasuryCharts.createTokenCharts();
      window.treasuryCharts.createVolumeChart();
      const currentPage = parseInt(document.getElementById('current-page').textContent);
      const itemsPerPage = 10;
      Debug.Dashboard.log('Re-rendering transactions page', { currentPage, itemsPerPage });
      const originalRenderTransactions = window.treasury.renderTransactions;
      window.treasury.renderTransactions = function(transactions, page, perPage) {
        Debug.Dashboard.log('Rendering transactions', { 
          total: transactions.length,
          page,
          perPage,
          showing: `${(page-1)*perPage + 1}-${Math.min(page*perPage, transactions.length)}`
        });
        const start = (page - 1) * perPage;
        const end = start + perPage;
        const tbody = document.getElementById('transactions-body');
        tbody.innerHTML = '';
        transactions.slice(start, end).forEach(tx => {
          const row = document.createElement('tr');
          const isIncoming = window.treasury.incomingTx.includes(tx);
          row.innerHTML = `
            <td>${new Date(tx.date).toLocaleDateString()}</td>
            <td>${tx.token}</td>
            <td title="${tx.from}">${tx.from.slice(0, 8)}...</td>
            <td title="${tx.to}">${tx.to.slice(0, 8)}...</td>
            <td class="${isIncoming ? 'incoming' : 'outgoing'}">${tx.amount} ${tx.token}</td>
            <td class="usd-value">${tx.valueUSD || 'Updating...'}</td>
          `;
          tbody.appendChild(row);
        });
      };
      window.treasury.renderTransactions(window.treasury.transactions, currentPage, itemsPerPage);
      window.treasury.renderTransactions = originalRenderTransactions;
      Debug.Dashboard.log('Dashboard refresh complete');
    });
  }, 500);  // Wait for all updates in a 500ms window
  // Connect to SSE endpoint for progress updates
  function initializePriceUpdates(isReconnect = false) {
    // Close existing connection if any
    if (eventSource) {
      eventSource.close();
      eventSource = null;
    }
    // Don't show progress on reconnect if no active updates
    if (isReconnect && !priceUpdateProgress.hasActiveUpdates) {
      return;
    }
    // Check if we've exceeded max reconnection attempts
    if (isReconnect && reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
      console.error('Max reconnection attempts reached. Giving up.');
      priceUpdateProgress.updateProgress({
        total: 0,
        completed: 0,
        failed: 0,
        status: 'error'
      });
      return;
    }
    try {
      eventSource = new EventSource(`${API_BASE_URL}/api/prices/progress`, {
        withCredentials: true
      });
      let heartbeatTimeout;
      const resetHeartbeatTimeout = () => {
        if (heartbeatTimeout) clearTimeout(heartbeatTimeout);
        heartbeatTimeout = setTimeout(() => {
          console.error('SSE heartbeat timeout');
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          initializePriceUpdates(true);
        }, 45000); // Wait 45 seconds for heartbeat (timeout after missing one)
      };
      eventSource.onopen = () => {
        console.log('SSE connection established');
        reconnectAttempts = 0; // Reset reconnect attempts on successful connection
        resetHeartbeatTimeout();
        // Show connecting state
        priceUpdateProgress.updateProgress({
          total: 0,
          completed: 0,
          failed: 0,
          status: 'connecting'
        });
      };
      eventSource.onmessage = (event) => {
        resetHeartbeatTimeout();
        if (event.data.trim() === '') {
          Debug.SSE.log('Received heartbeat');
          if (!priceUpdateProgress.hasActiveUpdates) {
            priceUpdateProgress.updateProgress({ status: 'idle' });
          }
          return;
        }
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'progress') {
            const progress = data.progress;
            if (progress.type === 'price_update' && Array.isArray(progress.updates)) {
              Debug.Updates.log(`Processing ${progress.updates.length} price updates`);
              let updatedAny = false;
              let updateStats = { attempted: 0, succeeded: 0, failed: 0 };
              progress.updates.forEach(update => {
                const { token, timestamp, price } = update;
                updateStats.attempted++;
                let found = false;
                window.treasury.transactions.forEach(tx => {
                  const txTimestamp = Math.floor(new Date(tx.date).getTime() / 1000);
                  if (tx.token === token && txTimestamp === timestamp) {
                    tx.valueUSD = `$${price.toFixed(2)}`;
                    updatedAny = true;
                    found = true;
                    updateStats.succeeded++;
                    // Track successful update
                    priceUpdateProgress.trackUpdate(token, txTimestamp);
                  }
                });
                if (!found) {
                  Debug.Updates.log(`No matching transaction found for ${token} at ${timestamp}`);
                  updateStats.failed++;
                }
              });
              Debug.Updates.log(`Update complete - Attempted: ${updateStats.attempted}, Succeeded: ${updateStats.succeeded}, Failed: ${updateStats.failed}`);
              if (updatedAny) {
                Debug.Updates.log('Refreshing dashboard');
                refreshDashboard();
              }
            } else {
              priceUpdateProgress.updateProgress(progress);
            }
          }
        } catch (error) {
          Debug.SSE.error(`Failed to process message: ${error.message}`);
        }
      };
      eventSource.onerror = (error) => {
        const errorMessage = error.message || 'Unknown error';
        console.error('SSE connection error:', error);
        console.log('EventSource readyState:', eventSource?.readyState);
        if (heartbeatTimeout) {
          clearTimeout(heartbeatTimeout);
          heartbeatTimeout = null;
        }
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
        // Only attempt reconnect if we haven't reached the limit
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1);
          console.log(`Attempting reconnect ${reconnectAttempts} of ${MAX_RECONNECT_ATTEMPTS} in ${delay}ms`);
          // Show reconnecting state
          priceUpdateProgress.updateProgress({
            total: 0,
            completed: 0,
            failed: 0,
            status: 'reconnecting'
          });
          setTimeout(() => {
            initializePriceUpdates(true);
          }, delay);
        } else {
          console.error('Max reconnection attempts reached');
          priceUpdateProgress.updateProgress({
            total: 0,
            completed: 0,
            failed: 0,
            status: 'error'
          });
        }
      };
      // Clean up function
      return () => {
        if (heartbeatTimeout) {
          clearTimeout(heartbeatTimeout);
          heartbeatTimeout = null;
        }
        if (eventSource) {
          eventSource.close();
          eventSource = null;
        }
      };
    } catch (error) {
      console.error('Error initializing SSE connection:', error);
      if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
        reconnectAttempts++;
        const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts - 1);
        setTimeout(() => {
          initializePriceUpdates(true);
        }, delay);
      }
    }
  }
  // Update transaction values in the UI
  function updateTransactionValues(updates) {
    console.log('[Price Updates] Received updates to apply:', updates);
    if (!Array.isArray(updates)) {
      console.warn('[Price Updates] Updates is not an array:', updates);
      return;
    }
    // Debug: List all available data-tx-key elements
    const allElements = document.querySelectorAll('[data-tx-key]');
    console.log(`[Price Updates] Found ${allElements.length} total elements with data-tx-key attributes`);
    if (allElements.length > 0) {
      console.log('[Price Updates] Available keys:', Array.from(allElements).map(el => el.getAttribute('data-tx-key')));
    }
    let updatedCount = 0;
    updates.forEach(update => {
      if (!update || !update.token || !update.timestamp) {
        console.warn('[Price Updates] Invalid update object:', update);
        return;
      }
      // Try both Unix timestamp and ISO date formats
      const unixKey = `${update.token}-${update.timestamp}`;
      const isoDate = new Date(update.timestamp * 1000).toISOString().split('T')[0];
      const isoKey = `${update.token}-${isoDate}`;
      console.log(`[Price Updates] Looking for elements with keys:`, {
        unixKey,
        isoKey,
        token: update.token,
        timestamp: update.timestamp,
        isoDate
      });
      // Try both formats
      let elements = document.querySelectorAll(`[data-tx-key="${unixKey}"]`);
      if (elements.length === 0) {
        elements = document.querySelectorAll(`[data-tx-key="${isoKey}"]`);
      }
      console.log(`[Price Updates] Found ${elements.length} elements to update for ${update.token}`);
      elements.forEach(element => {
        const oldValue = element.textContent;
        const newValue = `$${update.price.toFixed(2)}`;
        console.log(`[Price Updates] Updating element from ${oldValue} to ${newValue}`);
        // Add highlight effect
        element.classList.add('price-updated');
        element.textContent = newValue;
        updatedCount++;
        // Remove highlight effect after animation
        setTimeout(() => {
          element.classList.remove('price-updated');
        }, 1000);
      });
    });
    console.log(`[Price Updates] Completed updates: ${updatedCount} elements updated`);
  }
  // Add necessary styles
  const style = document.createElement('style');
  style.textContent = `
    .price-updated {
      animation: highlight-price 1s ease-in-out;
    }
    .dashboard-updated {
      animation: highlight-dashboard 1s ease-in-out;
    }
    @keyframes highlight-price {
      0% { background-color: transparent; }
      50% { background-color: rgba(76, 175, 80, 0.1); }
      100% { background-color: transparent; }
    }
    @keyframes highlight-dashboard {
      0% { opacity: 1; }
      50% { opacity: 0.8; }
      100% { opacity: 1; }
    }
  `;
  document.head.appendChild(style);
  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // First connect to SSE for updates
    initializePriceUpdates();
    // Then queue all transactions for price updates when treasury data is available
    const checkTreasuryData = setInterval(() => {
      if (window.treasury?.transactions) {
        Debug.Updates.log('Treasury data loaded, queueing all transactions for price updates');
        queueTransactionsForUpdate(window.treasury.transactions);
        clearInterval(checkTreasuryData);
      }
    }, 100);
    // Clean up on page unload
    window.addEventListener('unload', () => {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      clearInterval(checkTreasuryData);
    });
  });
  // Make functions globally available
  window.priceUpdates = {
    initializePriceUpdates,
    updateTransactionValues,
    queueTransactionsForUpdate
  };
})();
</file>

<file path="assets/js/treasury-cost-charts.js">
// Cost Visualization Handler
class CostVisualization {
    constructor(treasuryDataService) {
        this.dataService = treasuryDataService;
        this.charts = {};
        this.currentYear = '2025';
        this.currentCurrency = 'USD';
        this.colors = {
            infrastructure: '#3b82f6',
            corporate: '#10b981',
            expenses: '#f59e0b',
            salaries: '#ef4444',
            other: '#8b5cf6'
        };
    }
    initialize() {
        this.initializeCharts();
        this.setupEventListeners();
        this.updateVisualizations();
    }
    initializeCharts() {
        // Category Distribution Chart
        this.charts.category = new Chart(
            document.getElementById('cost-category-chart').getContext('2d'),
            {
                type: 'doughnut',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: Object.values(this.colors)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        },
                        tooltip: {
                            callbacks: {
                                label: (context) => {
                                    const label = context.label || '';
                                    const value = this.formatCurrency(context.raw);
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.raw / total) * 100).toFixed(1);
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            }
        );
        // Infrastructure Breakdown Chart
        this.charts.infrastructure = new Chart(
            document.getElementById('infrastructure-breakdown-chart').getContext('2d'),
            {
                type: 'pie',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: this.generateColors(5)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            }
        );
        // Monthly Cost Trend Chart
        this.charts.monthly = new Chart(
            document.getElementById('monthly-cost-chart').getContext('2d'),
            {
                type: 'bar',
                data: {
                    labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                callback: value => this.formatCurrency(value)
                            }
                        }
                    }
                }
            }
        );
        // Entity Cost Chart
        this.charts.entity = new Chart(
            document.getElementById('entity-cost-chart').getContext('2d'),
            {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        data: [],
                        backgroundColor: this.generateColors(2)
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => this.formatCurrency(value)
                            }
                        }
                    }
                }
            }
        );
        // Currency Distribution Chart
        this.charts.currency = new Chart(
            document.getElementById('currency-distribution-chart').getContext('2d'),
            {
                type: 'pie',
                data: {
                    labels: ['USD', 'EUR'],
                    datasets: [{
                        data: [],
                        backgroundColor: ['#3b82f6', '#10b981']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right'
                        }
                    }
                }
            }
        );
    }
    setupEventListeners() {
        // Year filter
        document.getElementById('cost-year-filter').addEventListener('change', (e) => {
            this.currentYear = e.target.value;
            this.updateVisualizations();
        });
        // Currency display
        document.getElementById('cost-currency-display').addEventListener('change', (e) => {
            this.currentCurrency = e.target.value;
            this.updateVisualizations();
        });
        // Table sorting
        document.getElementById('cost-table-sort').addEventListener('change', (e) => {
            this.sortCostTable(e.target.value);
        });
        // Search
        document.getElementById('cost-search').addEventListener('input', (e) => {
            this.filterCostTable(e.target.value);
        });
    }
    updateVisualizations() {
        const costData = this.dataService.getCostsByYear()[this.currentYear];
        if (!costData) return;
        this.updateMetrics(costData);
        this.updateCategoryChart(costData);
        this.updateInfrastructureChart(costData);
        this.updateMonthlyChart(costData);
        this.updateEntityChart(costData);
        this.updateCurrencyChart();
        this.updateCostTable(costData);
    }
    updateMetrics(costData) {
        // Update total annual cost
        document.getElementById('total-annual-cost').textContent = 
            this.formatCurrency(costData.total);
        // Update monthly burn rate
        document.getElementById('monthly-burn-rate').textContent = 
            this.formatCurrency(costData.total / 12);
        // Update infrastructure cost - sum up individual infrastructure items
        const infraItems = costData.byCategory.expenses?.mainCategories?.Infrastructure?.items || [];
        const infraCost = infraItems.reduce((sum, item) => sum + (item.amountUSD || 0), 0);
        document.getElementById('infrastructure-cost').textContent = 
            this.formatCurrency(infraCost);
        // Update corporate cost
        const corpCost = costData.byCategory.corporate?.total || 0;
        document.getElementById('corporate-cost').textContent = 
            this.formatCurrency(corpCost);
    }
    updateCategoryChart(costData) {
        const categories = Object.keys(costData.byCategory);
        const values = categories.map(cat => costData.byCategory[cat].total);
        this.charts.category.data.labels = categories;
        this.charts.category.data.datasets[0].data = values;
        this.charts.category.update();
    }
    updateInfrastructureChart(costData) {
        // Get infrastructure data from expenses category
        const expensesCategory = costData.byCategory.expenses;
        if (!expensesCategory?.mainCategories?.Infrastructure) return;
        const infraData = expensesCategory.mainCategories.Infrastructure;
        const items = infraData.items;
        // Update chart with infrastructure items
        this.charts.infrastructure.data.labels = items.map(item => item.description);
        this.charts.infrastructure.data.datasets[0].data = items.map(item => item.amountUSD);
        this.charts.infrastructure.update();
    }
    updateMonthlyChart(costData) {
        const categories = Object.keys(costData.byCategory);
        const datasets = categories.map((category, index) => ({
            label: category,
            data: Array(12).fill(costData.byCategory[category].total / 12),
            backgroundColor: this.colors[category.toLowerCase()] || this.colors.other
        }));
        this.charts.monthly.data.datasets = datasets;
        this.charts.monthly.update();
    }
    updateEntityChart(costData) {
        const entityData = this.dataService.getCostsByEntity();
        const entities = Object.keys(entityData);
        const values = entities.map(entity => 
            entityData[entity].byYear[this.currentYear]?.total || 0
        );
        this.charts.entity.data.labels = entities;
        this.charts.entity.data.datasets[0].data = values;
        this.charts.entity.update();
    }
    updateCurrencyChart() {
        const currencyData = this.dataService.getCostsByCurrency();
        const values = [
            currencyData.USD?.total || 0,
            currencyData.EUR?.total || 0
        ];
        this.charts.currency.data.datasets[0].data = values;
        this.charts.currency.update();
    }
    updateCostTable(costData) {
        const tbody = document.getElementById('cost-details-table').querySelector('tbody');
        tbody.innerHTML = '';
        Object.entries(costData.byCategory).forEach(([category, data]) => {
            data.items.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${category}</td>
                    <td>${item.mainCategory || '-'}</td>
                    <td>${item.subCategory || '-'}</td>
                    <td>${this.formatCurrency(item.amountUSD)}</td>
                    <td>${item.originalValue || '-'}</td>
                `;
                tbody.appendChild(row);
            });
        });
    }
    sortCostTable(criteria) {
        const tbody = document.getElementById('cost-details-table').querySelector('tbody');
        const rows = Array.from(tbody.querySelectorAll('tr'));
        rows.sort((a, b) => {
            const aValue = a.cells[this.getSortColumnIndex(criteria)].textContent;
            const bValue = b.cells[this.getSortColumnIndex(criteria)].textContent;
            return this.compareValues(aValue, bValue, criteria);
        });
        tbody.innerHTML = '';
        rows.forEach(row => tbody.appendChild(row));
    }
    filterCostTable(searchTerm) {
        const tbody = document.getElementById('cost-details-table').querySelector('tbody');
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(row => {
            const text = Array.from(row.cells).map(cell => cell.textContent).join(' ').toLowerCase();
            row.style.display = text.includes(searchTerm.toLowerCase()) ? '' : 'none';
        });
    }
    getSortColumnIndex(criteria) {
        switch (criteria) {
            case 'category': return 0;
            case 'entity': return 1;
            case 'amount': return 3;
            default: return 0;
        }
    }
    compareValues(a, b, criteria) {
        if (criteria === 'amount') {
            return this.parseAmount(b) - this.parseAmount(a);
        }
        return a.localeCompare(b);
    }
    parseAmount(value) {
        return parseFloat(value.replace(/[^0-9.-]+/g, '')) || 0;
    }
    formatCurrency(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: this.currentCurrency,
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    }
    formatOriginalAmount(amount, currency) {
        if (!currency) return '-';
        // Use European locale for EUR, US locale for USD
        const locale = currency === 'EUR' ? 'de-DE' : 'en-US';
        return new Intl.NumberFormat(locale, {
            style: 'currency',
            currency: currency,
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(amount);
    }
    generateColors(count) {
        const baseColors = [
            '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
            '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#84cc16'
        ];
        return Array(count).fill().map((_, i) => baseColors[i % baseColors.length]);
    }
}
export { CostVisualization };
</file>

<file path="assets/js/treasury-cost-processor.js">
// Cost Data Processor for Treasury Dashboard
class CostProcessor {
    constructor(rawData, fxRates) {
        this.rawData = rawData;
        this.fxRates = fxRates;
        this.processedData = {
            byYear: {},
            byEntity: {},
            byCurrency: {},
            summary: {
                totalUSD: 0,
                totalEUR: 0
            }
        };
    }
    process() {
        // Filter cost-related entries
        const costEntries = this.rawData.filter(entry => 
            entry._section === 'cost' && !entry.key.endsWith('_ignore')
        );
        // Process each entry
        costEntries.forEach(entry => {
            this.processEntry(entry);
        });
        return this.processedData;
    }
    processEntry(entry) {
        const year = entry._year || new Date().getFullYear().toString();
        const amount = this.parseAmount(entry.value);
        const currency = this.detectCurrency(entry.value);
        const amountUSD = currency === 'EUR' ? amount * this.fxRates.EURUSD : amount;
        // Extract categories and entity
        const category = entry._category;
        const mainCategory = entry._path_1;
        const subCategory = entry._path_2;
        const entity = this.getEntityFromPath(entry._path_1);
        // Initialize year if not exists
        if (!this.processedData.byYear[year]) {
            this.processedData.byYear[year] = {
                total: 0,
                byCategory: {},
                items: []
            };
        }
        // Update year data
        this.processedData.byYear[year].total += amountUSD;
        this.updateCategoryBreakdown(
            this.processedData.byYear[year].byCategory, 
            category,
            mainCategory,
            subCategory,
            amountUSD,
            entry,
            amount,
            currency
        );
        this.processedData.byYear[year].items.push({
            category,
            mainCategory,
            subCategory,
            entity,
            amountUSD,
            originalAmount: amount,
            originalValue: entry.value,
            currency,
            description: subCategory || mainCategory
        });
        // Update entity breakdown
        if (entity) {
            this.updateEntityBreakdown(entity, year, amountUSD, {
                category,
                mainCategory,
                subCategory,
                amountUSD,
                originalAmount: amount,
                originalValue: entry.value,
                currency,
                description: subCategory || mainCategory
            });
        }
        // Update currency breakdown
        this.updateCurrencyBreakdown(currency, amountUSD, amount);
        // Update summary
        this.processedData.summary.totalUSD += amountUSD;
        if (currency === 'EUR') {
            this.processedData.summary.totalEUR += amount;
        }
    }
    getEntityFromPath(path) {
        if (!path) return null;
        // Map known entity names
        const entityMap = {
            'Association': 'Association',
            'Just Tech Solutions': 'JTS',
            'Core Team': 'Core'
        };
        return entityMap[path] || null;
    }
    updateCategoryBreakdown(categoryData, category, mainCategory, subCategory, amountUSD, entry, amount, currency) {
        if (!categoryData[category]) {
            categoryData[category] = {
                total: 0,
                subCategories: {},
                mainCategories: {},
                items: []
            };
        }
        categoryData[category].total += amountUSD;
        // Update main category breakdown
        if (mainCategory) {
            if (!categoryData[category].mainCategories[mainCategory]) {
                categoryData[category].mainCategories[mainCategory] = {
                    total: 0,
                    items: []
                };
            }
            categoryData[category].mainCategories[mainCategory].total += amountUSD;
            categoryData[category].mainCategories[mainCategory].items.push({
                description: subCategory,
                amountUSD,
                originalAmount: amount,
                originalValue: entry.value,
                currency,
                details: entry
            });
        }
        // Update sub-category breakdown
        if (subCategory) {
            if (!categoryData[category].subCategories[subCategory]) {
                categoryData[category].subCategories[subCategory] = {
                    total: 0,
                    items: []
                };
            }
            categoryData[category].subCategories[subCategory].total += amountUSD;
            categoryData[category].subCategories[subCategory].items.push({
                mainCategory,
                amountUSD,
                originalAmount: amount,
                originalValue: entry.value,
                currency,
                details: entry
            });
        }
        // Add to items
        categoryData[category].items.push({
            mainCategory,
            subCategory,
            amountUSD,
            originalAmount: amount,
            originalValue: entry.value,
            currency,
            details: entry
        });
    }
    updateEntityBreakdown(entity, year, amountUSD, details) {
        if (!this.processedData.byEntity[entity]) {
            this.processedData.byEntity[entity] = {
                total: 0,
                byYear: {},
                items: []
            };
        }
        this.processedData.byEntity[entity].total += amountUSD;
        if (!this.processedData.byEntity[entity].byYear[year]) {
            this.processedData.byEntity[entity].byYear[year] = {
                total: 0,
                items: []
            };
        }
        this.processedData.byEntity[entity].byYear[year].total += amountUSD;
        this.processedData.byEntity[entity].byYear[year].items.push(details);
        this.processedData.byEntity[entity].items.push(details);
    }
    updateCurrencyBreakdown(currency, amountUSD, originalAmount) {
        if (!this.processedData.byCurrency[currency]) {
            this.processedData.byCurrency[currency] = {
                total: 0,
                totalUSD: 0,
                items: []
            };
        }
        this.processedData.byCurrency[currency].total += originalAmount;
        this.processedData.byCurrency[currency].totalUSD += amountUSD;
    }
    parseAmount(value) {
        if (typeof value !== 'string') return 0;
        // Clean the string - remove currency symbols and spaces
        let numericPart = value.trim().replace(/[€$\s]/g, '');
        // Handle European format:
        // 1. Replace all periods (thousand separators) with nothing
        // 2. Replace comma (decimal separator) with period for JS parsing
        numericPart = numericPart
            .replace(/\./g, '')     // Remove all periods (thousand separators)
            .replace(',', '.');      // Convert comma to period for decimals
        // Parse the numeric value
        const amount = parseFloat(numericPart);
        return isNaN(amount) ? 0 : amount;
    }
    detectCurrency(value) {
        if (typeof value !== 'string') return 'USD';
        const cleanValue = value.trim();
        // Check for EUR symbol or notation
        if (cleanValue.includes('€') || cleanValue.toLowerCase().includes('eur')) {
            return 'EUR';
        }
        // Default to USD
        return 'USD';
    }
}
export { CostProcessor };
</file>

<file path="assets/js/treasury-v2-data.js">
import { CostProcessor } from './treasury-cost-processor.js';
// Treasury Data Service
class TreasuryDataService {
    constructor() {
        this.API_URL = 'https://api.sheetbest.com/sheets/4143ddf3-c90f-4e50-a382-f549be411ac4';
        this.rawData = null;
        this.structuredData = {};
        this.CURRENCY_PATTERNS = {
            EUR: /^€?\s*[\d.,]+\s*€?$/,  // Matches €100, 100€, or 100 with € symbol
            USD: /^\$?\s*[\d.,]+\s*\$?$/, // Matches $100, 100$, or 100 with $ symbol
        };
        this.NUMBER_FORMATS = {
            EUROPEAN: {
                thousandSeparator: '.',
                decimalSeparator: ','
            },
            US: {
                thousandSeparator: ',',
                decimalSeparator: '.'
            }
        };
        this.costProcessor = null;
        this.processedCosts = null;
        this.fxRates = {
            EURUSD: 1.08 // Default rate, should be updated with real data
        };
    }
    // Fetch and process data from the API
    async fetchData() {
        try {
            const response = await fetch(this.API_URL);
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            this.rawData = await response.json();
            this.processData();
            return this.structuredData;
        } catch (error) {
            console.error('Error fetching treasury data:', error);
            throw error;
        }
    }
    // Parse numeric values with format detection
    parseNumericValue(value) {
        if (!value || typeof value !== 'string') return 0;
        // Remove currency symbols and whitespace
        const cleanValue = value.replace(/[$€]/g, '').trim();
        // Detect number format
        const format = this.detectNumberFormat(cleanValue);
        // Convert to a standard format (US)
        let standardized = cleanValue;
        if (format === 'EUROPEAN') {
            standardized = cleanValue
                .replace(/\./g, '')  // Remove thousand separators
                .replace(/,/g, '.'); // Convert decimal separator
        }
        // Parse the standardized number
        const result = parseFloat(standardized);
        return isNaN(result) ? 0 : result;
    }
    // Detect the number format (European vs US)
    detectNumberFormat(value) {
        // If contains comma followed by exactly 2 digits at the end, likely European
        if (/,\d{2}$/.test(value)) return 'EUROPEAN';
        // If contains period followed by exactly 2 digits at the end, likely US
        if (/\.\d{2}$/.test(value)) return 'US';
        // Count separators
        const commas = (value.match(/,/g) || []).length;
        const periods = (value.match(/\./g) || []).length;
        // If more periods than commas, likely European
        if (periods > commas) return 'EUROPEAN';
        // Default to US format
        return 'US';
    }
    // Detect currency from value
    detectCurrency(value) {
        if (!value || typeof value !== 'string') return null;
        // Check for explicit currency symbols
        if (value.includes('€')) return 'EUR';
        if (value.includes('$')) return 'USD';
        // Try pattern matching
        for (const [currency, pattern] of Object.entries(this.CURRENCY_PATTERNS)) {
            if (pattern.test(value)) return currency;
        }
        return null;
    }
    // Format value according to currency
    formatCurrencyValue(value, currency = 'USD') {
        const formatter = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: currency,
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
        return formatter.format(value);
    }
    // Set a value in a nested object structure based on a path array
    setNestedValue(obj, path, value) {
        let current = obj;
        const lastIndex = path.length - 1;
        // Build the nested structure
        for (let i = 0; i < lastIndex; i++) {
            const key = path[i];
            if (!current[key]) {
                current[key] = {};
            }
            current = current[key];
        }
        // Set the final value - handle numeric keys by parsing them
        const finalKey = path[lastIndex];
        const parsedKey = isNaN(finalKey) ? finalKey : parseInt(finalKey);
        current[parsedKey] = value;
    }
    // Process raw data into structured format
    processData() {
        // Reset structured data
        this.structuredData = {};
        // Process each item in the flat list
        this.rawData.forEach(item => {
            const { key, value } = item;
            // Skip any key ending with _ignore
            if (key.endsWith('_ignore')) {
                return;
            }
            const parts = key.split('_');
            const section = parts[0];          // overview, fx, multisig, etc.
            const category = parts[1];         // liquid, debt, provisions, etc.
            const path = parts.slice(2);       // remaining path parts
            const numericValue = this.parseNumericValue(value);
            // Initialize section if it doesn't exist
            if (!this.structuredData[section]) {
                this.structuredData[section] = {};
            }
            // Initialize category if it doesn't exist
            if (!this.structuredData[section][category]) {
                this.structuredData[section][category] = {};
            }
            // For fx rates, store directly under fx section
            if (section === 'fx') {
                this.structuredData.fx[category.toUpperCase()] = numericValue;
            } else {
                // For all other sections, use the nested path
                this.setNestedValue(this.structuredData[section][category], path, numericValue);
            }
        });
        // Process cost data
        const costProcessor = new CostProcessor(this.rawData, this.fxRates);
        this.processedCosts = costProcessor.process();
        this.calculateDerivedMetrics();
    }
    // Calculate additional metrics
    calculateDerivedMetrics() {
        const overview = this.structuredData.overview;
        // Calculate total assets
        const totalAssets = (overview.liquid?.total || 0) + (overview.illiquid?.total || 0);
        // Calculate net position
        const netPosition = totalAssets - 
            (overview.debt?.total || 0) - 
            (overview.provisions?.total || 0);
        // Calculate liquidity ratio
        const liquidityRatio = (overview.liquid?.total || 0) / 
            ((overview.debt?.total || 0) + (overview.provisions?.total || 0));
        // Add derived metrics to the structure
        overview.total_assets = totalAssets;
        overview.net_position = netPosition;
        overview.liquidity_ratio = liquidityRatio;
    }
    // Get dashboard metrics
    getDashboardMetrics() {
        const overview = this.structuredData.overview;
        return {
            totalBalance: overview.true?.balance || 0,
            effectiveBudget: overview.effective?.budget || 0,
            liquidAssets: overview.liquid?.total || 0,
            illiquidAssets: overview.illiquid?.total || 0,
            totalDebt: overview.debt?.total || 0,
            totalProvisions: overview.provisions?.total || 0,
            netPosition: overview.net_position || 0,
            liquidityRatio: overview.liquidity_ratio || 0
        };
    }
    // Get asset breakdown
    getAssetBreakdown() {
        const overview = this.structuredData.overview;
        return {
            liquid: {
                cash: overview.liquid?.cash || 0,
                receivables: {
                    '2024': overview.liquid?.outstanding?.receivables?.[2024] || 0,
                    '2025': overview.liquid?.outstanding?.receivables?.[2025] || 0
                }
            },
            illiquid: {
                cg_token: {
                    amount: overview.illiquid?.cg_token || 0,
                    price: overview.cg_token_price || 0
                }
            }
        };
    }
    // Get liability breakdown
    getLiabilityBreakdown() {
        const overview = this.structuredData.overview;
        return {
            debt: {
                jts: overview.debt?.jts?.unpaid || 0,
                flo: {
                    expenses: overview.debt?.flo?.expenses?.unpaid || 0,
                    salaries: overview.debt?.flo?.salaries?.unpaid || 0
                },
                jan: {
                    salaries: overview.debt?.jan?.salaries?.unpaid || 0
                }
            },
            provisions: {
                vat: overview.provisions?.vat?.token_sale || 0,
                overhead: overview.provisions?.association?.overhead || 0,
                payables_2025: overview.provisions?.outstanding?.payables?.[2025] || 0,
                infra_2025: overview.provisions?.infra?.[2025] || 0,
                corporate_2025: overview.provisions?.corporate?.[2025] || 0
            }
        };
    }
    // Get FX rates
    getFXRates() {
        return { ...this.structuredData.fx };
    }
    // Get cost metrics
    getCostMetrics() {
        if (!this.costProcessor) return null;
        return this.costProcessor.getSummaryMetrics();
    }
    // Get cost breakdown by category
    getCostsByCategory() {
        if (!this.costProcessor) return null;
        return this.costProcessor.getCategoryBreakdown();
    }
    // Get cost breakdown by year
    getCostsByYear() {
        return this.processedCosts?.byYear || {};
    }
    // Get cost breakdown by entity
    getCostsByEntity() {
        return this.processedCosts?.byEntity || {};
    }
    // Get cost breakdown by currency
    getCostsByCurrency() {
        return this.processedCosts?.byCurrency || {};
    }
    getCostSummary() {
        return this.processedCosts?.summary || {
            totalUSD: 0,
            totalEUR: 0
        };
    }
}
// Export as singleton
const treasuryDataService = new TreasuryDataService();
export { treasuryDataService };
</file>

<file path="assets/js/treasury-v2.js">
import { treasuryDataService } from '/assets/js/treasury-v2-data.js';
import { CostVisualization } from '/assets/js/treasury-cost-charts.js';
// Treasury Dashboard V2
class TreasuryDashboard {
    constructor() {
        this.charts = {};
        this.data = {
            metrics: null,
            assets: null,
            liabilities: null,
            fxRates: null,
            structuredData: null
        };
        this.costViz = null;
        this.init();
    }
    async init() {
        try {
            await this.loadData();
            this.initializeCharts();
            this.setupEventListeners();
            this.render();
            // Initialize cost visualizations
            this.costViz = new CostVisualization(treasuryDataService);
            this.costViz.initialize();
            // Setup auto-refresh every 5 minutes
            setInterval(() => this.refreshData(), 5 * 60 * 1000);
        } catch (error) {
            console.error('Failed to initialize dashboard:', error);
            this.handleError(error);
        }
    }
    async loadData() {
        let isDataValid = false;
        try {
            // Show loading state
            this.setLoadingState(true);
            // Try up to 3 times with exponential backoff
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    await treasuryDataService.fetchData();
                    break;
                } catch (error) {
                    if (attempt === 3) throw error;
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt - 1) * 1000));
                }
            }
            // Get structured data from service
            this.data.metrics = treasuryDataService.getDashboardMetrics();
            // If total liquid is 0 or null, keep the loading state and retry
            if (this.data.metrics.liquidAssets === 0) {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    return this.loadData();
            }
            // Mark data as valid and load the remaining data
            isDataValid = true;
            this.data.assets = treasuryDataService.getAssetBreakdown();
            this.data.liabilities = treasuryDataService.getLiabilityBreakdown();
            this.data.fxRates = treasuryDataService.getFXRates();
            this.data.structuredData = treasuryDataService.structuredData;
            // Calculate changes
            this.calculateChanges();
        } catch (error) {
            console.error('Error loading data:', error);
            this.handleError(new Error('Failed to load treasury data. Please check your connection and try again.'));
        } finally {
            // Only remove loading state if valid data has been loaded
            if (isDataValid) {
                this.setLoadingState(false);
            }
        }
    }
    setLoadingState(isLoading) {
        const dashboard = document.querySelector('.dashboard-container');
        if (!dashboard) return;
        // Ensure the dashboard container is positioned relative so the absolute overlay is correctly positioned
        dashboard.style.position = 'relative';
        if (isLoading) {
            let overlay = document.getElementById('dashboard-loading-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'dashboard-loading-overlay';
                overlay.innerHTML = `
                    <div class="spinner"></div>
                    <h2>Loading Treasury Data</h2>
                    <p>Please hold on while we gather the latest financial insights...</p>
                `;
                dashboard.appendChild(overlay);
            }
            // Style the overlay to cover the dashboard container with a smart white gradient
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'flex-start';
            overlay.style.paddingTop = '20px';
            overlay.style.background = 'linear-gradient(135deg, #ffffff, #f0f0f0)';
            overlay.style.backdropFilter = 'blur(8px)';
            overlay.style.boxShadow = 'inset 0 0 30px rgba(0, 0, 0, 0.1)';
            overlay.style.zIndex = '1000';
            overlay.style.opacity = '1';
            overlay.style.transition = 'opacity 0.3s ease-in-out';
        } else {
            const overlay = document.getElementById('dashboard-loading-overlay');
            if (overlay) {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.remove(), 300);
            }
        }
    }
    async refreshData() {
        // Clear existing refresh timer if it exists
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
        }
        await this.loadData();
        this.render();
        // Update cost visualizations
        if (this.costViz) {
            this.costViz.updateVisualizations();
        }
        // Setup new refresh timer
        this.refreshTimer = setInterval(() => this.refreshData(), 5 * 60 * 1000);
    }
    calculateChanges() {
        // Placeholder for calculating metric changes
        // This will be implemented when we have historical data
        this.data.changes = {
            totalBalance: 0,
            liquidAssets: 0,
            illiquidAssets: 0,
            assetCount: 0
        };
    }
    initializeCharts() {
        try {
            if (typeof Chart === 'undefined') {
                throw new Error('Chart.js is not loaded');
            }
            // Cleanup existing charts
            Object.values(this.charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            this.charts = {};
            // Initialize new charts
            this.initializeLiquidPortfolioChart();
            this.initializeIlliquidPortfolioChart();
            this.initializeTokenDistributionChart();
            this.initializeTreasuryComponentsChart();
        } catch (error) {
            console.error('Failed to initialize charts:', error);
            this.handleError(error);
        }
    }
    initializeLiquidPortfolioChart() {
        const ctx = document.getElementById('liquid-portfolio-chart')?.getContext('2d');
        if (!ctx) {
            console.warn('Liquid portfolio chart canvas not found');
            return;
        }
        this.charts.liquidPortfolio = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    backgroundColor: []
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.label || '';
                                const value = this.formatCurrency(context.raw);
                                const percentage = ((context.raw / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }
    initializeIlliquidPortfolioChart() {
        const ctx = document.getElementById('illiquid-portfolio-chart')?.getContext('2d');
        if (!ctx) {
            console.warn('Illiquid portfolio chart canvas not found');
            return;
        }
        this.charts.illiquidPortfolio = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    backgroundColor: []
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.label || '';
                                const value = this.formatCurrency(context.raw);
                                const percentage = ((context.raw / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }
    initializeTokenDistributionChart() {
        const ctx = document.getElementById('token-distribution-chart')?.getContext('2d');
        if (!ctx) {
            console.warn('Token distribution chart canvas not found');
            return;
        }
        this.charts.tokenDist = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        stacked: true
                    },
                    y: {
                        stacked: true,
                        beginAtZero: true,
                        ticks: {
                            callback: value => this.formatCurrency(value)
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                return `${context.dataset.label}: ${this.formatCurrency(context.raw)}`;
                            }
                        }
                    }
                }
            }
        });
    }
    initializeTreasuryComponentsChart() {
        const ctx = document.getElementById('treasury-components-chart')?.getContext('2d');
        if (!ctx) {
            console.warn('Treasury components chart canvas not found');
            return;
        }
        this.charts.components = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{
                    data: [],
                    backgroundColor: []
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right'
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.label || '';
                                const value = this.formatCurrency(context.raw);
                                const percentage = ((context.raw / context.dataset.data.reduce((a, b) => a + b, 0)) * 100).toFixed(1);
                                return `${label}: ${value} (${percentage}%)`;
                            }
                        }
                    }
                }
            }
        });
    }
    setupEventListeners() {
        // Asset sorting
        document.getElementById('liquid-asset-sort').addEventListener('change', (e) => {
            this.sortAssets('liquid', e.target.value);
        });
        document.getElementById('illiquid-asset-sort').addEventListener('change', (e) => {
            this.sortAssets('illiquid', e.target.value);
        });
    }
    sortAssets(type, criteria) {
        const assets = type === 'liquid' ? this.getLiquidAssets() : this.getIlliquidAssets();
        switch (criteria) {
            case 'value':
                assets.sort((a, b) => b.value - a.value);
                break;
            case 'name':
                assets.sort((a, b) => a.name.localeCompare(b.name));
                break;
        }
        this.renderAssetList(type, assets);
    }
    getLiquidAssets() {
        const overview = this.data.structuredData?.overview;
        const multisig = this.data.structuredData?.multisig;
        if (!overview?.liquid || !multisig) return [];
        const assets = [];
        const tokenTotals = {};
        // Calculate token totals across all multisig wallets
        Object.values(multisig).forEach(wallet => {
            Object.entries(wallet).forEach(([token, amount]) => {
                if (token !== 'total') {
                    const upperToken = token.toUpperCase();
                    const fxRate = this.data.structuredData.fx[upperToken] || 1;
                    const valueUSD = amount * fxRate;
                    if (!tokenTotals[upperToken]) {
                        tokenTotals[upperToken] = {
                            amount: 0,
                            valueUSD: 0
                        };
                    }
                    tokenTotals[upperToken].amount += amount;
                    tokenTotals[upperToken].valueUSD += valueUSD;
                }
            });
        });
        // Add token assets
        Object.entries(tokenTotals).forEach(([token, data]) => {
            assets.push({
                name: token,
                amount: data.amount,
                symbol: token,
                value: data.valueUSD,
                change: 0
            });
        });
        // Add receivables (combined)
        if (overview.liquid.outstanding?.receivables) {
            const totalReceivables = Object.values(overview.liquid.outstanding.receivables).reduce((sum, amount) => sum + amount, 0);
            assets.push({
                name: 'Receivables',
                amount: totalReceivables,
                symbol: 'USD',
                value: totalReceivables,
                change: 0
            });
        }
        return assets;
    }
    getIlliquidAssets() {
        const overview = this.data.structuredData?.overview;
        if (!overview?.illiquid) return [];
        const assets = [];
        // Add CG Token
        if (overview.illiquid?.cg?.token) {
            const cgTokenAmount = overview.illiquid.cg.token;
            assets.push({
                name: 'CG Token',
                amount: cgTokenAmount,
                symbol: 'CG',
                value: overview.illiquid.total || 0,
                change: 0
            });
        }
        return assets;
    }
    viewAllTransactions() {
        // Placeholder for view all transactions functionality
    }
    updateMetrics() {
        if (!this.data.metrics) return;
        // Update total balance
        document.getElementById('total-balance-value').textContent = 
            this.formatCurrency(this.data.metrics.totalBalance);
        document.getElementById('total-balance-change').textContent = 
            this.formatPercentage(this.data.changes.totalBalance);
        // Update inflow/outflow (to be implemented)
        document.getElementById('total-inflow-value').textContent = 
            this.formatCurrency(0);
        document.getElementById('total-outflow-value').textContent = 
            this.formatCurrency(0);
        // Update asset count
        const assetCount = Object.keys(this.data.assets.liquid).length + 
                          Object.keys(this.data.assets.illiquid).length;
        document.getElementById('asset-count-value').textContent = assetCount;
    }
    getAssetItems() {
        const assetItems = [];
        const overview = this.data.structuredData?.overview;
        if (!overview) return assetItems;
        // Add liquid assets
        if (overview.liquid) {
            // Add cash
            if (overview.liquid.cash) {
                assetItems.push({
                    name: 'Cash',
                    amount: overview.liquid.cash,
                    symbol: 'USD',
                    value: overview.liquid.cash,
                    change: 0
                });
            }
            // Add receivables (combined)
            if (overview.liquid.outstanding?.receivables) {
                const totalReceivables = Object.values(overview.liquid.outstanding.receivables).reduce((sum, amount) => sum + amount, 0);
                assetItems.push({
                    name: 'Receivables',
                    amount: totalReceivables,
                    symbol: 'USD',
                    value: totalReceivables,
                    change: 0
                });
            }
        }
        // Add illiquid assets
        if (overview.illiquid?.cg?.token) {
            const cgTokenAmount = overview.illiquid.cg.token;
            assetItems.push({
                name: 'CG Token',
                amount: cgTokenAmount,
                symbol: 'CG',
                value: overview.illiquid.total || 0,  // Use the pre-calculated USD total
                change: 0
            });
        }
        return assetItems;
    }
    formatAssetName(name) {
        return name
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
    }
    formatPercentage(value) {
        const sign = value >= 0 ? '+' : '';
        return `${sign}${value.toFixed(2)}%`;
    }
    renderAssetList(type, assets) {
        const listId = type === 'liquid' ? 'liquid-asset-list' : 'illiquid-asset-list';
        const assetList = document.getElementById(listId);
        assetList.innerHTML = '';
        assets.forEach(asset => {
            const assetElement = document.createElement('div');
            assetElement.className = 'asset-item';
            assetElement.innerHTML = `
                <div class="asset-info">
                    <div class="asset-icon"></div>
                    <div>
                        <div class="asset-name">${asset.name}</div>
                        <div class="asset-amount">${asset.amount} ${asset.symbol}</div>
                    </div>
                </div>
                <div class="asset-value">
                    <div class="asset-price">${this.formatCurrency(asset.value)}</div>
                    <div class="asset-change ${asset.change >= 0 ? 'positive' : 'negative'}">
                        ${asset.change >= 0 ? '+' : ''}${asset.change}%
                    </div>
                </div>
            `;
            assetList.appendChild(assetElement);
        });
    }
    updateCharts() {
        this.updateLiquidPortfolioChart();
        this.updateIlliquidPortfolioChart();
        this.updateTokenDistributionChart();
        this.updateTreasuryComponentsChart();
    }
    updateLiquidPortfolioChart() {
        const liquidAssets = this.getLiquidAssets();
        if (liquidAssets.length > 0) {
            this.charts.liquidPortfolio.data.labels = liquidAssets.map(a => a.name);
            this.charts.liquidPortfolio.data.datasets[0].data = liquidAssets.map(a => a.value);
            this.charts.liquidPortfolio.data.datasets[0].backgroundColor = this.generateChartColors(liquidAssets.length);
            this.charts.liquidPortfolio.update();
        }
    }
    updateIlliquidPortfolioChart() {
        const illiquidAssets = this.getIlliquidAssets();
        if (illiquidAssets.length > 0) {
            this.charts.illiquidPortfolio.data.labels = illiquidAssets.map(a => a.name);
            this.charts.illiquidPortfolio.data.datasets[0].data = illiquidAssets.map(a => a.value);
            this.charts.illiquidPortfolio.data.datasets[0].backgroundColor = this.generateChartColors(illiquidAssets.length);
            this.charts.illiquidPortfolio.update();
        }
    }
    updateTokenDistributionChart() {
        const multisig = this.data.structuredData?.multisig;
        if (!multisig) return;
        // Get all unique tokens across all wallets
        const allTokens = new Set();
        Object.values(multisig).forEach(wallet => {
            Object.keys(wallet).forEach(token => {
                if (token !== 'total') allTokens.add(token.toUpperCase());
            });
        });
        // Prepare datasets
        const labels = Object.keys(multisig);
        const datasets = Array.from(allTokens).map(token => ({
            label: token,
            data: labels.map(wallet => {
                const amount = multisig[wallet][token.toLowerCase()] || 0;
                const fxRate = this.data.structuredData.fx[token] || 1;
                return amount * fxRate;
            }),
            backgroundColor: this.getTokenColor(token)
        }));
        this.charts.tokenDist.data.labels = labels.map(this.formatWalletName);
        this.charts.tokenDist.data.datasets = datasets;
        this.charts.tokenDist.update();
    }
    updateTreasuryComponentsChart() {
        const overview = this.data.structuredData?.overview;
        if (!overview) return;
        const components = [
            { label: 'Liquid Assets', value: overview.liquid?.total || 0 },
            { label: 'Illiquid Assets', value: overview.illiquid?.total || 0 },
            { label: 'Provisions', value: overview.provisions?.total || 0 }
        ];
        this.charts.components.data.labels = components.map(c => c.label);
        this.charts.components.data.datasets[0].data = components.map(c => c.value);
        this.charts.components.data.datasets[0].backgroundColor = this.generateChartColors(components.length);
        this.charts.components.update();
    }
    generateChartColors(count) {
        const colors = [
            '#3b82f6', // blue
            '#10b981', // green
            '#f59e0b', // yellow
            '#ef4444', // red
            '#8b5cf6', // purple
            '#ec4899', // pink
            '#14b8a6', // teal
            '#f97316', // orange
            '#6366f1', // indigo
            '#84cc16'  // lime
        ];
        // If we need more colors than we have, repeat the array
        return Array(count).fill().map((_, i) => colors[i % colors.length]);
    }
    render() {
        this.renderDashboardMetrics();
        this.renderAssetList('liquid', this.getLiquidAssets());
        this.renderAssetList('illiquid', this.getIlliquidAssets());
        this.renderMultisigWallets();
        this.updateCharts();
    }
    formatCurrency(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    }
    formatTime(timestamp) {
        if (!timestamp) return '';
        return new Intl.RelativeTimeFormat('en', { numeric: 'auto' })
            .format(-Math.round((Date.now() - timestamp) / 1000 / 60), 'minute');
    }
    handleError(error) {
        console.error('Treasury Dashboard Error:', error);
        // Display error message to user
        const metricsDiv = document.getElementById('dashboard-metrics');
        if (metricsDiv) {
            metricsDiv.innerHTML = `
                <div class="error-message">
                    <h3>Error Loading Dashboard Data</h3>
                    <p>${error.message}</p>
                    <button onclick="window.location.reload()">Retry</button>
                </div>
            `;
        }
    }
    // Render dashboard metrics
    renderDashboardMetrics() {
        const metrics = this.data.metrics;
        const metricsContainer = document.getElementById('dashboard-metrics');
        const metricCards = [
            {
                title: 'Total Liquid',
                value: this.formatCurrency(metrics.liquidAssets),
                icon: 'bi-cash-coin',
                trend: null
            },
            {
                title: 'Total Illiquid',
                value: this.formatCurrency(metrics.illiquidAssets),
                icon: 'bi-bank',
                trend: null
            },
            {
                title: 'Unallocated Budget',
                value: this.formatCurrency(metrics.effectiveBudget),
                icon: 'bi-wallet2',
                trend: null
            },
            {
                title: 'Total Provisions',
                value: this.formatCurrency(metrics.totalProvisions),
                icon: 'bi-piggy-bank',
                trend: null
            }
        ];
        metricsContainer.innerHTML = metricCards.map(metric => `
            <div class="metric-card">
                <h3>${metric.title}</h3>
                <div class="metric-value">${metric.value}</div>
                ${metric.trend ? `<div class="metric-change">${metric.trend.value}</div>` : ''}
            </div>
        `).join('');
    }
    renderMultisigWallets() {
        const multisig = this.data.structuredData?.multisig;
        const walletsContainer = document.getElementById('multisig-wallets');
        if (!multisig) return;
        const walletCards = Object.entries(multisig).map(([name, data]) => {
            const tokens = Object.entries(data)
                .filter(([key]) => key !== 'total')
                .map(([token, amount]) => {
                    const upperToken = token.toUpperCase();
                    const fxRate = this.data.structuredData.fx[upperToken] || 1;
                    return {
                        token: upperToken,
                        amount,
                        valueUSD: amount * fxRate
                    };
                });
            return `
                <div class="multisig-wallet">
                    <div class="multisig-wallet-header">
                        <div class="multisig-wallet-name">${this.formatWalletName(name)}</div>
                        <div class="multisig-wallet-total">${this.formatCurrency(data.total || 0)}</div>
                    </div>
                    <div class="token-list">
                        ${tokens.map(t => `
                            <div class="token-item">
                                <span class="token-name">${t.token}</span>
                                <span class="token-amount">${t.amount.toFixed(2)} (${this.formatCurrency(t.valueUSD)})</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        });
        walletsContainer.innerHTML = walletCards.join('');
    }
    formatWalletName(name) {
        return name.split('-').map(word => 
            word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
    }
    getTokenColor(token) {
        const colors = {
            'ETH': '#8247E5',    // Ethereum purple
            'USDC': '#2775CA',   // USDC blue
            'USDT': '#26A17B',   // Tether green
            'EURE': '#F0B90B',   // Euro gold/yellow
            'default': '#CBD5E1'  // Default gray
        };
        return colors[token.toUpperCase()] || colors.default;
    }
}
// Initialize dashboard when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.treasuryDashboard = new TreasuryDashboard();
});
</file>

<file path="assets/js/treasury.charts.js">
(function() {
  // Chart instances
  let incomingTokenChart = null;
  let outgoingTokenChart = null;
  let volumeChart = null;
  // Token chart creation
  function createTokenCharts() {
    const colors = [
      '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
      '#FF9F40', '#FF6384', '#C9CBCF'
    ];
    const incomingTokens = processTokenVolumes(window.treasury.incomingTx);
    const outgoingTokens = processTokenVolumes(window.treasury.outgoingTx);
    // Create or update charts
    updateTokenChart('incomingTokenChart', incomingTokens, colors);
    updateTokenChart('outgoingTokenChart', outgoingTokens, colors);
    createCombinedLegend(incomingTokens, outgoingTokens, colors);
  }
  function updateTokenChart(canvasId, tokens, colors) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const chart = canvasId === 'incomingTokenChart' ? incomingTokenChart : outgoingTokenChart;
    // Destroy existing chart
    if (chart) {
      chart.destroy();
    }
    // Default chart configuration
    const config = {
      type: 'doughnut',
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 1,
        plugins: {
          legend: { display: false }
        }
      }
    };
    // Handle empty data case
    if (!tokens || tokens.length === 0) {
      config.data = {
        labels: ['No Data'],
        datasets: [{
          data: [1],
          backgroundColor: ['#f5f5f5'],
          borderWidth: 0
        }]
      };
    } else {
      config.data = {
        labels: tokens.map(([token]) => token),
        datasets: [{
          data: tokens.map(([,value]) => value),
          backgroundColor: colors.slice(0, tokens.length),
          borderWidth: 1
        }]
      };
    }
    // Create new chart
    const newChart = new Chart(ctx, config);
    // Store reference
    if (canvasId === 'incomingTokenChart') {
      incomingTokenChart = newChart;
    } else {
      outgoingTokenChart = newChart;
    }
  }
  function processTokenVolumes(transactions) {
    const tokenVolumes = transactions.reduce((acc, tx) => {
      const token = tx.token;
      acc[token] = (acc[token] || 0) + window.treasury.parseUSDValue(tx.valueUSD);
      return acc;
    }, {});
    const sortedTokens = Object.entries(tokenVolumes)
      .sort(([,a], [,b]) => b - a)
      .filter(([,value]) => value > 0);
    const OTHERS_THRESHOLD = 0.02;
    const totalVolume = sortedTokens.reduce((sum, [,value]) => sum + value, 0);
    let chartTokens = [];
    let othersValue = 0;
    sortedTokens.forEach(([token, value]) => {
      if (value / totalVolume < OTHERS_THRESHOLD) {
        othersValue += value;
      } else {
        chartTokens.push([token, value]);
      }
    });
    if (othersValue > 0) {
      chartTokens.push(['Others', othersValue]);
    }
    return chartTokens;
  }
  function createCombinedLegend(incomingTokens, outgoingTokens, colors) {
    // Combine and deduplicate tokens
    const allTokens = new Set([
      ...incomingTokens.map(([token]) => token),
      ...outgoingTokens.map(([token]) => token)
    ]);
    const legend = document.getElementById('token-legend');
    if (allTokens.size === 0) {
      legend.innerHTML = '<div class="token-legend-item">No token transactions</div>';
      return;
    }
    legend.innerHTML = Array.from(allTokens).map((token, index) => {
      const incomingValue = incomingTokens.find(([t]) => t === token)?.[1] || 0;
      const outgoingValue = outgoingTokens.find(([t]) => t === token)?.[1] || 0;
      return `
        <div class="token-legend-item">
          <div class="token-legend-color" style="background: ${colors[index]}"></div>
          <span class="token-legend-label">${token}</span>
          <div class="token-legend-values">
            <span class="incoming">+$${incomingValue.toLocaleString('en-US', { maximumFractionDigits: 2 })}</span>
            <span class="outgoing">-$${outgoingValue.toLocaleString('en-US', { maximumFractionDigits: 2 })}</span>
          </div>
        </div>
      `;
    }).join('');
  }
  function createVolumeChart() {
    const canvas = document.getElementById('volumeChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (volumeChart) {
      volumeChart.destroy();
    }
    const chartData = prepareChartData();
    volumeChart = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: chartData.labels,
        datasets: [
          {
            label: 'Incoming',
            data: chartData.incoming,
            backgroundColor: 'rgba(46, 204, 113, 0.2)',
            borderColor: 'rgba(46, 204, 113, 1)',
            borderWidth: 1
          },
          {
            label: 'Outgoing',
            data: chartData.outgoing,
            backgroundColor: 'rgba(231, 76, 60, 0.2)',
            borderColor: 'rgba(231, 76, 60, 1)',
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 2,
        plugins: {
          tooltip: {
            callbacks: {
              label: context => {
                const label = context.dataset.label;
                const value = context.raw;
                return `${label}: $${value.toLocaleString()}`;
              }
            }
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: value => '$' + value.toLocaleString()
            }
          }
        }
      }
    });
  }
  function prepareChartData() {
    const monthlyVolumes = {};
    window.treasury.transactions.forEach(tx => {
      const date = new Date(tx.date);
      const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
      if (!monthlyVolumes[monthKey]) {
        monthlyVolumes[monthKey] = { incoming: 0, outgoing: 0 };
      }
      const value = window.treasury.parseUSDValue(tx.valueUSD);
      if (window.treasury.incomingTx.includes(tx)) {
        monthlyVolumes[monthKey].incoming += value;
      } else {
        monthlyVolumes[monthKey].outgoing += value;
      }
    });
    const sortedMonths = Object.keys(monthlyVolumes).sort();
    return {
      labels: sortedMonths.map(month => {
        const [year, monthNum] = month.split('-');
        return `${monthNum}/${year}`;
      }),
      incoming: sortedMonths.map(month => monthlyVolumes[month].incoming),
      outgoing: sortedMonths.map(month => monthlyVolumes[month].outgoing)
    };
  }
  // Make functions globally available
  window.treasuryCharts = {
    createTokenCharts,
    createVolumeChart
  };
})();
</file>

<file path="assets/js/treasury.js">
(function() {
  // Load and parse transaction data
  let ms2, ms3, ms4, ms5;
  try {
    const multisig2Data = window.MULTISIG2_DATA;
    const multisig3Data = window.MULTISIG3_DATA;
    const multisig4Data = window.MULTISIG4_DATA;
    const multisig5Data = window.MULTISIG5_DATA;
    ms2 = JSON.parse(multisig2Data);
    ms3 = JSON.parse(multisig3Data);
    ms4 = JSON.parse(multisig4Data);
    ms5 = JSON.parse(multisig5Data);
  } catch (e) {
    console.error('Failed to parse multisig data:', e);
    ms2 = [];
    ms3 = [];
    ms4 = [];
    ms5 = [];
  }
  const multisig1Data = window.MULTISIG1_DATA;
  // Make these globally available for other scripts
  window.treasury = {
    incomingTx: [],
    outgoingTx: [],
    transactions: [],
    parseUSDValue: function(valueStr) {
      if (!valueStr) return 0;
      return parseFloat(valueStr.replace('$', '').replace(/,/g, '')) || 0;
    }
  };
  // Helper functions
  function parseUSDValue(valueStr) {
    return window.treasury.parseUSDValue(valueStr);
  }
  function parseAmount(amountStr, type = '') {
    if (!amountStr) return { amount: 0, token: type || 'ETH' };
    // Handle different amount formats
    const cleanStr = amountStr.trim();
    // Format: "X.XX TOKEN" (e.g., "0.15 ETH")
    if (cleanStr.includes(' ')) {
      const [amount, token] = cleanStr.split(' ');
      return {
        amount: parseFloat(amount) || 0,
        token: token || type || 'ETH'
      };
    }
    // Format: Just the number with separate token field
    return {
      amount: parseFloat(cleanStr) || 0,
      token: type || 'ETH'
    };
  }
  function isValidTransaction(tx) {
    return tx.amount !== 0 || parseUSDValue(tx.valueUSD) !== 0;
  }
  function isIncomingTransaction(address, tx) {
    return tx.to.toLowerCase() === address.toLowerCase();
  }
  // Multisig addresses
  const MULTISIG_ADDRESSES = {
    multisig1: '0x582e8f63fc69d396395f61191ce1f7870f7289d6',
    multisig2: '0x04a11D3453Ef2E7174a95a07FCae749A182a3F07',
    multisig3: '0x7882bfa84C4Bee72649A0cadf730318A85f3fe56',
    multisig4: '0xb548C27DE463D5AC53056041D664d58b6A8341AD',
    multisig5: '0x2BCb4cE16A0E95CD2006b3eb602BD8C9E698f64B'
  };
  // Process transactions function
  function processTransactions() {
    // Clear existing transactions
    window.treasury.incomingTx.length = 0;
    window.treasury.outgoingTx.length = 0;
    // Helper function to normalize transaction data
    function normalizeTransaction(row, multisigKey, txType = 'ETH') {
      if (!row || typeof row !== 'object') return null;
      // Parse amount and determine token type
      const amountInfo = parseAmount(row["Amount"], row["Token"]);
      // For ETH transactions, if amount contains "ETH", override txType
      if (row["Amount"] && row["Amount"].includes('ETH')) {
        txType = 'ETH';
      }
      // Use explicit token type if provided
      if (row["Token"]) {
        txType = row["Token"].split('(')[0].trim();
      }
      return {
        date: row["DateTime (UTC)"],
        from: row["From"],
        to: row["To"],
        amount: amountInfo.amount,
        token: txType,
        valueUSD: row["Value (USD)"],
        multisig: multisigKey,
        hash: row["Transaction Hash"] || row["Parent Transaction Hash"]
      };
    }
    // Helper function to process a single multisig's transactions
    function processMultisigTransactions(data, multisigKey, startIndex = 1) {
      if (!data || !Array.isArray(data) || data.length <= startIndex) return;
      for (let i = startIndex; i < data.length; i++) {
        const tx = normalizeTransaction(data[i], multisigKey);
        if (!tx || !isValidTransaction(tx)) continue;
        if (isIncomingTransaction(MULTISIG_ADDRESSES[multisigKey], tx)) {
          window.treasury.incomingTx.push(tx);
        } else {
          window.treasury.outgoingTx.push(tx);
        }
      }
    }
    // Process multisig2-5 transactions
    processMultisigTransactions(ms2, 'multisig2');
    processMultisigTransactions(ms3, 'multisig3');
    processMultisigTransactions(ms4, 'multisig4');
    processMultisigTransactions(ms5, 'multisig5');
    // Process multisig1 transactions with different file types
    Object.entries(multisig1Data).forEach(([filename, data]) => {
      if (!data || !Array.isArray(data) || data.length < 2) return;
      let txType = 'ETH';
      if (filename.includes('tokentxns')) {
        txType = 'token';
      } else if (filename.includes('internal-tx')) {
        txType = 'Internal';
      }
      data.slice(1).forEach(row => {
        const tx = normalizeTransaction(row, 'multisig1', txType);
        if (!tx || !isValidTransaction(tx)) return;
        if (isIncomingTransaction(MULTISIG_ADDRESSES.multisig1, tx)) {
          window.treasury.incomingTx.push(tx);
        } else {
          window.treasury.outgoingTx.push(tx);
        }
      });
    });
    // Sort transactions by date
    window.treasury.incomingTx.sort((a, b) => new Date(b.date) - new Date(a.date));
    window.treasury.outgoingTx.sort((a, b) => new Date(b.date) - new Date(a.date));
    window.treasury.transactions = [...window.treasury.incomingTx, ...window.treasury.outgoingTx]
      .sort((a, b) => new Date(b.date) - new Date(a.date));
    return window.treasury.transactions;
  }
  // Calculate and display metrics
  function calculateMetrics() {
    const incomingVolume = window.treasury.incomingTx.reduce((sum, tx) => sum + parseUSDValue(tx.valueUSD), 0);
    const outgoingVolume = window.treasury.outgoingTx.reduce((sum, tx) => sum + parseUSDValue(tx.valueUSD), 0);
    const netPosition = incomingVolume - outgoingVolume;
    document.getElementById('incoming-volume-value').textContent = 
      `$${incomingVolume.toLocaleString('en-US', { maximumFractionDigits: 2 })}`;
    document.getElementById('outgoing-volume-value').textContent = 
      `$${outgoingVolume.toLocaleString('en-US', { maximumFractionDigits: 2 })}`;
    const netPositionElement = document.getElementById('net-position-value');
    netPositionElement.textContent = 
      `$${Math.abs(netPosition).toLocaleString('en-US', { maximumFractionDigits: 2 })}`;
    netPositionElement.classList.add(netPosition >= 0 ? 'positive' : 'negative');
    if (netPosition < 0) netPositionElement.textContent = '-' + netPositionElement.textContent;
    document.getElementById('transaction-count-value').textContent = window.treasury.transactions.length;
    document.getElementById('incoming-count').textContent = window.treasury.incomingTx.length;
    document.getElementById('outgoing-count').textContent = window.treasury.outgoingTx.length;
    // Create token charts
    window.treasuryCharts.createTokenCharts();
  }
  // Render transactions for current page
  function renderTransactions(transactions, currentPage, itemsPerPage) {
    const start = (currentPage - 1) * itemsPerPage;
    const end = start + itemsPerPage;
    const tbody = document.getElementById('transactions-body');
    tbody.innerHTML = '';
    transactions.slice(start, end).forEach(tx => {
      const row = document.createElement('tr');
      const isIncoming = window.treasury.incomingTx.includes(tx);
      const txKey = `${tx.token}-${Math.floor(new Date(tx.date).getTime() / 1000)}`;
      row.innerHTML = `
        <td>${new Date(tx.date).toLocaleDateString()}</td>
        <td>${tx.token}</td>
        <td title="${tx.from}">${tx.from.slice(0, 8)}...</td>
        <td title="${tx.to}">${tx.to.slice(0, 8)}...</td>
        <td class="${isIncoming ? 'incoming' : 'outgoing'}">${tx.amount} ${tx.token}</td>
        <td class="usd-value" data-tx-key="${txKey}">${tx.valueUSD || 'Updating...'}</td>
      `;
      tbody.appendChild(row);
    });
  }
  // Setup pagination
  function setupPagination(transactions, itemsPerPage) {
    const totalPages = Math.ceil(transactions.length / itemsPerPage);
    let currentPage = 1;
    document.getElementById('current-page').textContent = currentPage;
    document.getElementById('prev-page').disabled = currentPage === 1;
    document.getElementById('next-page').disabled = currentPage === totalPages;
    document.getElementById('prev-page').addEventListener('click', () => {
      if (currentPage > 1) {
        currentPage--;
        renderTransactions(transactions, currentPage, itemsPerPage);
        document.getElementById('current-page').textContent = currentPage;
        document.getElementById('prev-page').disabled = currentPage === 1;
        document.getElementById('next-page').disabled = currentPage === totalPages;
      }
    });
    document.getElementById('next-page').addEventListener('click', () => {
      if (currentPage < totalPages) {
        currentPage++;
        renderTransactions(transactions, currentPage, itemsPerPage);
        document.getElementById('current-page').textContent = currentPage;
        document.getElementById('prev-page').disabled = currentPage === 1;
        document.getElementById('next-page').disabled = currentPage === totalPages;
      }
    });
  }
  function initializeDashboard() {
    // Initialize pagination
    const itemsPerPage = 10;
    let currentPage = 1;
    const totalPages = Math.ceil(window.treasury.transactions.length / itemsPerPage);
    // Update page info
    document.getElementById('total-pages').textContent = totalPages;
    // Calculate and display metrics
    calculateMetrics();
    // Create charts
    window.treasuryCharts.createVolumeChart();
    // Render initial transactions
    renderTransactions(window.treasury.transactions, currentPage, itemsPerPage);
    // Add pagination event listeners
    setupPagination(window.treasury.transactions, itemsPerPage);
  }
  // Make functions globally available
  Object.assign(window.treasury, {
    processTransactions,
    calculateMetrics,
    renderTransactions,
    setupPagination,
    initializeDashboard
  });
})();
</file>

<file path="assets/js/vendor-entry.js">
import Chart from 'chart.js/auto';
import Fuse from 'fuse.js';
// Make libraries available globally
window.Chart = Chart;
window.Fuse = Fuse;
</file>

<file path="assets/js/vendor.bundle.js">
(function () {
  'use strict';
  /*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   */
  function round(v) {
    return v + 0.5 | 0;
  }
  const lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  const map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
  const hex = [...'0123456789ABCDEF'];
  const h1 = b => hex[b & 0xF];
  const h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
  const eq = b => ((b & 0xF0) >> 4) === (b & 0xF);
  const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === '#') {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255
        };
      }
    }
    return ret;
  }
  const alpha = (a, f) => a < 255 ? f(a) : '';
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v
      ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)
      : undefined;
  }
  const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d, max) {
    if (r === max) {
      return ((g - b) / d) + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d + 2;
    }
    return (r - g) / d + 4;
  }
  function rgb2hsl(v) {
    const range = 255;
    const r = v.r / range;
    const g = v.g / range;
    const b = v.b / range;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = hueValue(r, g, b, d, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (
      Array.isArray(a)
        ? f(a[0], a[1], a[2])
        : f(a, b, c)
    ).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === 'hwb') {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === 'hsv') {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a: a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255
      ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
      : `hsl(${h}, ${s}%, ${l}%)`;
  }
  const map$2 = {
  	x: 'dark',
  	Z: 'light',
  	Y: 're',
  	X: 'blu',
  	W: 'gr',
  	V: 'medium',
  	U: 'slate',
  	A: 'ee',
  	T: 'ol',
  	S: 'or',
  	B: 'ra',
  	C: 'lateg',
  	D: 'ights',
  	R: 'in',
  	Q: 'turquois',
  	E: 'hi',
  	P: 'ro',
  	O: 'al',
  	N: 'le',
  	M: 'de',
  	L: 'yello',
  	F: 'en',
  	K: 'ch',
  	G: 'arks',
  	H: 'ea',
  	I: 'ightg',
  	J: 'wh'
  };
  const names$1 = {
  	OiceXe: 'f0f8ff',
  	antiquewEte: 'faebd7',
  	aqua: 'ffff',
  	aquamarRe: '7fffd4',
  	azuY: 'f0ffff',
  	beige: 'f5f5dc',
  	bisque: 'ffe4c4',
  	black: '0',
  	blanKedOmond: 'ffebcd',
  	Xe: 'ff',
  	XeviTet: '8a2be2',
  	bPwn: 'a52a2a',
  	burlywood: 'deb887',
  	caMtXe: '5f9ea0',
  	KartYuse: '7fff00',
  	KocTate: 'd2691e',
  	cSO: 'ff7f50',
  	cSnflowerXe: '6495ed',
  	cSnsilk: 'fff8dc',
  	crimson: 'dc143c',
  	cyan: 'ffff',
  	xXe: '8b',
  	xcyan: '8b8b',
  	xgTMnPd: 'b8860b',
  	xWay: 'a9a9a9',
  	xgYF: '6400',
  	xgYy: 'a9a9a9',
  	xkhaki: 'bdb76b',
  	xmagFta: '8b008b',
  	xTivegYF: '556b2f',
  	xSange: 'ff8c00',
  	xScEd: '9932cc',
  	xYd: '8b0000',
  	xsOmon: 'e9967a',
  	xsHgYF: '8fbc8f',
  	xUXe: '483d8b',
  	xUWay: '2f4f4f',
  	xUgYy: '2f4f4f',
  	xQe: 'ced1',
  	xviTet: '9400d3',
  	dAppRk: 'ff1493',
  	dApskyXe: 'bfff',
  	dimWay: '696969',
  	dimgYy: '696969',
  	dodgerXe: '1e90ff',
  	fiYbrick: 'b22222',
  	flSOwEte: 'fffaf0',
  	foYstWAn: '228b22',
  	fuKsia: 'ff00ff',
  	gaRsbSo: 'dcdcdc',
  	ghostwEte: 'f8f8ff',
  	gTd: 'ffd700',
  	gTMnPd: 'daa520',
  	Way: '808080',
  	gYF: '8000',
  	gYFLw: 'adff2f',
  	gYy: '808080',
  	honeyMw: 'f0fff0',
  	hotpRk: 'ff69b4',
  	RdianYd: 'cd5c5c',
  	Rdigo: '4b0082',
  	ivSy: 'fffff0',
  	khaki: 'f0e68c',
  	lavFMr: 'e6e6fa',
  	lavFMrXsh: 'fff0f5',
  	lawngYF: '7cfc00',
  	NmoncEffon: 'fffacd',
  	ZXe: 'add8e6',
  	ZcSO: 'f08080',
  	Zcyan: 'e0ffff',
  	ZgTMnPdLw: 'fafad2',
  	ZWay: 'd3d3d3',
  	ZgYF: '90ee90',
  	ZgYy: 'd3d3d3',
  	ZpRk: 'ffb6c1',
  	ZsOmon: 'ffa07a',
  	ZsHgYF: '20b2aa',
  	ZskyXe: '87cefa',
  	ZUWay: '778899',
  	ZUgYy: '778899',
  	ZstAlXe: 'b0c4de',
  	ZLw: 'ffffe0',
  	lime: 'ff00',
  	limegYF: '32cd32',
  	lRF: 'faf0e6',
  	magFta: 'ff00ff',
  	maPon: '800000',
  	VaquamarRe: '66cdaa',
  	VXe: 'cd',
  	VScEd: 'ba55d3',
  	VpurpN: '9370db',
  	VsHgYF: '3cb371',
  	VUXe: '7b68ee',
  	VsprRggYF: 'fa9a',
  	VQe: '48d1cc',
  	VviTetYd: 'c71585',
  	midnightXe: '191970',
  	mRtcYam: 'f5fffa',
  	mistyPse: 'ffe4e1',
  	moccasR: 'ffe4b5',
  	navajowEte: 'ffdead',
  	navy: '80',
  	Tdlace: 'fdf5e6',
  	Tive: '808000',
  	TivedBb: '6b8e23',
  	Sange: 'ffa500',
  	SangeYd: 'ff4500',
  	ScEd: 'da70d6',
  	pOegTMnPd: 'eee8aa',
  	pOegYF: '98fb98',
  	pOeQe: 'afeeee',
  	pOeviTetYd: 'db7093',
  	papayawEp: 'ffefd5',
  	pHKpuff: 'ffdab9',
  	peru: 'cd853f',
  	pRk: 'ffc0cb',
  	plum: 'dda0dd',
  	powMrXe: 'b0e0e6',
  	purpN: '800080',
  	YbeccapurpN: '663399',
  	Yd: 'ff0000',
  	Psybrown: 'bc8f8f',
  	PyOXe: '4169e1',
  	saddNbPwn: '8b4513',
  	sOmon: 'fa8072',
  	sandybPwn: 'f4a460',
  	sHgYF: '2e8b57',
  	sHshell: 'fff5ee',
  	siFna: 'a0522d',
  	silver: 'c0c0c0',
  	skyXe: '87ceeb',
  	UXe: '6a5acd',
  	UWay: '708090',
  	UgYy: '708090',
  	snow: 'fffafa',
  	sprRggYF: 'ff7f',
  	stAlXe: '4682b4',
  	tan: 'd2b48c',
  	teO: '8080',
  	tEstN: 'd8bfd8',
  	tomato: 'ff6347',
  	Qe: '40e0d0',
  	viTet: 'ee82ee',
  	JHt: 'f5deb3',
  	wEte: 'ffffff',
  	wEtesmoke: 'f5f5f5',
  	Lw: 'ffff00',
  	LwgYF: '9acd32'
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map$2);
    let i, j, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map$2[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
    }
    return unpacked;
  }
  let names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  }
  function rgbString(v) {
    return v && (
      v.a < 255
        ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
        : `rgb(${v.r}, ${v.g}, ${v.b})`
    );
  }
  const to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
  const from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate$1(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone$1(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = {r: 0, g: 0, b: 0, a: 255};
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = {r: input[0], g: input[1], b: input[2], a: 255};
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone$1(input, {r: 0, g: 0, b: 0, a: 1});
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === 'r') {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  class Color {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === 'object') {
        v = fromObject(input);
      } else if (type === 'string') {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone$1(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : undefined;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : undefined;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : undefined;
    }
    mix(color, weight) {
      if (color) {
        const c1 = this.rgb;
        const c2 = color.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        w2 = 1 - w1;
        c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color, t) {
      if (color) {
        this._rgb = interpolate$1(this._rgb, color._rgb, t);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  }
  /*!
   * Chart.js v4.4.7
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   */
  /**
   * @namespace Chart.helpers
   */ /**
   * An empty function that can be used, for example, for optional callback.
   */ function noop() {
  /* noop */ }
  /**
   * Returns a unique id, sequentially generated from a global variable.
   */ const uid = (()=>{
      let id = 0;
      return ()=>id++;
  })();
  /**
   * Returns true if `value` is neither null nor undefined, else returns false.
   * @param value - The value to test.
   * @since 2.7.0
   */ function isNullOrUndef(value) {
      return value === null || value === undefined;
  }
  /**
   * Returns true if `value` is an array (including typed arrays), else returns false.
   * @param value - The value to test.
   * @function
   */ function isArray$1(value) {
      if (Array.isArray && Array.isArray(value)) {
          return true;
      }
      const type = Object.prototype.toString.call(value);
      if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
          return true;
      }
      return false;
  }
  /**
   * Returns true if `value` is an object (excluding null), else returns false.
   * @param value - The value to test.
   * @since 2.7.0
   */ function isObject$1(value) {
      return value !== null && Object.prototype.toString.call(value) === '[object Object]';
  }
  /**
   * Returns true if `value` is a finite number, else returns false
   * @param value  - The value to test.
   */ function isNumberFinite(value) {
      return (typeof value === 'number' || value instanceof Number) && isFinite(+value);
  }
  /**
   * Returns `value` if finite, else returns `defaultValue`.
   * @param value - The value to return if defined.
   * @param defaultValue - The value to return if `value` is not finite.
   */ function finiteOrDefault(value, defaultValue) {
      return isNumberFinite(value) ? value : defaultValue;
  }
  /**
   * Returns `value` if defined, else returns `defaultValue`.
   * @param value - The value to return if defined.
   * @param defaultValue - The value to return if `value` is undefined.
   */ function valueOrDefault(value, defaultValue) {
      return typeof value === 'undefined' ? defaultValue : value;
  }
  const toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;
  const toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;
  /**
   * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
   * value returned by `fn`. If `fn` is not a function, this method returns undefined.
   * @param fn - The function to call.
   * @param args - The arguments with which `fn` should be called.
   * @param [thisArg] - The value of `this` provided for the call to `fn`.
   */ function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === 'function') {
          return fn.apply(thisArg, args);
      }
  }
  function each(loopable, fn, thisArg, reverse) {
      let i, len, keys;
      if (isArray$1(loopable)) {
          len = loopable.length;
          {
              for(i = 0; i < len; i++){
                  fn.call(thisArg, loopable[i], i);
              }
          }
      } else if (isObject$1(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;
          for(i = 0; i < len; i++){
              fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
      }
  }
  /**
   * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
   * @param a0 - The array to compare
   * @param a1 - The array to compare
   * @private
   */ function _elementsEqual(a0, a1) {
      let i, ilen, v0, v1;
      if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
      }
      for(i = 0, ilen = a0.length; i < ilen; ++i){
          v0 = a0[i];
          v1 = a1[i];
          if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
          }
      }
      return true;
  }
  /**
   * Returns a deep copy of `source` without keeping references on objects and arrays.
   * @param source - The value to clone.
   */ function clone(source) {
      if (isArray$1(source)) {
          return source.map(clone);
      }
      if (isObject$1(source)) {
          const target = Object.create(null);
          const keys = Object.keys(source);
          const klen = keys.length;
          let k = 0;
          for(; k < klen; ++k){
              target[keys[k]] = clone(source[keys[k]]);
          }
          return target;
      }
      return source;
  }
  function isValidKey(key) {
      return [
          '__proto__',
          'prototype',
          'constructor'
      ].indexOf(key) === -1;
  }
  /**
   * The default merger when Chart.helpers.merge is called without merger option.
   * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
   * @private
   */ function _merger(key, target, source, options) {
      if (!isValidKey(key)) {
          return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject$1(tval) && isObject$1(sval)) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          merge(tval, sval, options);
      } else {
          target[key] = clone(sval);
      }
  }
  function merge(target, source, options) {
      const sources = isArray$1(source) ? source : [
          source
      ];
      const ilen = sources.length;
      if (!isObject$1(target)) {
          return target;
      }
      options = options || {};
      const merger = options.merger || _merger;
      let current;
      for(let i = 0; i < ilen; ++i){
          current = sources[i];
          if (!isObject$1(current)) {
              continue;
          }
          const keys = Object.keys(current);
          for(let k = 0, klen = keys.length; k < klen; ++k){
              merger(keys[k], target, current, options);
          }
      }
      return target;
  }
  function mergeIf(target, source) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return merge(target, source, {
          merger: _mergerIf
      });
  }
  /**
   * Merges source[key] in target[key] only if target[key] is undefined.
   * @private
   */ function _mergerIf(key, target, source) {
      if (!isValidKey(key)) {
          return;
      }
      const tval = target[key];
      const sval = source[key];
      if (isObject$1(tval) && isObject$1(sval)) {
          mergeIf(tval, sval);
      } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
          target[key] = clone(sval);
      }
  }
  // resolveObjectKey resolver cache
  const keyResolvers = {
      // Chart.helpers.core resolveObjectKey should resolve empty key to root object
      '': (v)=>v,
      // default resolvers
      x: (o)=>o.x,
      y: (o)=>o.y
  };
  /**
   * @private
   */ function _splitKey(key) {
      const parts = key.split('.');
      const keys = [];
      let tmp = '';
      for (const part of parts){
          tmp += part;
          if (tmp.endsWith('\\')) {
              tmp = tmp.slice(0, -1) + '.';
          } else {
              keys.push(tmp);
              tmp = '';
          }
      }
      return keys;
  }
  function _getKeyResolver(key) {
      const keys = _splitKey(key);
      return (obj)=>{
          for (const k of keys){
              if (k === '') {
                  break;
              }
              obj = obj && obj[k];
          }
          return obj;
      };
  }
  function resolveObjectKey(obj, key) {
      const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
      return resolver(obj);
  }
  /**
   * @private
   */ function _capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
  }
  const defined = (value)=>typeof value !== 'undefined';
  const isFunction = (value)=>typeof value === 'function';
  // Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
  const setsEqual = (a, b)=>{
      if (a.size !== b.size) {
          return false;
      }
      for (const item of a){
          if (!b.has(item)) {
              return false;
          }
      }
      return true;
  };
  /**
   * @param e - The event
   * @private
   */ function _isClickEvent(e) {
      return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';
  }
  /**
   * @alias Chart.helpers.math
   * @namespace
   */ const PI = Math.PI;
  const TAU = 2 * PI;
  const PITAU = TAU + PI;
  const INFINITY = Number.POSITIVE_INFINITY;
  const RAD_PER_DEG = PI / 180;
  const HALF_PI = PI / 2;
  const QUARTER_PI = PI / 4;
  const TWO_THIRDS_PI = PI * 2 / 3;
  const log10 = Math.log10;
  const sign = Math.sign;
  function almostEquals(x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
  }
  /**
   * Implementation of the nice number algorithm used in determining where axis labels will go
   */ function niceNum(range) {
      const roundedRange = Math.round(range);
      range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
      const niceRange = Math.pow(10, Math.floor(log10(range)));
      const fraction = range / niceRange;
      const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
      return niceFraction * niceRange;
  }
  /**
   * Returns an array of factors sorted from 1 to sqrt(value)
   * @private
   */ function _factorize(value) {
      const result = [];
      const sqrt = Math.sqrt(value);
      let i;
      for(i = 1; i < sqrt; i++){
          if (value % i === 0) {
              result.push(i);
              result.push(value / i);
          }
      }
      if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
      }
      result.sort((a, b)=>a - b).pop();
      return result;
  }
  function isNumber$1(n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
      const rounded = Math.round(x);
      return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  /**
   * @private
   */ function _setMinAndMaxByKey(array, target, property) {
      let i, ilen, value;
      for(i = 0, ilen = array.length; i < ilen; i++){
          value = array[i][property];
          if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
          }
      }
  }
  function toRadians(degrees) {
      return degrees * (PI / 180);
  }
  function toDegrees(radians) {
      return radians * (180 / PI);
  }
  /**
   * Returns the number of decimal places
   * i.e. the number of digits after the decimal point, of the value of this Number.
   * @param x - A number.
   * @returns The number of decimal places.
   * @private
   */ function _decimalPlaces(x) {
      if (!isNumberFinite(x)) {
          return;
      }
      let e = 1;
      let p = 0;
      while(Math.round(x * e) / e !== x){
          e *= 10;
          p++;
      }
      return p;
  }
  // Gets the angle from vertical upright to the point about a centre.
  function getAngleFromPoint(centrePoint, anglePoint) {
      const distanceFromXCenter = anglePoint.x - centrePoint.x;
      const distanceFromYCenter = anglePoint.y - centrePoint.y;
      const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
      if (angle < -0.5 * PI) {
          angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
      }
      return {
          angle,
          distance: radialDistanceFromCenter
      };
  }
  function distanceBetweenPoints(pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  /**
   * Shortest distance between angles, in either direction.
   * @private
   */ function _angleDiff(a, b) {
      return (a - b + PITAU) % TAU - PI;
  }
  /**
   * Normalize angle to be between 0 and 2*PI
   * @private
   */ function _normalizeAngle(a) {
      return (a % TAU + TAU) % TAU;
  }
  /**
   * @private
   */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
      const a = _normalizeAngle(angle);
      const s = _normalizeAngle(start);
      const e = _normalizeAngle(end);
      const angleToStart = _normalizeAngle(s - a);
      const angleToEnd = _normalizeAngle(e - a);
      const startToAngle = _normalizeAngle(a - s);
      const endToAngle = _normalizeAngle(a - e);
      return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  /**
   * Limit `value` between `min` and `max`
   * @param value
   * @param min
   * @param max
   * @private
   */ function _limitValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
  }
  /**
   * @param {number} value
   * @private
   */ function _int16Range(value) {
      return _limitValue(value, -32768, 32767);
  }
  /**
   * @param value
   * @param start
   * @param end
   * @param [epsilon]
   * @private
   */ function _isBetween(value, start, end, epsilon = 1e-6) {
      return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
      cmp = cmp || ((index)=>table[index] < value);
      let hi = table.length - 1;
      let lo = 0;
      let mid;
      while(hi - lo > 1){
          mid = lo + hi >> 1;
          if (cmp(mid)) {
              lo = mid;
          } else {
              hi = mid;
          }
      }
      return {
          lo,
          hi
      };
  }
  /**
   * Binary search
   * @param table - the table search. must be sorted!
   * @param key - property name for the value in each entry
   * @param value - value to find
   * @param last - lookup last index
   * @private
   */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{
          const ti = table[index][key];
          return ti < value || ti === value && table[index + 1][key] === value;
      } : (index)=>table[index][key] < value);
  /**
   * Reverse binary search
   * @param table - the table search. must be sorted!
   * @param key - property name for the value in each entry
   * @param value - value to find
   * @private
   */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);
  /**
   * Return subset of `values` between `min` and `max` inclusive.
   * Values are assumed to be in sorted order.
   * @param values - sorted array of values
   * @param min - min value
   * @param max - max value
   */ function _filterBetween(values, min, max) {
      let start = 0;
      let end = values.length;
      while(start < end && values[start] < min){
          start++;
      }
      while(end > start && values[end - 1] > max){
          end--;
      }
      return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  const arrayEvents = [
      'push',
      'pop',
      'shift',
      'splice',
      'unshift'
  ];
  function listenArrayEvents(array, listener) {
      if (array._chartjs) {
          array._chartjs.listeners.push(listener);
          return;
      }
      Object.defineProperty(array, '_chartjs', {
          configurable: true,
          enumerable: false,
          value: {
              listeners: [
                  listener
              ]
          }
      });
      arrayEvents.forEach((key)=>{
          const method = '_onData' + _capitalize(key);
          const base = array[key];
          Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value (...args) {
                  const res = base.apply(this, args);
                  array._chartjs.listeners.forEach((object)=>{
                      if (typeof object[method] === 'function') {
                          object[method](...args);
                      }
                  });
                  return res;
              }
          });
      });
  }
  function unlistenArrayEvents(array, listener) {
      const stub = array._chartjs;
      if (!stub) {
          return;
      }
      const listeners = stub.listeners;
      const index = listeners.indexOf(listener);
      if (index !== -1) {
          listeners.splice(index, 1);
      }
      if (listeners.length > 0) {
          return;
      }
      arrayEvents.forEach((key)=>{
          delete array[key];
      });
      delete array._chartjs;
  }
  /**
   * @param items
   */ function _arrayUnique(items) {
      const set = new Set(items);
      if (set.size === items.length) {
          return items;
      }
      return Array.from(set);
  }
  /**
  * Request animation polyfill
  */ const requestAnimFrame = function() {
      if (typeof window === 'undefined') {
          return function(callback) {
              return callback();
          };
      }
      return window.requestAnimationFrame;
  }();
  /**
   * Throttles calling `fn` once per animation frame
   * Latest arguments are used on the actual call
   */ function throttled(fn, thisArg) {
      let argsToUse = [];
      let ticking = false;
      return function(...args) {
          // Save the args for use later
          argsToUse = args;
          if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, ()=>{
                  ticking = false;
                  fn.apply(thisArg, argsToUse);
              });
          }
      };
  }
  /**
   * Debounces calling `fn` for `delay` ms
   */ function debounce(fn, delay) {
      let timeout;
      return function(...args) {
          if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
          } else {
              fn.apply(this, args);
          }
          return delay;
      };
  }
  /**
   * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
   * @private
   */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
  /**
   * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
   * @private
   */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
  /**
   * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
   * @private
   */ const _textX = (align, left, right, rtl)=>{
      const check = rtl ? 'left' : 'right';
      return align === check ? right : align === 'center' ? (left + right) / 2 : left;
  };
  /**
   * Return start and count of visible points.
   * @private
   */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
      const pointCount = points.length;
      let start = 0;
      let count = pointCount;
      if (meta._sorted) {
          const { iScale , _parsed  } = meta;
          const axis = iScale.axis;
          const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
          if (minDefined) {
              start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed
              _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
              animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
          }
          if (maxDefined) {
              count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed
              _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
              animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;
          } else {
              count = pointCount - start;
          }
      }
      return {
          start,
          count
      };
  }
  /**
   * Checks if the scale ranges have changed.
   * @param {object} meta - dataset meta.
   * @returns {boolean}
   * @private
   */ function _scaleRangesChanged(meta) {
      const { xScale , yScale , _scaleRanges  } = meta;
      const newRanges = {
          xmin: xScale.min,
          xmax: xScale.max,
          ymin: yScale.min,
          ymax: yScale.max
      };
      if (!_scaleRanges) {
          meta._scaleRanges = newRanges;
          return true;
      }
      const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
      Object.assign(_scaleRanges, newRanges);
      return changed;
  }
  const atEdge = (t)=>t === 0 || t === 1;
  const elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  const elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  /**
   * Easing functions adapted from Robert Penner's easing equations.
   * @namespace Chart.helpers.easing.effects
   * @see http://www.robertpenner.com/easing/
   */ const effects = {
      linear: (t)=>t,
      easeInQuad: (t)=>t * t,
      easeOutQuad: (t)=>-t * (t - 2),
      easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
      easeInCubic: (t)=>t * t * t,
      easeOutCubic: (t)=>(t -= 1) * t * t + 1,
      easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
      easeInQuart: (t)=>t * t * t * t,
      easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),
      easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
      easeInQuint: (t)=>t * t * t * t * t,
      easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,
      easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
      easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,
      easeOutSine: (t)=>Math.sin(t * HALF_PI),
      easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),
      easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
      easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
      easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
      easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
      easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),
      easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
      easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
      easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
      easeInOutElastic (t) {
          const s = 0.1125;
          const p = 0.45;
          return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
      },
      easeInBack (t) {
          const s = 1.70158;
          return t * t * ((s + 1) * t - s);
      },
      easeOutBack (t) {
          const s = 1.70158;
          return (t -= 1) * t * ((s + 1) * t + s) + 1;
      },
      easeInOutBack (t) {
          let s = 1.70158;
          if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
          }
          return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
      },
      easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),
      easeOutBounce (t) {
          const m = 7.5625;
          const d = 2.75;
          if (t < 1 / d) {
              return m * t * t;
          }
          if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
          }
          if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
          }
          return m * (t -= 2.625 / d) * t + 0.984375;
      },
      easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
      if (value && typeof value === 'object') {
          const type = value.toString();
          return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';
      }
      return false;
  }
  function color(value) {
      return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
      return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  const numbers = [
      'x',
      'y',
      'borderWidth',
      'radius',
      'tension'
  ];
  const colors = [
      'color',
      'borderColor',
      'backgroundColor'
  ];
  function applyAnimationsDefaults(defaults) {
      defaults.set('animation', {
          delay: undefined,
          duration: 1000,
          easing: 'easeOutQuart',
          fn: undefined,
          from: undefined,
          loop: undefined,
          to: undefined,
          type: undefined
      });
      defaults.describe('animation', {
          _fallback: false,
          _indexable: false,
          _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'
      });
      defaults.set('animations', {
          colors: {
              type: 'color',
              properties: colors
          },
          numbers: {
              type: 'number',
              properties: numbers
          }
      });
      defaults.describe('animations', {
          _fallback: 'animation'
      });
      defaults.set('transitions', {
          active: {
              animation: {
                  duration: 400
              }
          },
          resize: {
              animation: {
                  duration: 0
              }
          },
          show: {
              animations: {
                  colors: {
                      from: 'transparent'
                  },
                  visible: {
                      type: 'boolean',
                      duration: 0
                  }
              }
          },
          hide: {
              animations: {
                  colors: {
                      to: 'transparent'
                  },
                  visible: {
                      type: 'boolean',
                      easing: 'linear',
                      fn: (v)=>v | 0
                  }
              }
          }
      });
  }
  function applyLayoutsDefaults(defaults) {
      defaults.set('layout', {
          autoPadding: true,
          padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0
          }
      });
  }
  const intlCache = new Map();
  function getNumberFormat(locale, options) {
      options = options || {};
      const cacheKey = locale + JSON.stringify(options);
      let formatter = intlCache.get(cacheKey);
      if (!formatter) {
          formatter = new Intl.NumberFormat(locale, options);
          intlCache.set(cacheKey, formatter);
      }
      return formatter;
  }
  function formatNumber(num, locale, options) {
      return getNumberFormat(locale, options).format(num);
  }
  const formatters = {
   values (value) {
          return isArray$1(value) ?  value : '' + value;
      },
   numeric (tickValue, index, ticks) {
          if (tickValue === 0) {
              return '0';
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
              const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
              if (maxTick < 1e-4 || maxTick > 1e+15) {
                  notation = 'scientific';
              }
              delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options = {
              notation,
              minimumFractionDigits: numDecimal,
              maximumFractionDigits: numDecimal
          };
          Object.assign(options, this.options.ticks.format);
          return formatNumber(tickValue, locale, options);
      },
   logarithmic (tickValue, index, ticks) {
          if (tickValue === 0) {
              return '0';
          }
          const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if ([
              1,
              2,
              3,
              5,
              10,
              15
          ].includes(remain) || index > 0.8 * ticks.length) {
              return formatters.numeric.call(this, tickValue, index, ticks);
          }
          return '';
      }
  };
  function calculateDelta(tickValue, ticks) {
      let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
      if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
          delta = tickValue - Math.floor(tickValue);
      }
      return delta;
  }
   var Ticks = {
      formatters
  };
  function applyScaleDefaults(defaults) {
      defaults.set('scale', {
          display: true,
          offset: false,
          reverse: false,
          beginAtZero: false,
   bounds: 'ticks',
          clip: true,
   grace: 0,
          grid: {
              display: true,
              lineWidth: 1,
              drawOnChartArea: true,
              drawTicks: true,
              tickLength: 8,
              tickWidth: (_ctx, options)=>options.lineWidth,
              tickColor: (_ctx, options)=>options.color,
              offset: false
          },
          border: {
              display: true,
              dash: [],
              dashOffset: 0.0,
              width: 1
          },
          title: {
              display: false,
              text: '',
              padding: {
                  top: 4,
                  bottom: 4
              }
          },
          ticks: {
              minRotation: 0,
              maxRotation: 50,
              mirror: false,
              textStrokeWidth: 0,
              textStrokeColor: '',
              padding: 3,
              display: true,
              autoSkip: true,
              autoSkipPadding: 3,
              labelOffset: 0,
              callback: Ticks.formatters.values,
              minor: {},
              major: {},
              align: 'center',
              crossAlign: 'near',
              showLabelBackdrop: false,
              backdropColor: 'rgba(255, 255, 255, 0.75)',
              backdropPadding: 2
          }
      });
      defaults.route('scale.ticks', 'color', '', 'color');
      defaults.route('scale.grid', 'color', '', 'borderColor');
      defaults.route('scale.border', 'color', '', 'borderColor');
      defaults.route('scale.title', 'color', '', 'color');
      defaults.describe('scale', {
          _fallback: false,
          _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
          _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'
      });
      defaults.describe('scales', {
          _fallback: 'scale'
      });
      defaults.describe('scale.ticks', {
          _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',
          _indexable: (name)=>name !== 'backdropPadding'
      });
  }
  const overrides = Object.create(null);
  const descriptors = Object.create(null);
   function getScope$1(node, key) {
      if (!key) {
          return node;
      }
      const keys = key.split('.');
      for(let i = 0, n = keys.length; i < n; ++i){
          const k = keys[i];
          node = node[k] || (node[k] = Object.create(null));
      }
      return node;
  }
  function set(root, scope, values) {
      if (typeof scope === 'string') {
          return merge(getScope$1(root, scope), values);
      }
      return merge(getScope$1(root, ''), scope);
  }
   class Defaults {
      constructor(_descriptors, _appliers){
          this.animation = undefined;
          this.backgroundColor = 'rgba(0,0,0,0.1)';
          this.borderColor = 'rgba(0,0,0,0.1)';
          this.color = '#666';
          this.datasets = {};
          this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();
          this.elements = {};
          this.events = [
              'mousemove',
              'mouseout',
              'click',
              'touchstart',
              'touchmove'
          ];
          this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: 'normal',
              lineHeight: 1.2,
              weight: null
          };
          this.hover = {};
          this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);
          this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);
          this.hoverColor = (ctx, options)=>getHoverColor(options.color);
          this.indexAxis = 'x';
          this.interaction = {
              mode: 'nearest',
              intersect: true,
              includeInvisible: false
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = undefined;
          this.scales = {};
          this.showLine = true;
          this.drawActiveElementsOnTop = true;
          this.describe(_descriptors);
          this.apply(_appliers);
      }
   set(scope, values) {
          return set(this, scope, values);
      }
   get(scope) {
          return getScope$1(this, scope);
      }
   describe(scope, values) {
          return set(descriptors, scope, values);
      }
      override(scope, values) {
          return set(overrides, scope, values);
      }
   route(scope, name, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope);
          const targetScopeObject = getScope$1(this, targetScope);
          const privateName = '_' + name;
          Object.defineProperties(scopeObject, {
              [privateName]: {
                  value: scopeObject[name],
                  writable: true
              },
              [name]: {
                  enumerable: true,
                  get () {
                      const local = this[privateName];
                      const target = targetScopeObject[targetName];
                      if (isObject$1(local)) {
                          return Object.assign({}, target, local);
                      }
                      return valueOrDefault(local, target);
                  },
                  set (value) {
                      this[privateName] = value;
                  }
              }
          });
      }
      apply(appliers) {
          appliers.forEach((apply)=>apply(this));
      }
  }
  var defaults = /* #__PURE__ */ new Defaults({
      _scriptable: (name)=>!name.startsWith('on'),
      _indexable: (name)=>name !== 'events',
      hover: {
          _fallback: 'interaction'
      },
      interaction: {
          _scriptable: false,
          _indexable: false
      }
  }, [
      applyAnimationsDefaults,
      applyLayoutsDefaults,
      applyScaleDefaults
  ]);
  /**
   * Converts the given font object into a CSS font string.
   * @param font - A font object.
   * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
   * @private
   */ function toFontString(font) {
      if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
          return null;
      }
      return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
  }
  /**
   * @private
   */ function _measureText(ctx, data, gc, longest, string) {
      let textWidth = data[string];
      if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
      }
      if (textWidth > longest) {
          longest = textWidth;
      }
      return longest;
  }
  /**
   * @private
   */ // eslint-disable-next-line complexity
  function _longestText(ctx, font, arrayOfThings, cache) {
      cache = cache || {};
      let data = cache.data = cache.data || {};
      let gc = cache.garbageCollect = cache.garbageCollect || [];
      if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
      }
      ctx.save();
      ctx.font = font;
      let longest = 0;
      const ilen = arrayOfThings.length;
      let i, j, jlen, thing, nestedThing;
      for(i = 0; i < ilen; i++){
          thing = arrayOfThings[i];
          // Undefined strings and arrays should not be measured
          if (thing !== undefined && thing !== null && !isArray$1(thing)) {
              longest = _measureText(ctx, data, gc, longest, thing);
          } else if (isArray$1(thing)) {
              // if it is an array lets measure each element
              // to do maybe simplify this function a bit so we can do this more recursively?
              for(j = 0, jlen = thing.length; j < jlen; j++){
                  nestedThing = thing[j];
                  // Undefined strings and arrays should not be measured
                  if (nestedThing !== undefined && nestedThing !== null && !isArray$1(nestedThing)) {
                      longest = _measureText(ctx, data, gc, longest, nestedThing);
                  }
              }
          }
      }
      ctx.restore();
      const gcLen = gc.length / 2;
      if (gcLen > arrayOfThings.length) {
          for(i = 0; i < gcLen; i++){
              delete data[gc[i]];
          }
          gc.splice(0, gcLen);
      }
      return longest;
  }
  /**
   * Returns the aligned pixel value to avoid anti-aliasing blur
   * @param chart - The chart instance.
   * @param pixel - A pixel value.
   * @param width - The width of the element.
   * @returns The aligned pixel value.
   * @private
   */ function _alignPixel(chart, pixel, width) {
      const devicePixelRatio = chart.currentDevicePixelRatio;
      const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  /**
   * Clears the entire canvas.
   */ function clearCanvas(canvas, ctx) {
      if (!ctx && !canvas) {
          return;
      }
      ctx = ctx || canvas.getContext('2d');
      ctx.save();
      // canvas.width and canvas.height do not consider the canvas transform,
      // while clearRect does
      ctx.resetTransform();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      drawPointLegend(ctx, options, x, y, null);
  }
  // eslint-disable-next-line complexity
  function drawPointLegend(ctx, options, x, y, w) {
      let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
      const style = options.pointStyle;
      const rotation = options.rotation;
      const radius = options.radius;
      let rad = (rotation || 0) * RAD_PER_DEG;
      if (style && typeof style === 'object') {
          type = style.toString();
          if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
              ctx.restore();
              return;
          }
      }
      if (isNaN(radius) || radius <= 0) {
          return;
      }
      ctx.beginPath();
      switch(style){
          // Default includes circle
          default:
              if (w) {
                  ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
              } else {
                  ctx.arc(x, y, radius, 0, TAU);
              }
              ctx.closePath();
              break;
          case 'triangle':
              width = w ? w / 2 : radius;
              ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
          case 'rectRounded':
              // NOTE: the rounded rect implementation changed to use `arc` instead of
              // `quadraticCurveTo` since it generates better results when rect is
              // almost a circle. 0.516 (instead of 0.5) produces results with visually
              // closer proportion to the previous impl and it is inscribed in the
              // circle with `radius`. For more details, see the following PRs:
              // https://github.com/chartjs/Chart.js/issues/5597
              // https://github.com/chartjs/Chart.js/issues/5858
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
              ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
              ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
              ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
              ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
              ctx.closePath();
              break;
          case 'rect':
              if (!rotation) {
                  size = Math.SQRT1_2 * radius;
                  width = w ? w / 2 : size;
                  ctx.rect(x - width, y - size, 2 * width, 2 * size);
                  break;
              }
              rad += QUARTER_PI;
          /* falls through */ case 'rectRot':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              ctx.closePath();
              break;
          case 'crossRot':
              rad += QUARTER_PI;
          /* falls through */ case 'cross':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
          case 'star':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              rad += QUARTER_PI;
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
          case 'line':
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
          case 'dash':
              ctx.moveTo(x, y);
              ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
              break;
          case false:
              ctx.closePath();
              break;
      }
      ctx.fill();
      if (options.borderWidth > 0) {
          ctx.stroke();
      }
  }
  /**
   * Returns true if the point is inside the rectangle
   * @param point - The point to test
   * @param area - The rectangle
   * @param margin - allowed margin
   * @private
   */ function _isPointInArea(point, area, margin) {
      margin = margin || 0.5; // margin - default is to match rounded decimals
      return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
  }
  function unclipArea(ctx) {
      ctx.restore();
  }
  /**
   * @private
   */ function _steppedLineTo(ctx, previous, target, flip, mode) {
      if (!previous) {
          return ctx.lineTo(target.x, target.y);
      }
      if (mode === 'middle') {
          const midpoint = (previous.x + target.x) / 2.0;
          ctx.lineTo(midpoint, previous.y);
          ctx.lineTo(midpoint, target.y);
      } else if (mode === 'after' !== !!flip) {
          ctx.lineTo(previous.x, target.y);
      } else {
          ctx.lineTo(target.x, previous.y);
      }
      ctx.lineTo(target.x, target.y);
  }
  /**
   * @private
   */ function _bezierCurveTo(ctx, previous, target, flip) {
      if (!previous) {
          return ctx.lineTo(target.x, target.y);
      }
      ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
      if (opts.translation) {
          ctx.translate(opts.translation[0], opts.translation[1]);
      }
      if (!isNullOrUndef(opts.rotation)) {
          ctx.rotate(opts.rotation);
      }
      if (opts.color) {
          ctx.fillStyle = opts.color;
      }
      if (opts.textAlign) {
          ctx.textAlign = opts.textAlign;
      }
      if (opts.textBaseline) {
          ctx.textBaseline = opts.textBaseline;
      }
  }
  function decorateText(ctx, x, y, line, opts) {
      if (opts.strikethrough || opts.underline) {
          /**
       * Now that IE11 support has been dropped, we can use more
       * of the TextMetrics object. The actual bounding boxes
       * are unflagged in Chrome, Firefox, Edge, and Safari so they
       * can be safely used.
       * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
       */ const metrics = ctx.measureText(line);
          const left = x - metrics.actualBoundingBoxLeft;
          const right = x + metrics.actualBoundingBoxRight;
          const top = y - metrics.actualBoundingBoxAscent;
          const bottom = y + metrics.actualBoundingBoxDescent;
          const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
          ctx.strokeStyle = ctx.fillStyle;
          ctx.beginPath();
          ctx.lineWidth = opts.decorationWidth || 2;
          ctx.moveTo(left, yDecoration);
          ctx.lineTo(right, yDecoration);
          ctx.stroke();
      }
  }
  function drawBackdrop(ctx, opts) {
      const oldColor = ctx.fillStyle;
      ctx.fillStyle = opts.color;
      ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
      ctx.fillStyle = oldColor;
  }
  /**
   * Render text onto the canvas
   */ function renderText(ctx, text, x, y, font, opts = {}) {
      const lines = isArray$1(text) ? text : [
          text
      ];
      const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
      let i, line;
      ctx.save();
      ctx.font = font.string;
      setRenderOpts(ctx, opts);
      for(i = 0; i < lines.length; ++i){
          line = lines[i];
          if (opts.backdrop) {
              drawBackdrop(ctx, opts.backdrop);
          }
          if (stroke) {
              if (opts.strokeColor) {
                  ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                  ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
          }
          ctx.fillText(line, x, y, opts.maxWidth);
          decorateText(ctx, x, y, line, opts);
          y += Number(font.lineHeight);
      }
      ctx.restore();
  }
  /**
   * Add a path of a rectangle with rounded corners to the current sub-path
   * @param ctx - Context
   * @param rect - Bounding rect
   */ function addRoundedRectPath(ctx, rect) {
      const { x , y , w , h , radius  } = rect;
      // top left arc
      ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
      // line from top left to bottom left
      ctx.lineTo(x, y + h - radius.bottomLeft);
      // bottom left arc
      ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
      // line from bottom left to bottom right
      ctx.lineTo(x + w - radius.bottomRight, y + h);
      // bottom right arc
      ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
      // line from bottom right to top right
      ctx.lineTo(x + w, y + radius.topRight);
      // top right arc
      ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
      // line from top right to top left
      ctx.lineTo(x + radius.topLeft, y);
  }
  const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  /**
   * @alias Chart.helpers.options
   * @namespace
   */ /**
   * Converts the given line height `value` in pixels for a specific font `size`.
   * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
   * @param size - The font size (in pixels) used to resolve relative `value`.
   * @returns The effective line height in pixels (size * 1.2 if value is invalid).
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
   * @since 2.7.0
   */ function toLineHeight(value, size) {
      const matches = ('' + value).match(LINE_HEIGHT);
      if (!matches || matches[1] === 'normal') {
          return size * 1.2;
      }
      value = +matches[2];
      switch(matches[3]){
          case 'px':
              return value;
          case '%':
              value /= 100;
              break;
      }
      return size * value;
  }
  const numberOrZero = (v)=>+v || 0;
  function _readValueToProps(value, props) {
      const ret = {};
      const objProps = isObject$1(props);
      const keys = objProps ? Object.keys(props) : props;
      const read = isObject$1(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;
      for (const prop of keys){
          ret[prop] = numberOrZero(read(prop));
      }
      return ret;
  }
  /**
   * Converts the given value into a TRBL object.
   * @param value - If a number, set the value to all TRBL component,
   *  else, if an object, use defined properties and sets undefined ones to 0.
   *  x / y are shorthands for same value for left/right and top/bottom.
   * @returns The padding values (top, right, bottom, left)
   * @since 3.0.0
   */ function toTRBL(value) {
      return _readValueToProps(value, {
          top: 'y',
          right: 'x',
          bottom: 'y',
          left: 'x'
      });
  }
  /**
   * Converts the given value into a TRBL corners object (similar with css border-radius).
   * @param value - If a number, set the value to all TRBL corner components,
   *  else, if an object, use defined properties and sets undefined ones to 0.
   * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
   * @since 3.0.0
   */ function toTRBLCorners(value) {
      return _readValueToProps(value, [
          'topLeft',
          'topRight',
          'bottomLeft',
          'bottomRight'
      ]);
  }
  /**
   * Converts the given value into a padding object with pre-computed width/height.
   * @param value - If a number, set the value to all TRBL component,
   *  else, if an object, use defined properties and sets undefined ones to 0.
   *  x / y are shorthands for same value for left/right and top/bottom.
   * @returns The padding values (top, right, bottom, left, width, height)
   * @since 2.7.0
   */ function toPadding(value) {
      const obj = toTRBL(value);
      obj.width = obj.left + obj.right;
      obj.height = obj.top + obj.bottom;
      return obj;
  }
  /**
   * Parses font options and returns the font object.
   * @param options - A object that contains font options to be parsed.
   * @param fallback - A object that contains fallback font options.
   * @return The font object.
   * @private
   */ function toFont(options, fallback) {
      options = options || {};
      fallback = fallback || defaults.font;
      let size = valueOrDefault(options.size, fallback.size);
      if (typeof size === 'string') {
          size = parseInt(size, 10);
      }
      let style = valueOrDefault(options.style, fallback.style);
      if (style && !('' + style).match(FONT_STYLE)) {
          console.warn('Invalid font style specified: "' + style + '"');
          style = undefined;
      }
      const font = {
          family: valueOrDefault(options.family, fallback.family),
          lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
          size,
          style,
          weight: valueOrDefault(options.weight, fallback.weight),
          string: ''
      };
      font.string = toFontString(font);
      return font;
  }
  /**
   * Evaluates the given `inputs` sequentially and returns the first defined value.
   * @param inputs - An array of values, falling back to the last value.
   * @param context - If defined and the current value is a function, the value
   * is called with `context` as first argument and the result becomes the new input.
   * @param index - If defined and the current value is an array, the value
   * at `index` become the new input.
   * @param info - object to return information about resolution in
   * @param info.cacheable - Will be set to `false` if option is not cacheable.
   * @since 2.7.0
   */ function resolve(inputs, context, index, info) {
      let i, ilen, value;
      for(i = 0, ilen = inputs.length; i < ilen; ++i){
          value = inputs[i];
          if (value === undefined) {
              continue;
          }
          if (value !== undefined) {
              return value;
          }
      }
  }
  /**
   * @param minmax
   * @param grace
   * @param beginAtZero
   * @private
   */ function _addGrace(minmax, grace, beginAtZero) {
      const { min , max  } = minmax;
      const change = toDimension(grace, (max - min) / 2);
      const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;
      return {
          min: keepZero(min, -Math.abs(change)),
          max: keepZero(max, change)
      };
  }
  function createContext(parentContext, context) {
      return Object.assign(Object.create(parentContext), context);
  }
  /**
   * Creates a Proxy for resolving raw values for options.
   * @param scopes - The option scopes to look for values, in resolution order
   * @param prefixes - The prefixes for values, in resolution order.
   * @param rootScopes - The root option scopes
   * @param fallback - Parent scopes fallback
   * @param getTarget - callback for getting the target for changed values
   * @returns Proxy
   * @private
   */ function _createResolver(scopes, prefixes = [
      ''
  ], rootScopes, fallback, getTarget = ()=>scopes[0]) {
      const finalRootScopes = rootScopes || scopes;
      if (typeof fallback === 'undefined') {
          fallback = _resolve('_fallback', scopes);
      }
      const cache = {
          [Symbol.toStringTag]: 'Object',
          _cacheable: true,
          _scopes: scopes,
          _rootScopes: finalRootScopes,
          _fallback: fallback,
          _getTarget: getTarget,
          override: (scope)=>_createResolver([
                  scope,
                  ...scopes
              ], prefixes, finalRootScopes, fallback)
      };
      return new Proxy(cache, {
          /**
       * A trap for the delete operator.
       */ deleteProperty (target, prop) {
              delete target[prop]; // remove from cache
              delete target._keys; // remove cached keys
              delete scopes[0][prop]; // remove from top level scope
              return true;
          },
          /**
       * A trap for getting property values.
       */ get (target, prop) {
              return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));
          },
          /**
       * A trap for Object.getOwnPropertyDescriptor.
       * Also used by Object.hasOwnProperty.
       */ getOwnPropertyDescriptor (target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
          },
          /**
       * A trap for Object.getPrototypeOf.
       */ getPrototypeOf () {
              return Reflect.getPrototypeOf(scopes[0]);
          },
          /**
       * A trap for the in operator.
       */ has (target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
          },
          /**
       * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
       */ ownKeys (target) {
              return getKeysFromAllScopes(target);
          },
          /**
       * A trap for setting property values.
       */ set (target, prop, value) {
              const storage = target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value; // set to top level scope + cache
              delete target._keys; // remove cached keys
              return true;
          }
      });
  }
  /**
   * Returns an Proxy for resolving option values with context.
   * @param proxy - The Proxy returned by `_createResolver`
   * @param context - Context object for scriptable/indexable options
   * @param subProxy - The proxy provided for scriptable options
   * @param descriptorDefaults - Defaults for descriptors
   * @private
   */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {
      const cache = {
          _cacheable: false,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),
          override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
      };
      return new Proxy(cache, {
          /**
       * A trap for the delete operator.
       */ deleteProperty (target, prop) {
              delete target[prop]; // remove from cache
              delete proxy[prop]; // remove from proxy
              return true;
          },
          /**
       * A trap for getting property values.
       */ get (target, prop, receiver) {
              return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));
          },
          /**
       * A trap for Object.getOwnPropertyDescriptor.
       * Also used by Object.hasOwnProperty.
       */ getOwnPropertyDescriptor (target, prop) {
              return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                  enumerable: true,
                  configurable: true
              } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);
          },
          /**
       * A trap for Object.getPrototypeOf.
       */ getPrototypeOf () {
              return Reflect.getPrototypeOf(proxy);
          },
          /**
       * A trap for the in operator.
       */ has (target, prop) {
              return Reflect.has(proxy, prop);
          },
          /**
       * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
       */ ownKeys () {
              return Reflect.ownKeys(proxy);
          },
          /**
       * A trap for setting property values.
       */ set (target, prop, value) {
              proxy[prop] = value; // set to proxy
              delete target[prop]; // remove from cache
              return true;
          }
      });
  }
  /**
   * @private
   */ function _descriptors(proxy, defaults = {
      scriptable: true,
      indexable: true
  }) {
      const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;
      return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,
          isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable
      };
  }
  const readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;
  const needsSubResolver = (prop, value)=>isObject$1(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve) {
      if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {
          return target[prop];
      }
      const value = resolve();
      // cache the resolved value
      target[prop] = value;
      return value;
  }
  function _resolveWithContext(target, prop, receiver) {
      const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
      let value = _proxy[prop]; // resolve from proxy
      // resolve with context
      if (isFunction(value) && descriptors.isScriptable(prop)) {
          value = _resolveScriptable(prop, value, target, receiver);
      }
      if (isArray$1(value) && value.length) {
          value = _resolveArray(prop, value, target, descriptors.isIndexable);
      }
      if (needsSubResolver(prop, value)) {
          // if the resolved value is an object, create a sub resolver for it
          value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
      }
      return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
      const { _proxy , _context , _subProxy , _stack  } = target;
      if (_stack.has(prop)) {
          throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
      }
      _stack.add(prop);
      let value = getValue(_context, _subProxy || receiver);
      _stack.delete(prop);
      if (needsSubResolver(prop, value)) {
          // When scriptable option returns an object, create a resolver on that.
          value = createSubResolver(_proxy._scopes, _proxy, prop, value);
      }
      return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
      const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;
      if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
          return value[_context.index % value.length];
      } else if (isObject$1(value[0])) {
          // Array of objects, return array or resolvers
          const arr = value;
          const scopes = _proxy._scopes.filter((s)=>s !== arr);
          value = [];
          for (const item of arr){
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
          }
      }
      return value;
  }
  function resolveFallback(fallback, prop, value) {
      return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  const getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
  function addScopes(set, parentScopes, key, parentFallback, value) {
      for (const parent of parentScopes){
          const scope = getScope(key, parent);
          if (scope) {
              set.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {
                  // When we reach the descriptor that defines a new _fallback, return that.
                  // The fallback will resume to that new scope.
                  return fallback;
              }
          } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {
              // Fallback to `false` results to `false`, when falling back to different key.
              // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
              return null;
          }
      }
      return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
      const rootScopes = resolver._rootScopes;
      const fallback = resolveFallback(resolver._fallback, prop, value);
      const allScopes = [
          ...parentScopes,
          ...rootScopes
      ];
      const set = new Set();
      set.add(value);
      let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
      if (key === null) {
          return false;
      }
      if (typeof fallback !== 'undefined' && fallback !== prop) {
          key = addScopesFromKey(set, allScopes, fallback, key, value);
          if (key === null) {
              return false;
          }
      }
      return _createResolver(Array.from(set), [
          ''
      ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set, allScopes, key, fallback, item) {
      while(key){
          key = addScopes(set, allScopes, key, fallback, item);
      }
      return key;
  }
  function subGetTarget(resolver, prop, value) {
      const parent = resolver._getTarget();
      if (!(prop in parent)) {
          parent[prop] = {};
      }
      const target = parent[prop];
      if (isArray$1(target) && isObject$1(value)) {
          // For array of objects, the object is used to store updated values
          return value;
      }
      return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
      let value;
      for (const prefix of prefixes){
          value = _resolve(readKey(prefix, prop), scopes);
          if (typeof value !== 'undefined') {
              return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
          }
      }
  }
  function _resolve(key, scopes) {
      for (const scope of scopes){
          if (!scope) {
              continue;
          }
          const value = scope[key];
          if (typeof value !== 'undefined') {
              return value;
          }
      }
  }
  function getKeysFromAllScopes(target) {
      let keys = target._keys;
      if (!keys) {
          keys = target._keys = resolveKeysFromAllScopes(target._scopes);
      }
      return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
      const set = new Set();
      for (const scope of scopes){
          for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){
              set.add(key);
          }
      }
      return Array.from(set);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
      const { iScale  } = meta;
      const { key ='r'  } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index, item;
      for(i = 0, ilen = count; i < ilen; ++i){
          index = i + start;
          item = data[index];
          parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index)
          };
      }
      return parsed;
  }
  const EPSILON = Number.EPSILON || 1e-14;
  const getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];
  const getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
      // Props to Rob Spencer at scaled innovation for his post on splining between points
      // http://scaledinnovation.com/analytics/splines/aboutSplines.html
      // This function must also respect "skipped" points
      const previous = firstPoint.skip ? middlePoint : firstPoint;
      const current = middlePoint;
      const next = afterPoint.skip ? middlePoint : afterPoint;
      const d01 = distanceBetweenPoints(current, previous);
      const d12 = distanceBetweenPoints(next, current);
      let s01 = d01 / (d01 + d12);
      let s12 = d12 / (d01 + d12);
      // If all points are the same, s01 & s02 will be inf
      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      const fa = t * s01; // scaling factor for triangle Ta
      const fb = t * s12;
      return {
          previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y)
          },
          next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y)
          }
      };
  }
  /**
   * Adjust tangents to ensure monotonic properties
   */ function monotoneAdjust(points, deltaK, mK) {
      const pointsLen = points.length;
      let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for(let i = 0; i < pointsLen - 1; ++i){
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent || !pointAfter) {
              continue;
          }
          if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
          }
          alphaK = mK[i] / deltaK[i];
          betaK = mK[i + 1] / deltaK[i];
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
              continue;
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          mK[i] = alphaK * tauK * deltaK[i];
          mK[i + 1] = betaK * tauK * deltaK[i];
      }
  }
  function monotoneCompute(points, mK, indexAxis = 'x') {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      let delta, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for(let i = 0; i < pointsLen; ++i){
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
              continue;
          }
          const iPixel = pointCurrent[indexAxis];
          const vPixel = pointCurrent[valueAxis];
          if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
          }
          if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
          }
      }
  }
  /**
   * This function calculates Bézier control points in a similar way than |splineCurve|,
   * but preserves monotonicity of the provided data and ensures no local extremums are added
   * between the dataset discrete points due to the interpolation.
   * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
   */ function splineCurveMonotone(points, indexAxis = 'x') {
      const valueAxis = getValueAxis(indexAxis);
      const pointsLen = points.length;
      const deltaK = Array(pointsLen).fill(0);
      const mK = Array(pointsLen);
      // Calculate slopes (deltaK) and initialize tangents (mK)
      let i, pointBefore, pointCurrent;
      let pointAfter = getPoint(points, 0);
      for(i = 0; i < pointsLen; ++i){
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
              continue;
          }
          if (pointAfter) {
              const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
              // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
              deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
          }
          mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
      }
      monotoneAdjust(points, deltaK, mK);
      monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
      return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
      let i, ilen, point, inArea, inAreaPrev;
      let inAreaNext = _isPointInArea(points[0], area);
      for(i = 0, ilen = points.length; i < ilen; ++i){
          inAreaPrev = inArea;
          inArea = inAreaNext;
          inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
          if (!inArea) {
              continue;
          }
          point = points[i];
          if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
          }
          if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
          }
      }
  }
  /**
   * @private
   */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
      let i, ilen, point, controlPoints;
      // Only consider points that are drawn in case the spanGaps option is used
      if (options.spanGaps) {
          points = points.filter((pt)=>!pt.skip);
      }
      if (options.cubicInterpolationMode === 'monotone') {
          splineCurveMonotone(points, indexAxis);
      } else {
          let prev = loop ? points[points.length - 1] : points[0];
          for(i = 0, ilen = points.length; i < ilen; ++i){
              point = points[i];
              controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
          }
      }
      if (options.capBezierPoints) {
          capBezierPoints(points, area);
      }
  }
  /**
   * Note: typedefs are auto-exported, so use a made-up `dom` namespace where
   * necessary to avoid duplicates with `export * from './helpers`; see
   * https://github.com/microsoft/TypeScript/issues/46011
   * @typedef { import('../core/core.controller.js').default } dom.Chart
   * @typedef { import('../../types').ChartEvent } ChartEvent
   */ /**
   * @private
   */ function _isDomSupported() {
      return typeof window !== 'undefined' && typeof document !== 'undefined';
  }
  /**
   * @private
   */ function _getParentNode(domNode) {
      let parent = domNode.parentNode;
      if (parent && parent.toString() === '[object ShadowRoot]') {
          parent = parent.host;
      }
      return parent;
  }
  /**
   * convert max-width/max-height values that may be percentages into a number
   * @private
   */ function parseMaxStyle(styleValue, node, parentProperty) {
      let valueInPixels;
      if (typeof styleValue === 'string') {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf('%') !== -1) {
              // percentage * size in dimension
              valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
      } else {
          valueInPixels = styleValue;
      }
      return valueInPixels;
  }
  const getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
      return getComputedStyle(el).getPropertyValue(property);
  }
  const positions = [
      'top',
      'right',
      'bottom',
      'left'
  ];
  function getPositionedStyle(styles, style, suffix) {
      const result = {};
      suffix = suffix ? '-' + suffix : '';
      for(let i = 0; i < 4; i++){
          const pos = positions[i];
          result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
      }
      result.width = result.left + result.right;
      result.height = result.top + result.bottom;
      return result;
  }
  const useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);
  /**
   * @param e
   * @param canvas
   * @returns Canvas position
   */ function getCanvasPosition(e, canvas) {
      const touches = e.touches;
      const source = touches && touches.length ? touches[0] : e;
      const { offsetX , offsetY  } = source;
      let box = false;
      let x, y;
      if (useOffsetPos(offsetX, offsetY, e.target)) {
          x = offsetX;
          y = offsetY;
      } else {
          const rect = canvas.getBoundingClientRect();
          x = source.clientX - rect.left;
          y = source.clientY - rect.top;
          box = true;
      }
      return {
          x,
          y,
          box
      };
  }
  /**
   * Gets an event's x, y coordinates, relative to the chart area
   * @param event
   * @param chart
   * @returns x and y coordinates of the event
   */ function getRelativePosition(event, chart) {
      if ('native' in event) {
          return event;
      }
      const { canvas , currentDevicePixelRatio  } = chart;
      const style = getComputedStyle(canvas);
      const borderBox = style.boxSizing === 'border-box';
      const paddings = getPositionedStyle(style, 'padding');
      const borders = getPositionedStyle(style, 'border', 'width');
      const { x , y , box  } = getCanvasPosition(event, canvas);
      const xOffset = paddings.left + (box && borders.left);
      const yOffset = paddings.top + (box && borders.top);
      let { width , height  } = chart;
      if (borderBox) {
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
      }
      return {
          x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
          y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
      };
  }
  function getContainerSize(canvas, width, height) {
      let maxWidth, maxHeight;
      if (width === undefined || height === undefined) {
          const container = canvas && _getParentNode(canvas);
          if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
          } else {
              const rect = container.getBoundingClientRect(); // this is the border box of the container
              const containerStyle = getComputedStyle(container);
              const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
              const containerPadding = getPositionedStyle(containerStyle, 'padding');
              width = rect.width - containerPadding.width - containerBorder.width;
              height = rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
              maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
          }
      }
      return {
          width,
          height,
          maxWidth: maxWidth || INFINITY,
          maxHeight: maxHeight || INFINITY
      };
  }
  const round1 = (v)=>Math.round(v * 10) / 10;
  // eslint-disable-next-line complexity
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
      const style = getComputedStyle(canvas);
      const margins = getPositionedStyle(style, 'margin');
      const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
      const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
      const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
      let { width , height  } = containerSize;
      if (style.boxSizing === 'content-box') {
          const borders = getPositionedStyle(style, 'border', 'width');
          const paddings = getPositionedStyle(style, 'padding');
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
      }
      width = Math.max(0, width - margins.width);
      height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
      width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
      height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
      if (width && !height) {
          // https://github.com/chartjs/Chart.js/issues/4659
          // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
          height = round1(width / 2);
      }
      const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;
      if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
          height = containerSize.height;
          width = round1(Math.floor(height * aspectRatio));
      }
      return {
          width,
          height
      };
  }
  /**
   * @param chart
   * @param forceRatio
   * @param forceStyle
   * @returns True if the canvas context size or transformation has changed.
   */ function retinaScale(chart, forceRatio, forceStyle) {
      const pixelRatio = forceRatio || 1;
      const deviceHeight = Math.floor(chart.height * pixelRatio);
      const deviceWidth = Math.floor(chart.width * pixelRatio);
      chart.height = Math.floor(chart.height);
      chart.width = Math.floor(chart.width);
      const canvas = chart.canvas;
      // If no style has been set on the canvas, the render size is used as display size,
      // making the chart visually bigger, so let's enforce it to the "correct" values.
      // See https://github.com/chartjs/Chart.js/issues/3575
      if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
          canvas.style.height = `${chart.height}px`;
          canvas.style.width = `${chart.width}px`;
      }
      if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
          chart.currentDevicePixelRatio = pixelRatio;
          canvas.height = deviceHeight;
          canvas.width = deviceWidth;
          chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return true;
      }
      return false;
  }
  /**
   * Detects support for options object argument in addEventListener.
   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
   * @private
   */ const supportsEventListenerOptions = function() {
      let passiveSupported = false;
      try {
          const options = {
              get passive () {
                  passiveSupported = true;
                  return false;
              }
          };
          if (_isDomSupported()) {
              window.addEventListener('test', null, options);
              window.removeEventListener('test', null, options);
          }
      } catch (e) {
      // continue regardless of error
      }
      return passiveSupported;
  }();
  /**
   * The "used" size is the final value of a dimension property after all calculations have
   * been performed. This method uses the computed style of `element` but returns undefined
   * if the computed style is not expressed in pixels. That can happen in some cases where
   * `element` has a size relative to its parent and this last one is not yet displayed,
   * for example because of `display: none` on a parent node.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
   * @returns Size in pixels or undefined if unknown.
   */ function readUsedSize(element, property) {
      const value = getStyle(element, property);
      const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
      return matches ? +matches[1] : undefined;
  }
  /**
   * @private
   */ function _pointInLine(p1, p2, t, mode) {
      return {
          x: p1.x + t * (p2.x - p1.x),
          y: p1.y + t * (p2.y - p1.y)
      };
  }
  /**
   * @private
   */ function _steppedInterpolation(p1, p2, t, mode) {
      return {
          x: p1.x + t * (p2.x - p1.x),
          y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
      };
  }
  /**
   * @private
   */ function _bezierInterpolation(p1, p2, t, mode) {
      const cp1 = {
          x: p1.cp2x,
          y: p1.cp2y
      };
      const cp2 = {
          x: p2.cp1x,
          y: p2.cp1y
      };
      const a = _pointInLine(p1, cp1, t);
      const b = _pointInLine(cp1, cp2, t);
      const c = _pointInLine(cp2, p2, t);
      const d = _pointInLine(a, b, t);
      const e = _pointInLine(b, c, t);
      return _pointInLine(d, e, t);
  }
  const getRightToLeftAdapter = function(rectX, width) {
      return {
          x (x) {
              return rectX + rectX + width - x;
          },
          setWidth (w) {
              width = w;
          },
          textAlign (align) {
              if (align === 'center') {
                  return align;
              }
              return align === 'right' ? 'left' : 'right';
          },
          xPlus (x, value) {
              return x - value;
          },
          leftForLtr (x, itemWidth) {
              return x - itemWidth;
          }
      };
  };
  const getLeftToRightAdapter = function() {
      return {
          x (x) {
              return x;
          },
          setWidth (w) {},
          textAlign (align) {
              return align;
          },
          xPlus (x, value) {
              return x + value;
          },
          leftForLtr (x, _itemWidth) {
              return x;
          }
      };
  };
  function getRtlAdapter(rtl, rectX, width) {
      return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
      let style, original;
      if (direction === 'ltr' || direction === 'rtl') {
          style = ctx.canvas.style;
          original = [
              style.getPropertyValue('direction'),
              style.getPropertyPriority('direction')
          ];
          style.setProperty('direction', direction, 'important');
          ctx.prevTextDirection = original;
      }
  }
  function restoreTextDirection(ctx, original) {
      if (original !== undefined) {
          delete ctx.prevTextDirection;
          ctx.canvas.style.setProperty('direction', original[0], original[1]);
      }
  }
  function propertyFn(property) {
      if (property === 'angle') {
          return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle
          };
      }
      return {
          between: _isBetween,
          compare: (a, b)=>a - b,
          normalize: (x)=>x
      };
  }
  function normalizeSegment({ start , end , count , loop , style  }) {
      return {
          start: start % count,
          end: end % count,
          loop: loop && (end - start + 1) % count === 0,
          style
      };
  }
  function getSegment(segment, points, bounds) {
      const { property , start: startBound , end: endBound  } = bounds;
      const { between , normalize  } = propertyFn(property);
      const count = points.length;
      let { start , end , loop  } = segment;
      let i, ilen;
      if (loop) {
          start += count;
          end += count;
          for(i = 0, ilen = count; i < ilen; ++i){
              if (!between(normalize(points[start % count][property]), startBound, endBound)) {
                  break;
              }
              start--;
              end--;
          }
          start %= count;
          end %= count;
      }
      if (end < start) {
          end += count;
      }
      return {
          start,
          end,
          loop,
          style: segment.style
      };
  }
   function _boundSegment(segment, points, bounds) {
      if (!bounds) {
          return [
              segment
          ];
      }
      const { property , start: startBound , end: endBound  } = bounds;
      const count = points.length;
      const { compare , between , normalize  } = propertyFn(property);
      const { start , end , loop , style  } = getSegment(segment, points, bounds);
      const result = [];
      let inside = false;
      let subStart = null;
      let value, point, prevValue;
      const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
      const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);
      const shouldStart = ()=>inside || startIsBefore();
      const shouldStop = ()=>!inside || endIsBefore();
      for(let i = start, prev = start; i <= end; ++i){
          point = points[i % count];
          if (point.skip) {
              continue;
          }
          value = normalize(point[property]);
          if (value === prevValue) {
              continue;
          }
          inside = between(value, startBound, endBound);
          if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
          }
          if (subStart !== null && shouldStop()) {
              result.push(normalizeSegment({
                  start: subStart,
                  end: i,
                  loop,
                  count,
                  style
              }));
              subStart = null;
          }
          prev = i;
          prevValue = value;
      }
      if (subStart !== null) {
          result.push(normalizeSegment({
              start: subStart,
              end,
              loop,
              count,
              style
          }));
      }
      return result;
  }
   function _boundSegments(line, bounds) {
      const result = [];
      const segments = line.segments;
      for(let i = 0; i < segments.length; i++){
          const sub = _boundSegment(segments[i], line.points, bounds);
          if (sub.length) {
              result.push(...sub);
          }
      }
      return result;
  }
   function findStartAndEnd(points, count, loop, spanGaps) {
      let start = 0;
      let end = count - 1;
      if (loop && !spanGaps) {
          while(start < count && !points[start].skip){
              start++;
          }
      }
      while(start < count && points[start].skip){
          start++;
      }
      start %= count;
      if (loop) {
          end += start;
      }
      while(end > start && points[end % count].skip){
          end--;
      }
      end %= count;
      return {
          start,
          end
      };
  }
   function solidSegments(points, start, max, loop) {
      const count = points.length;
      const result = [];
      let last = start;
      let prev = points[start];
      let end;
      for(end = start + 1; end <= max; ++end){
          const cur = points[end % count];
          if (cur.skip || cur.stop) {
              if (!prev.skip) {
                  loop = false;
                  result.push({
                      start: start % count,
                      end: (end - 1) % count,
                      loop
                  });
                  start = last = cur.stop ? end : null;
              }
          } else {
              last = end;
              if (prev.skip) {
                  start = end;
              }
          }
          prev = cur;
      }
      if (last !== null) {
          result.push({
              start: start % count,
              end: last % count,
              loop
          });
      }
      return result;
  }
   function _computeSegments(line, segmentOptions) {
      const points = line.points;
      const spanGaps = line.options.spanGaps;
      const count = points.length;
      if (!count) {
          return [];
      }
      const loop = !!line._loop;
      const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);
      if (spanGaps === true) {
          return splitByStyles(line, [
              {
                  start,
                  end,
                  loop
              }
          ], points, segmentOptions);
      }
      const max = end < start ? end + count : end;
      const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
      return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
   function splitByStyles(line, segments, points, segmentOptions) {
      if (!segmentOptions || !segmentOptions.setContext || !points) {
          return segments;
      }
      return doSplitByStyles(line, segments, points, segmentOptions);
  }
   function doSplitByStyles(line, segments, points, segmentOptions) {
      const chartContext = line._chart.getContext();
      const baseStyle = readStyle(line.options);
      const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;
      const count = points.length;
      const result = [];
      let prevStyle = baseStyle;
      let start = segments[0].start;
      let i = start;
      function addStyle(s, e, l, st) {
          const dir = spanGaps ? -1 : 1;
          if (s === e) {
              return;
          }
          s += count;
          while(points[s % count].skip){
              s -= dir;
          }
          while(points[e % count].skip){
              e += dir;
          }
          if (s % count !== e % count) {
              result.push({
                  start: s % count,
                  end: e % count,
                  loop: l,
                  style: st
              });
              prevStyle = st;
              start = e % count;
          }
      }
      for (const segment of segments){
          start = spanGaps ? start : segment.start;
          let prev = points[start % count];
          let style;
          for(i = start + 1; i <= segment.end; i++){
              const pt = points[i % count];
              style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                  type: 'segment',
                  p0: prev,
                  p1: pt,
                  p0DataIndex: (i - 1) % count,
                  p1DataIndex: i % count,
                  datasetIndex
              })));
              if (styleChanged(style, prevStyle)) {
                  addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
          }
          if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
          }
      }
      return result;
  }
  function readStyle(options) {
      return {
          backgroundColor: options.backgroundColor,
          borderCapStyle: options.borderCapStyle,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderJoinStyle: options.borderJoinStyle,
          borderWidth: options.borderWidth,
          borderColor: options.borderColor
      };
  }
  function styleChanged(style, prevStyle) {
      if (!prevStyle) {
          return false;
      }
      const cache = [];
      const replacer = function(key, value) {
          if (!isPatternOrGradient(value)) {
              return value;
          }
          if (!cache.includes(value)) {
              cache.push(value);
          }
          return cache.indexOf(value);
      };
      return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }
  /*!
   * Chart.js v4.4.7
   * https://www.chartjs.org
   * (c) 2024 Chart.js Contributors
   * Released under the MIT License
   */
  class Animator {
      constructor(){
          this._request = null;
          this._charts = new Map();
          this._running = false;
          this._lastDate = undefined;
      }
   _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach((fn)=>fn({
                  chart,
                  initial: anims.initial,
                  numSteps,
                  currentStep: Math.min(date - anims.start, numSteps)
              }));
      }
   _refresh() {
          if (this._request) {
              return;
          }
          this._running = true;
          this._request = requestAnimFrame.call(window, ()=>{
              this._update();
              this._request = null;
              if (this._running) {
                  this._refresh();
              }
          });
      }
   _update(date = Date.now()) {
          let remaining = 0;
          this._charts.forEach((anims, chart)=>{
              if (!anims.running || !anims.items.length) {
                  return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw = false;
              let item;
              for(; i >= 0; --i){
                  item = items[i];
                  if (item._active) {
                      if (item._total > anims.duration) {
                          anims.duration = item._total;
                      }
                      item.tick(date);
                      draw = true;
                  } else {
                      items[i] = items[items.length - 1];
                      items.pop();
                  }
              }
              if (draw) {
                  chart.draw();
                  this._notify(chart, anims, date, 'progress');
              }
              if (!items.length) {
                  anims.running = false;
                  this._notify(chart, anims, date, 'complete');
                  anims.initial = false;
              }
              remaining += items.length;
          });
          this._lastDate = date;
          if (remaining === 0) {
              this._running = false;
          }
      }
   _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
              anims = {
                  running: false,
                  initial: true,
                  items: [],
                  listeners: {
                      complete: [],
                      progress: []
                  }
              };
              charts.set(chart, anims);
          }
          return anims;
      }
   listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
      }
   add(chart, items) {
          if (!items || !items.length) {
              return;
          }
          this._getAnims(chart).items.push(...items);
      }
   has(chart) {
          return this._getAnims(chart).items.length > 0;
      }
   start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
              return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);
          this._refresh();
      }
      running(chart) {
          if (!this._running) {
              return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
              return false;
          }
          return true;
      }
   stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
              return;
          }
          const items = anims.items;
          let i = items.length - 1;
          for(; i >= 0; --i){
              items[i].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), 'complete');
      }
   remove(chart) {
          return this._charts.delete(chart);
      }
  }
  var animator = /* #__PURE__ */ new Animator();
  const transparent = 'transparent';
  const interpolators = {
      boolean (from, to, factor) {
          return factor > 0.5 ? to : from;
      },
   color (from, to, factor) {
          const c0 = color(from || transparent);
          const c1 = c0.valid && color(to || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
      },
      number (from, to, factor) {
          return from + (to - from) * factor;
      }
  };
  class Animation {
      constructor(cfg, target, prop, to){
          const currentValue = target[prop];
          to = resolve([
              cfg.to,
              to,
              currentValue,
              cfg.from
          ]);
          const from = resolve([
              cfg.from,
              currentValue,
              to
          ]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from];
          this._easing = effects[cfg.easing] || effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from;
          this._to = to;
          this._promises = undefined;
      }
      active() {
          return this._active;
      }
      update(cfg, to, date) {
          if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = resolve([
                  cfg.to,
                  to,
                  currentValue,
                  cfg.from
              ]);
              this._from = resolve([
                  cfg.from,
                  currentValue,
                  to
              ]);
          }
      }
      cancel() {
          if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
          }
      }
      tick(date) {
          const elapsed = date - this._start;
          const duration = this._duration;
          const prop = this._prop;
          const from = this._from;
          const loop = this._loop;
          const to = this._to;
          let factor;
          this._active = from !== to && (loop || elapsed < duration);
          if (!this._active) {
              this._target[prop] = to;
              this._notify(true);
              return;
          }
          if (elapsed < 0) {
              this._target[prop] = from;
              return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = this._easing(Math.min(1, Math.max(0, factor)));
          this._target[prop] = this._fn(from, to, factor);
      }
      wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej)=>{
              promises.push({
                  res,
                  rej
              });
          });
      }
      _notify(resolved) {
          const method = resolved ? 'res' : 'rej';
          const promises = this._promises || [];
          for(let i = 0; i < promises.length; i++){
              promises[i][method]();
          }
      }
  }
  class Animations {
      constructor(chart, config){
          this._chart = chart;
          this._properties = new Map();
          this.configure(config);
      }
      configure(config) {
          if (!isObject$1(config)) {
              return;
          }
          const animationOptions = Object.keys(defaults.animation);
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config).forEach((key)=>{
              const cfg = config[key];
              if (!isObject$1(cfg)) {
                  return;
              }
              const resolved = {};
              for (const option of animationOptions){
                  resolved[option] = cfg[option];
              }
              (isArray$1(cfg.properties) && cfg.properties || [
                  key
              ]).forEach((prop)=>{
                  if (prop === key || !animatedProps.has(prop)) {
                      animatedProps.set(prop, resolved);
                  }
              });
          });
      }
   _animateOptions(target, values) {
          const newOptions = values.options;
          const options = resolveTargetOptions(target, newOptions);
          if (!options) {
              return [];
          }
          const animations = this._createAnimations(options, newOptions);
          if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(()=>{
                  target.options = newOptions;
              }, ()=>{
              });
          }
          return animations;
      }
   _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i;
          for(i = props.length - 1; i >= 0; --i){
              const prop = props[i];
              if (prop.charAt(0) === '$') {
                  continue;
              }
              if (prop === 'options') {
                  animations.push(...this._animateOptions(target, values));
                  continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                  if (cfg && animation.active()) {
                      animation.update(cfg, value, date);
                      continue;
                  } else {
                      animation.cancel();
                  }
              }
              if (!cfg || !cfg.duration) {
                  target[prop] = value;
                  continue;
              }
              running[prop] = animation = new Animation(cfg, target, prop, value);
              animations.push(animation);
          }
          return animations;
      }
   update(target, values) {
          if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
              animator.add(this._chart, animations);
              return true;
          }
      }
  }
  function awaitAll(animations, properties) {
      const running = [];
      const keys = Object.keys(properties);
      for(let i = 0; i < keys.length; i++){
          const anim = animations[keys[i]];
          if (anim && anim.active()) {
              running.push(anim.wait());
          }
      }
      return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
      if (!newOptions) {
          return;
      }
      let options = target.options;
      if (!options) {
          target.options = newOptions;
          return;
      }
      if (options.$shared) {
          target.options = options = Object.assign({}, options, {
              $shared: false,
              $animations: {}
          });
      }
      return options;
  }
  function scaleClip(scale, allowedOverflow) {
      const opts = scale && scale.options || {};
      const reverse = opts.reverse;
      const min = opts.min === undefined ? allowedOverflow : 0;
      const max = opts.max === undefined ? allowedOverflow : 0;
      return {
          start: reverse ? max : min,
          end: reverse ? min : max
      };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
      if (allowedOverflow === false) {
          return false;
      }
      const x = scaleClip(xScale, allowedOverflow);
      const y = scaleClip(yScale, allowedOverflow);
      return {
          top: y.end,
          right: x.end,
          bottom: y.start,
          left: x.start
      };
  }
  function toClip(value) {
      let t, r, b, l;
      if (isObject$1(value)) {
          t = value.top;
          r = value.right;
          b = value.bottom;
          l = value.left;
      } else {
          t = r = b = l = value;
      }
      return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          disabled: value === false
      };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
      const keys = [];
      const metasets = chart._getSortedDatasetMetas(filterVisible);
      let i, ilen;
      for(i = 0, ilen = metasets.length; i < ilen; ++i){
          keys.push(metasets[i].index);
      }
      return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
      const keys = stack.keys;
      const singleMode = options.mode === 'single';
      let i, ilen, datasetIndex, otherValue;
      if (value === null) {
          return;
      }
      let found = false;
      for(i = 0, ilen = keys.length; i < ilen; ++i){
          datasetIndex = +keys[i];
          if (datasetIndex === dsIndex) {
              found = true;
              if (options.all) {
                  continue;
              }
              break;
          }
          otherValue = stack.values[datasetIndex];
          if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
              value += otherValue;
          }
      }
      if (!found && !options.all) {
          return 0;
      }
      return value;
  }
  function convertObjectDataToArray(data, meta) {
      const { iScale , vScale  } = meta;
      const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
      const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
      const keys = Object.keys(data);
      const adata = new Array(keys.length);
      let i, ilen, key;
      for(i = 0, ilen = keys.length; i < ilen; ++i){
          key = keys[i];
          adata[i] = {
              [iAxisKey]: key,
              [vAxisKey]: data[key]
          };
      }
      return adata;
  }
  function isStacked(scale, meta) {
      const stacked = scale && scale.options.stacked;
      return stacked || stacked === undefined && meta.stack !== undefined;
  }
  function getStackKey(indexScale, valueScale, meta) {
      return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
      const { min , max , minDefined , maxDefined  } = scale.getUserBounds();
      return {
          min: minDefined ? min : Number.NEGATIVE_INFINITY,
          max: maxDefined ? max : Number.POSITIVE_INFINITY
      };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
      const subStack = stacks[stackKey] || (stacks[stackKey] = {});
      return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
      for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){
          const value = stack[meta.index];
          if (positive && value > 0 || !positive && value < 0) {
              return meta.index;
          }
      }
      return null;
  }
  function updateStacks(controller, parsed) {
      const { chart , _cachedMeta: meta  } = controller;
      const stacks = chart._stacks || (chart._stacks = {});
      const { iScale , vScale , index: datasetIndex  } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const key = getStackKey(iScale, vScale, meta);
      const ilen = parsed.length;
      let stack;
      for(let i = 0; i < ilen; ++i){
          const item = parsed[i];
          const { [iAxis]: index , [vAxis]: value  } = item;
          const itemStacks = item._stacks || (item._stacks = {});
          stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
          stack[datasetIndex] = value;
          stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
          stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
          const visualValues = stack._visualValues || (stack._visualValues = {});
          visualValues[datasetIndex] = value;
      }
  }
  function getFirstScaleId(chart, axis) {
      const scales = chart.scales;
      return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index) {
      return createContext(parent, {
          active: false,
          dataset: undefined,
          datasetIndex: index,
          index,
          mode: 'default',
          type: 'dataset'
      });
  }
  function createDataContext(parent, index, element) {
      return createContext(parent, {
          active: false,
          dataIndex: index,
          parsed: undefined,
          raw: undefined,
          element,
          index,
          mode: 'default',
          type: 'data'
      });
  }
  function clearStacks(meta, items) {
      const datasetIndex = meta.controller.index;
      const axis = meta.vScale && meta.vScale.axis;
      if (!axis) {
          return;
      }
      items = items || meta._parsed;
      for (const parsed of items){
          const stacks = parsed._stacks;
          if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
              return;
          }
          delete stacks[axis][datasetIndex];
          if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {
              delete stacks[axis]._visualValues[datasetIndex];
          }
      }
  }
  const isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';
  const cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);
  const createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {
          keys: getSortedDatasetIndices(chart, true),
          values: null
      };
  class DatasetController {
   static defaults = {};
   static datasetElementType = null;
   static dataElementType = null;
   constructor(chart, datasetIndex){
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = undefined;
           this._parsing = false;
          this._data = undefined;
          this._objectData = undefined;
          this._sharedOptions = undefined;
          this._drawStart = undefined;
          this._drawCount = undefined;
          this.enableOptionSharing = false;
          this.supportsDecimation = false;
          this.$context = undefined;
          this._syncList = [];
          this.datasetElementType = new.target.datasetElementType;
          this.dataElementType = new.target.dataElementType;
          this.initialize();
      }
      initialize() {
          const meta = this._cachedMeta;
          this.configure();
          this.linkScales();
          meta._stacked = isStacked(meta.vScale, meta);
          this.addElements();
          if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
              console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
          }
      }
      updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
      }
      linkScales() {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;
          const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));
          const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));
          const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));
          const indexAxis = meta.indexAxis;
          const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta.xScale = this.getScaleForId(xid);
          meta.yScale = this.getScaleForId(yid);
          meta.rScale = this.getScaleForId(rid);
          meta.iScale = this.getScaleForId(iid);
          meta.vScale = this.getScaleForId(vid);
      }
      getDataset() {
          return this.chart.data.datasets[this.index];
      }
      getMeta() {
          return this.chart.getDatasetMeta(this.index);
      }
   getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
      }
   _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
      }
      reset() {
          this._update('reset');
      }
   _destroy() {
          const meta = this._cachedMeta;
          if (this._data) {
              unlistenArrayEvents(this._data, this);
          }
          if (meta._stacked) {
              clearStacks(meta);
          }
      }
   _dataCheck() {
          const dataset = this.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = this._data;
          if (isObject$1(data)) {
              const meta = this._cachedMeta;
              this._data = convertObjectDataToArray(data, meta);
          } else if (_data !== data) {
              if (_data) {
                  unlistenArrayEvents(_data, this);
                  const meta = this._cachedMeta;
                  clearStacks(meta);
                  meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                  listenArrayEvents(data, this);
              }
              this._syncList = [];
              this._data = data;
          }
      }
      addElements() {
          const meta = this._cachedMeta;
          this._dataCheck();
          if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
          }
      }
      buildOrUpdateElements(resetNewElements) {
          const meta = this._cachedMeta;
          const dataset = this.getDataset();
          let stackChanged = false;
          this._dataCheck();
          const oldStacked = meta._stacked;
          meta._stacked = isStacked(meta.vScale, meta);
          if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
          }
          this._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
              meta._stacked = isStacked(meta.vScale, meta);
          }
      }
   configure() {
          const config = this.chart.config;
          const scopeKeys = config.datasetScopeKeys(this._type);
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
          this.options = config.createResolver(scopes, this.getContext());
          this._parsing = this.options.parsing;
          this._cachedDataOpts = {};
      }
   parse(start, count) {
          const { _cachedMeta: meta , _data: data  } = this;
          const { iScale , _stacked  } = meta;
          const iAxis = iScale.axis;
          let sorted = start === 0 && count === data.length ? true : meta._sorted;
          let prev = start > 0 && meta._parsed[start - 1];
          let i, cur, parsed;
          if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
          } else {
              if (isArray$1(data[start])) {
                  parsed = this.parseArrayData(meta, data, start, count);
              } else if (isObject$1(data[start])) {
                  parsed = this.parseObjectData(meta, data, start, count);
              } else {
                  parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
              for(i = 0; i < count; ++i){
                  meta._parsed[i + start] = cur = parsed[i];
                  if (sorted) {
                      if (isNotInOrderComparedToPrev()) {
                          sorted = false;
                      }
                      prev = cur;
                  }
              }
              meta._sorted = sorted;
          }
          if (_stacked) {
              updateStacks(this, parsed);
          }
      }
   parsePrimitiveData(meta, data, start, count) {
          const { iScale , vScale  } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i, ilen, index;
          for(i = 0, ilen = count; i < ilen; ++i){
              index = i + start;
              parsed[i] = {
                  [iAxis]: singleScale || iScale.parse(labels[index], index),
                  [vAxis]: vScale.parse(data[index], index)
              };
          }
          return parsed;
      }
   parseArrayData(meta, data, start, count) {
          const { xScale , yScale  } = meta;
          const parsed = new Array(count);
          let i, ilen, index, item;
          for(i = 0, ilen = count; i < ilen; ++i){
              index = i + start;
              item = data[index];
              parsed[i] = {
                  x: xScale.parse(item[0], index),
                  y: yScale.parse(item[1], index)
              };
          }
          return parsed;
      }
   parseObjectData(meta, data, start, count) {
          const { xScale , yScale  } = meta;
          const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index, item;
          for(i = 0, ilen = count; i < ilen; ++i){
              index = i + start;
              item = data[index];
              parsed[i] = {
                  x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                  y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
              };
          }
          return parsed;
      }
   getParsed(index) {
          return this._cachedMeta._parsed[index];
      }
   getDataElement(index) {
          return this._cachedMeta.data[index];
      }
   applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const value = parsed[scale.axis];
          const stack = {
              keys: getSortedDatasetIndices(chart, true),
              values: parsed._stacks[scale.axis]._visualValues
          };
          return applyStack(stack, value, meta.index, {
              mode
          });
      }
   updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
          }
          range.min = Math.min(range.min, value);
          range.max = Math.max(range.max, value);
      }
   getMinMax(scale, canStack) {
          const meta = this._cachedMeta;
          const _parsed = meta._parsed;
          const sorted = meta._sorted && scale === meta.iScale;
          const ilen = _parsed.length;
          const otherScale = this._getOtherScale(scale);
          const stack = createStack(canStack, meta, this.chart);
          const range = {
              min: Number.POSITIVE_INFINITY,
              max: Number.NEGATIVE_INFINITY
          };
          const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);
          let i, parsed;
          function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
          }
          for(i = 0; i < ilen; ++i){
              if (_skip()) {
                  continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              if (sorted) {
                  break;
              }
          }
          if (sorted) {
              for(i = ilen - 1; i >= 0; --i){
                  if (_skip()) {
                      continue;
                  }
                  this.updateRangeFromParsed(range, scale, parsed, stack);
                  break;
              }
          }
          return range;
      }
      getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i, ilen, value;
          for(i = 0, ilen = parsed.length; i < ilen; ++i){
              value = parsed[i][scale.axis];
              if (isNumberFinite(value)) {
                  values.push(value);
              }
          }
          return values;
      }
   getMaxOverflow() {
          return false;
      }
   getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const parsed = this.getParsed(index);
          return {
              label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
              value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
          };
      }
   _update(mode) {
          const meta = this._cachedMeta;
          this.update(mode || 'default');
          meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
      }
   update(mode) {}
      draw() {
          const ctx = this._ctx;
          const chart = this.chart;
          const meta = this._cachedMeta;
          const elements = meta.data || [];
          const area = chart.chartArea;
          const active = [];
          const start = this._drawStart || 0;
          const count = this._drawCount || elements.length - start;
          const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
          let i;
          if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
          }
          for(i = start; i < start + count; ++i){
              const element = elements[i];
              if (element.hidden) {
                  continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                  active.push(element);
              } else {
                  element.draw(ctx, area);
              }
          }
          for(i = 0; i < active.length; ++i){
              active[i].draw(ctx, area);
          }
      }
   getStyle(index, active) {
          const mode = active ? 'active' : 'default';
          return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
      }
   getContext(index, active, mode) {
          const dataset = this.getDataset();
          let context;
          if (index >= 0 && index < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index];
              context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
              context.parsed = this.getParsed(index);
              context.raw = dataset.data[index];
              context.index = context.dataIndex = index;
          } else {
              context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
          }
          context.active = !!active;
          context.mode = mode;
          return context;
      }
   resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
      }
   resolveDataElementOptions(index, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index);
      }
   _resolveElementOptions(elementType, mode = 'default', index) {
          const active = mode === 'active';
          const cache = this._cachedDataOpts;
          const cacheKey = elementType + '-' + mode;
          const cached = cache[cacheKey];
          const sharing = this.enableOptionSharing && defined(index);
          if (cached) {
              return cloneIfNotShared(cached, sharing);
          }
          const config = this.chart.config;
          const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
          const prefixes = active ? [
              `${elementType}Hover`,
              'hover',
              elementType,
              ''
          ] : [
              elementType,
              ''
          ];
          const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
          const names = Object.keys(defaults.elements[elementType]);
          const context = ()=>this.getContext(index, active, mode);
          const values = config.resolveNamedOptions(scopes, names, context, prefixes);
          if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
      }
   _resolveAnimations(index, transition, active) {
          const chart = this.chart;
          const cache = this._cachedDataOpts;
          const cacheKey = `animation-${transition}`;
          const cached = cache[cacheKey];
          if (cached) {
              return cached;
          }
          let options;
          if (chart.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
              const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
              options = config.createResolver(scopes, this.getContext(index, active, transition));
          }
          const animations = new Animations(chart, options && options.animations);
          if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
          }
          return animations;
      }
   getSharedOptions(options) {
          if (!options.$shared) {
              return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
      }
   includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
      }
   _getSharedOptions(start, mode) {
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const previouslySharedOptions = this._sharedOptions;
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
          return {
              sharedOptions,
              includeOptions
          };
      }
   updateElement(element, index, properties, mode) {
          if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
          } else {
              this._resolveAnimations(index, mode).update(element, properties);
          }
      }
   updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
          }
      }
   _setStyle(element, index, mode, active) {
          element.active = active;
          const options = this.getStyle(index, active);
          this._resolveAnimations(index, mode, active).update(element, {
              options: !active && this.getSharedOptions(options) || options
          });
      }
      removeHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, 'active', false);
      }
      setHoverStyle(element, datasetIndex, index) {
          this._setStyle(element, index, 'active', true);
      }
   _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
              this._setStyle(element, undefined, 'active', false);
          }
      }
   _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
              this._setStyle(element, undefined, 'active', true);
          }
      }
   _resyncElements(resetNewElements) {
          const data = this._data;
          const elements = this._cachedMeta.data;
          for (const [method, arg1, arg2] of this._syncList){
              this[method](arg1, arg2);
          }
          this._syncList = [];
          const numMeta = elements.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (count) {
              this.parse(0, count);
          }
          if (numData > numMeta) {
              this._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
          }
      }
   _insertElements(start, count, resetNewElements = true) {
          const meta = this._cachedMeta;
          const data = meta.data;
          const end = start + count;
          let i;
          const move = (arr)=>{
              arr.length += count;
              for(i = arr.length - 1; i >= end; i--){
                  arr[i] = arr[i - count];
              }
          };
          move(data);
          for(i = start; i < end; ++i){
              data[i] = new this.dataElementType();
          }
          if (this._parsing) {
              move(meta._parsed);
          }
          this.parse(start, count);
          if (resetNewElements) {
              this.updateElements(data, start, count, 'reset');
          }
      }
      updateElements(element, start, count, mode) {}
   _removeElements(start, count) {
          const meta = this._cachedMeta;
          if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                  clearStacks(meta, removed);
              }
          }
          meta.data.splice(start, count);
      }
   _sync(args) {
          if (this._parsing) {
              this._syncList.push(args);
          } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
          }
          this.chart._dataChanges.push([
              this.index,
              ...args
          ]);
      }
      _onDataPush() {
          const count = arguments.length;
          this._sync([
              '_insertElements',
              this.getDataset().data.length - count,
              count
          ]);
      }
      _onDataPop() {
          this._sync([
              '_removeElements',
              this._cachedMeta.data.length - 1,
              1
          ]);
      }
      _onDataShift() {
          this._sync([
              '_removeElements',
              0,
              1
          ]);
      }
      _onDataSplice(start, count) {
          if (count) {
              this._sync([
                  '_removeElements',
                  start,
                  count
              ]);
          }
          const newCount = arguments.length - 2;
          if (newCount) {
              this._sync([
                  '_insertElements',
                  start,
                  newCount
              ]);
          }
      }
      _onDataUnshift() {
          this._sync([
              '_insertElements',
              0,
              arguments.length
          ]);
      }
  }
  function getAllScaleValues(scale, type) {
      if (!scale._cache.$bar) {
          const visibleMetas = scale.getMatchingVisibleMetas(type);
          let values = [];
          for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){
              values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
          }
          scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));
      }
      return scale._cache.$bar;
  }
   function computeMinSampleSize(meta) {
      const scale = meta.iScale;
      const values = getAllScaleValues(scale, meta.type);
      let min = scale._length;
      let i, ilen, curr, prev;
      const updateMinAndPrev = ()=>{
          if (curr === 32767 || curr === -32768) {
              return;
          }
          if (defined(prev)) {
              min = Math.min(min, Math.abs(curr - prev) || min);
          }
          prev = curr;
      };
      for(i = 0, ilen = values.length; i < ilen; ++i){
          curr = scale.getPixelForValue(values[i]);
          updateMinAndPrev();
      }
      prev = undefined;
      for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){
          curr = scale.getPixelForTick(i);
          updateMinAndPrev();
      }
      return min;
  }
   function computeFitCategoryTraits(index, ruler, options, stackCount) {
      const thickness = options.barThickness;
      let size, ratio;
      if (isNullOrUndef(thickness)) {
          size = ruler.min * options.categoryPercentage;
          ratio = options.barPercentage;
      } else {
          size = thickness * stackCount;
          ratio = 1;
      }
      return {
          chunk: size / stackCount,
          ratio,
          start: ruler.pixels[index] - size / 2
      };
  }
   function computeFlexCategoryTraits(index, ruler, options, stackCount) {
      const pixels = ruler.pixels;
      const curr = pixels[index];
      let prev = index > 0 ? pixels[index - 1] : null;
      let next = index < pixels.length - 1 ? pixels[index + 1] : null;
      const percent = options.categoryPercentage;
      if (prev === null) {
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
      }
      if (next === null) {
          next = curr + curr - prev;
      }
      const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
      const size = Math.abs(next - prev) / 2 * percent;
      return {
          chunk: size / stackCount,
          ratio: options.barPercentage,
          start
      };
  }
  function parseFloatBar(entry, item, vScale, i) {
      const startValue = vScale.parse(entry[0], i);
      const endValue = vScale.parse(entry[1], i);
      const min = Math.min(startValue, endValue);
      const max = Math.max(startValue, endValue);
      let barStart = min;
      let barEnd = max;
      if (Math.abs(min) > Math.abs(max)) {
          barStart = max;
          barEnd = min;
      }
      item[vScale.axis] = barEnd;
      item._custom = {
          barStart,
          barEnd,
          start: startValue,
          end: endValue,
          min,
          max
      };
  }
  function parseValue(entry, item, vScale, i) {
      if (isArray$1(entry)) {
          parseFloatBar(entry, item, vScale, i);
      } else {
          item[vScale.axis] = vScale.parse(entry, i);
      }
      return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = [];
      let i, ilen, item, entry;
      for(i = start, ilen = start + count; i < ilen; ++i){
          entry = data[i];
          item = {};
          item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
          parsed.push(parseValue(entry, item, vScale, i));
      }
      return parsed;
  }
  function isFloatBar(custom) {
      return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
  }
  function barSign(size, vScale, actualBase) {
      if (size !== 0) {
          return sign(size);
      }
      return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
      let reverse, start, end, top, bottom;
      if (properties.horizontal) {
          reverse = properties.base > properties.x;
          start = 'left';
          end = 'right';
      } else {
          reverse = properties.base < properties.y;
          start = 'bottom';
          end = 'top';
      }
      if (reverse) {
          top = 'end';
          bottom = 'start';
      } else {
          top = 'start';
          bottom = 'end';
      }
      return {
          start,
          end,
          reverse,
          top,
          bottom
      };
  }
  function setBorderSkipped(properties, options, stack, index) {
      let edge = options.borderSkipped;
      const res = {};
      if (!edge) {
          properties.borderSkipped = res;
          return;
      }
      if (edge === true) {
          properties.borderSkipped = {
              top: true,
              right: true,
              bottom: true,
              left: true
          };
          return;
      }
      const { start , end , reverse , top , bottom  } = borderProps(properties);
      if (edge === 'middle' && stack) {
          properties.enableBorderRadius = true;
          if ((stack._top || 0) === index) {
              edge = top;
          } else if ((stack._bottom || 0) === index) {
              edge = bottom;
          } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
          }
      }
      res[parseEdge(edge, start, end, reverse)] = true;
      properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
      if (reverse) {
          edge = swap(edge, a, b);
          edge = startEnd(edge, b, a);
      } else {
          edge = startEnd(edge, a, b);
      }
      return edge;
  }
  function swap(orig, v1, v2) {
      return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
      return v === 'start' ? start : v === 'end' ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount  }, ratio) {
      properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  class BarController extends DatasetController {
      static id = 'bar';
   static defaults = {
          datasetElementType: false,
          dataElementType: 'bar',
          categoryPercentage: 0.8,
          barPercentage: 0.9,
          grouped: true,
          animations: {
              numbers: {
                  type: 'number',
                  properties: [
                      'x',
                      'y',
                      'base',
                      'width',
                      'height'
                  ]
              }
          }
      };
   static overrides = {
          scales: {
              _index_: {
                  type: 'category',
                  offset: true,
                  grid: {
                      offset: true
                  }
              },
              _value_: {
                  type: 'linear',
                  beginAtZero: true
              }
          }
      };
   parsePrimitiveData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
      }
   parseArrayData(meta, data, start, count) {
          return parseArrayOrPrimitive(meta, data, start, count);
      }
   parseObjectData(meta, data, start, count) {
          const { iScale , vScale  } = meta;
          const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;
          const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
          const parsed = [];
          let i, ilen, item, obj;
          for(i = start, ilen = start + count; i < ilen; ++i){
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
              parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
          }
          return parsed;
      }
   updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
              range.min = Math.min(range.min, custom.min);
              range.max = Math.max(range.max, custom.max);
          }
      }
   getMaxOverflow() {
          return 0;
      }
   getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const { iScale , vScale  } = meta;
          const parsed = this.getParsed(index);
          const custom = parsed._custom;
          const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
              label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
              value
          };
      }
      initialize() {
          this.enableOptionSharing = true;
          super.initialize();
          const meta = this._cachedMeta;
          meta.stack = this.getDataset().stack;
      }
      update(mode) {
          const meta = this._cachedMeta;
          this.updateElements(meta.data, 0, meta.data.length, mode);
      }
      updateElements(bars, start, count, mode) {
          const reset = mode === 'reset';
          const { index , _cachedMeta: { vScale  }  } = this;
          const base = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = this._getRuler();
          const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
          for(let i = start; i < start + count; i++){
              const parsed = this.getParsed(i);
              const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                  base,
                  head: base
              } : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                  horizontal,
                  base: vpixels.base,
                  enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                  x: horizontal ? vpixels.head : ipixels.center,
                  y: horizontal ? ipixels.center : vpixels.head,
                  height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                  width: horizontal ? Math.abs(vpixels.size) : ipixels.size
              };
              if (includeOptions) {
                  properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
          }
      }
   _getStacks(last, dataIndex) {
          const { iScale  } = this._cachedMeta;
          const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);
          const stacked = iScale.options.stacked;
          const stacks = [];
          const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
          const iScaleValue = currentParsed && currentParsed[iScale.axis];
          const skipNull = (meta)=>{
              const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);
              const val = parsed && parsed[meta.vScale.axis];
              if (isNullOrUndef(val) || isNaN(val)) {
                  return true;
              }
          };
          for (const meta of metasets){
              if (dataIndex !== undefined && skipNull(meta)) {
                  continue;
              }
              if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
                  stacks.push(meta.stack);
              }
              if (meta.index === last) {
                  break;
              }
          }
          if (!stacks.length) {
              stacks.push(undefined);
          }
          return stacks;
      }
   _getStackCount(index) {
          return this._getStacks(undefined, index).length;
      }
   _getStackIndex(datasetIndex, name, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index = name !== undefined ? stacks.indexOf(name) : -1;
          return index === -1 ? stacks.length - 1 : index;
      }
   _getRuler() {
          const opts = this.options;
          const meta = this._cachedMeta;
          const iScale = meta.iScale;
          const pixels = [];
          let i, ilen;
          for(i = 0, ilen = meta.data.length; i < ilen; ++i){
              pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(meta);
          return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
      }
   _calculateBarValuePixels(index) {
          const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;
          const actualBase = baseValue || 0;
          const parsed = this.getParsed(index);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value = parsed[vScale.axis];
          let start = 0;
          let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
          let head, size;
          if (length !== value) {
              start = length - value;
              length = value;
          }
          if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
                  start = 0;
              }
              start += value;
          }
          const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
          let base = vScale.getPixelForValue(startValue);
          if (this.chart.getDataVisibility(index)) {
              head = vScale.getPixelForValue(start + length);
          } else {
              head = base;
          }
          size = head - base;
          if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                  base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
              if (_stacked && !floating) {
                  parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
              }
          }
          if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
              base += halfGrid;
              size -= halfGrid;
          }
          return {
              size,
              base,
              head,
              center: head + size / 2
          };
      }
   _calculateBarIndexPixels(index, ruler) {
          const scale = ruler.scale;
          const options = this.options;
          const skipNull = options.skipNull;
          const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
              const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
              const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);
              center = range.start + range.chunk * stackIndex + range.chunk / 2;
              size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
              center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size
          };
      }
      draw() {
          const meta = this._cachedMeta;
          const vScale = meta.vScale;
          const rects = meta.data;
          const ilen = rects.length;
          let i = 0;
          for(; i < ilen; ++i){
              if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                  rects[i].draw(this._ctx);
              }
          }
      }
  }
  class BubbleController extends DatasetController {
      static id = 'bubble';
   static defaults = {
          datasetElementType: false,
          dataElementType: 'point',
          animations: {
              numbers: {
                  type: 'number',
                  properties: [
                      'x',
                      'y',
                      'borderWidth',
                      'radius'
                  ]
              }
          }
      };
   static overrides = {
          scales: {
              x: {
                  type: 'linear'
              },
              y: {
                  type: 'linear'
              }
          }
      };
      initialize() {
          this.enableOptionSharing = true;
          super.initialize();
      }
   parsePrimitiveData(meta, data, start, count) {
          const parsed = super.parsePrimitiveData(meta, data, start, count);
          for(let i = 0; i < parsed.length; i++){
              parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
          }
          return parsed;
      }
   parseArrayData(meta, data, start, count) {
          const parsed = super.parseArrayData(meta, data, start, count);
          for(let i = 0; i < parsed.length; i++){
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
      }
   parseObjectData(meta, data, start, count) {
          const parsed = super.parseObjectData(meta, data, start, count);
          for(let i = 0; i < parsed.length; i++){
              const item = data[start + i];
              parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
          }
          return parsed;
      }
   getMaxOverflow() {
          const data = this._cachedMeta.data;
          let max = 0;
          for(let i = data.length - 1; i >= 0; --i){
              max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
          }
          return max > 0 && max;
      }
   getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const labels = this.chart.data.labels || [];
          const { xScale , yScale  } = meta;
          const parsed = this.getParsed(index);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
              label: labels[index] || '',
              value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
          };
      }
      update(mode) {
          const points = this._cachedMeta.data;
          this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
          const reset = mode === 'reset';
          const { iScale , vScale  } = this._cachedMeta;
          const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for(let i = start; i < start + count; i++){
              const point = points[i];
              const parsed = !reset && this.getParsed(i);
              const properties = {};
              const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
              const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                  properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
                  if (reset) {
                      properties.options.radius = 0;
                  }
              }
              this.updateElement(point, i, properties, mode);
          }
      }
   resolveDataElementOptions(index, mode) {
          const parsed = this.getParsed(index);
          let values = super.resolveDataElementOptions(index, mode);
          if (values.$shared) {
              values = Object.assign({}, values, {
                  $shared: false
              });
          }
          const radius = values.radius;
          if (mode !== 'active') {
              values.radius = 0;
          }
          values.radius += valueOrDefault(parsed && parsed._custom, radius);
          return values;
      }
  }
  function getRatioAndOffset(rotation, circumference, cutout) {
      let ratioX = 1;
      let ratioY = 1;
      let offsetX = 0;
      let offsetY = 0;
      if (circumference < TAU) {
          const startAngle = rotation;
          const endAngle = startAngle + circumference;
          const startX = Math.cos(startAngle);
          const startY = Math.sin(startAngle);
          const endX = Math.cos(endAngle);
          const endY = Math.sin(endAngle);
          const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
          const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
          const maxX = calcMax(0, startX, endX);
          const maxY = calcMax(HALF_PI, startY, endY);
          const minX = calcMin(PI, startX, endX);
          const minY = calcMin(PI + HALF_PI, startY, endY);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
      }
      return {
          ratioX,
          ratioY,
          offsetX,
          offsetY
      };
  }
  class DoughnutController extends DatasetController {
      static id = 'doughnut';
   static defaults = {
          datasetElementType: false,
          dataElementType: 'arc',
          animation: {
              animateRotate: true,
              animateScale: false
          },
          animations: {
              numbers: {
                  type: 'number',
                  properties: [
                      'circumference',
                      'endAngle',
                      'innerRadius',
                      'outerRadius',
                      'startAngle',
                      'x',
                      'y',
                      'offset',
                      'borderWidth',
                      'spacing'
                  ]
              }
          },
          cutout: '50%',
          rotation: 0,
          circumference: 360,
          radius: '100%',
          spacing: 0,
          indexAxis: 'r'
      };
      static descriptors = {
          _scriptable: (name)=>name !== 'spacing',
          _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')
      };
   static overrides = {
          aspectRatio: 1,
          plugins: {
              legend: {
                  labels: {
                      generateLabels (chart) {
                          const data = chart.data;
                          if (data.labels.length && data.datasets.length) {
                              const { labels: { pointStyle , color  }  } = chart.legend.options;
                              return data.labels.map((label, i)=>{
                                  const meta = chart.getDatasetMeta(0);
                                  const style = meta.controller.getStyle(i);
                                  return {
                                      text: label,
                                      fillStyle: style.backgroundColor,
                                      strokeStyle: style.borderColor,
                                      fontColor: color,
                                      lineWidth: style.borderWidth,
                                      pointStyle: pointStyle,
                                      hidden: !chart.getDataVisibility(i),
                                      index: i
                                  };
                              });
                          }
                          return [];
                      }
                  },
                  onClick (e, legendItem, legend) {
                      legend.chart.toggleDataVisibility(legendItem.index);
                      legend.chart.update();
                  }
              }
          }
      };
      constructor(chart, datasetIndex){
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = undefined;
          this.outerRadius = undefined;
          this.offsetX = undefined;
          this.offsetY = undefined;
      }
      linkScales() {}
   parse(start, count) {
          const data = this.getDataset().data;
          const meta = this._cachedMeta;
          if (this._parsing === false) {
              meta._parsed = data;
          } else {
              let getter = (i)=>+data[i];
              if (isObject$1(data[start])) {
                  const { key ='value'  } = this._parsing;
                  getter = (i)=>+resolveObjectKey(data[i], key);
              }
              let i, ilen;
              for(i = start, ilen = start + count; i < ilen; ++i){
                  meta._parsed[i] = getter(i);
              }
          }
      }
   _getRotation() {
          return toRadians(this.options.rotation - 90);
      }
   _getCircumference() {
          return toRadians(this.options.circumference);
      }
   _getRotationExtents() {
          let min = TAU;
          let max = -TAU;
          for(let i = 0; i < this.chart.data.datasets.length; ++i){
              if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                  const controller = this.chart.getDatasetMeta(i).controller;
                  const rotation = controller._getRotation();
                  const circumference = controller._getCircumference();
                  min = Math.min(min, rotation);
                  max = Math.max(max, rotation + circumference);
              }
          }
          return {
              rotation: min,
              circumference: max - min
          };
      }
   update(mode) {
          const chart = this.chart;
          const { chartArea  } = chart;
          const meta = this._cachedMeta;
          const arcs = meta.data;
          const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
          const chartWeight = this._getRingWeight(this.index);
          const { circumference , rotation  } = this._getRotationExtents();
          const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = toDimension(this.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
          this.offsetX = offsetX * outerRadius;
          this.offsetY = offsetY * outerRadius;
          meta.total = this.calculateTotal();
          this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
          this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
          this.updateElements(arcs, 0, arcs.length, mode);
      }
   _circumference(i, reset) {
          const opts = this.options;
          const meta = this._cachedMeta;
          const circumference = this._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
              return 0;
          }
          return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
      }
      updateElements(arcs, start, count, mode) {
          const reset = mode === 'reset';
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : this.innerRadius;
          const outerRadius = animateScale ? 0 : this.outerRadius;
          const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
          let startAngle = this._getRotation();
          let i;
          for(i = 0; i < start; ++i){
              startAngle += this._circumference(i, reset);
          }
          for(i = start; i < start + count; ++i){
              const circumference = this._circumference(i, reset);
              const arc = arcs[i];
              const properties = {
                  x: centerX + this.offsetX,
                  y: centerY + this.offsetY,
                  startAngle,
                  endAngle: startAngle + circumference,
                  circumference,
                  outerRadius,
                  innerRadius
              };
              if (includeOptions) {
                  properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
          }
      }
      calculateTotal() {
          const meta = this._cachedMeta;
          const metaData = meta.data;
          let total = 0;
          let i;
          for(i = 0; i < metaData.length; i++){
              const value = meta._parsed[i];
              if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
                  total += Math.abs(value);
              }
          }
          return total;
      }
      calculateCircumference(value) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value)) {
              return TAU * (Math.abs(value) / total);
          }
          return 0;
      }
      getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index], chart.options.locale);
          return {
              label: labels[index] || '',
              value
          };
      }
      getMaxBorderWidth(arcs) {
          let max = 0;
          const chart = this.chart;
          let i, ilen, meta, controller, options;
          if (!arcs) {
              for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){
                  if (chart.isDatasetVisible(i)) {
                      meta = chart.getDatasetMeta(i);
                      arcs = meta.data;
                      controller = meta.controller;
                      break;
                  }
              }
          }
          if (!arcs) {
              return 0;
          }
          for(i = 0, ilen = arcs.length; i < ilen; ++i){
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== 'inner') {
                  max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
              }
          }
          return max;
      }
      getMaxOffset(arcs) {
          let max = 0;
          for(let i = 0, ilen = arcs.length; i < ilen; ++i){
              const options = this.resolveDataElementOptions(i);
              max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
          }
          return max;
      }
   _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for(let i = 0; i < datasetIndex; ++i){
              if (this.chart.isDatasetVisible(i)) {
                  ringWeightOffset += this._getRingWeight(i);
              }
          }
          return ringWeightOffset;
      }
   _getRingWeight(datasetIndex) {
          return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
      }
   _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
      }
  }
  class LineController extends DatasetController {
      static id = 'line';
   static defaults = {
          datasetElementType: 'line',
          dataElementType: 'point',
          showLine: true,
          spanGaps: false
      };
   static overrides = {
          scales: {
              _index_: {
                  type: 'category'
              },
              _value_: {
                  type: 'linear'
              }
          }
      };
      initialize() {
          this.enableOptionSharing = true;
          this.supportsDecimation = true;
          super.initialize();
      }
      update(mode) {
          const meta = this._cachedMeta;
          const { dataset: line , data: points = [] , _dataset  } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
          }
          line._chart = this.chart;
          line._datasetIndex = this.index;
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options = this.resolveDatasetElementOptions(mode);
          if (!this.options.showLine) {
              options.borderWidth = 0;
          }
          options.segment = this.options.segment;
          this.updateElement(line, undefined, {
              animated: !animationsDisabled,
              options
          }, mode);
          this.updateElements(points, start, count, mode);
      }
      updateElements(points, start, count, mode) {
          const reset = mode === 'reset';
          const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
          const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps , segment  } = this.options;
          const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
          const end = start + count;
          const pointsCount = points.length;
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for(let i = 0; i < pointsCount; ++i){
              const point = points[i];
              const properties = directUpdate ? point : {};
              if (i < start || i >= end) {
                  properties.skip = true;
                  continue;
              }
              const parsed = this.getParsed(i);
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                  properties.parsed = parsed;
                  properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                  properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
              }
              if (!directUpdate) {
                  this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
          }
      }
   getMaxOverflow() {
          const meta = this._cachedMeta;
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta.data || [];
          if (!data.length) {
              return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
      }
      draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
          super.draw();
      }
  }
  class PolarAreaController extends DatasetController {
      static id = 'polarArea';
   static defaults = {
          dataElementType: 'arc',
          animation: {
              animateRotate: true,
              animateScale: true
          },
          animations: {
              numbers: {
                  type: 'number',
                  properties: [
                      'x',
                      'y',
                      'startAngle',
                      'endAngle',
                      'innerRadius',
                      'outerRadius'
                  ]
              }
          },
          indexAxis: 'r',
          startAngle: 0
      };
   static overrides = {
          aspectRatio: 1,
          plugins: {
              legend: {
                  labels: {
                      generateLabels (chart) {
                          const data = chart.data;
                          if (data.labels.length && data.datasets.length) {
                              const { labels: { pointStyle , color  }  } = chart.legend.options;
                              return data.labels.map((label, i)=>{
                                  const meta = chart.getDatasetMeta(0);
                                  const style = meta.controller.getStyle(i);
                                  return {
                                      text: label,
                                      fillStyle: style.backgroundColor,
                                      strokeStyle: style.borderColor,
                                      fontColor: color,
                                      lineWidth: style.borderWidth,
                                      pointStyle: pointStyle,
                                      hidden: !chart.getDataVisibility(i),
                                      index: i
                                  };
                              });
                          }
                          return [];
                      }
                  },
                  onClick (e, legendItem, legend) {
                      legend.chart.toggleDataVisibility(legendItem.index);
                      legend.chart.update();
                  }
              }
          },
          scales: {
              r: {
                  type: 'radialLinear',
                  angleLines: {
                      display: false
                  },
                  beginAtZero: true,
                  grid: {
                      circular: true
                  },
                  pointLabels: {
                      display: false
                  },
                  startAngle: 0
              }
          }
      };
      constructor(chart, datasetIndex){
          super(chart, datasetIndex);
          this.innerRadius = undefined;
          this.outerRadius = undefined;
      }
      getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const chart = this.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index].r, chart.options.locale);
          return {
              label: labels[index] || '',
              value
          };
      }
      parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
      }
      update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
      }
   getMinMax() {
          const meta = this._cachedMeta;
          const range = {
              min: Number.POSITIVE_INFINITY,
              max: Number.NEGATIVE_INFINITY
          };
          meta.data.forEach((element, index)=>{
              const parsed = this.getParsed(index).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                  if (parsed < range.min) {
                      range.min = parsed;
                  }
                  if (parsed > range.max) {
                      range.max = parsed;
                  }
              }
          });
          return range;
      }
   _updateRadius() {
          const chart = this.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          this.outerRadius = outerRadius - radiusLength * this.index;
          this.innerRadius = this.outerRadius - radiusLength;
      }
      updateElements(arcs, start, count, mode) {
          const reset = mode === 'reset';
          const chart = this.chart;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = this._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
          let angle = datasetStartAngle;
          let i;
          const defaultAngle = 360 / this.countVisibleElements();
          for(i = 0; i < start; ++i){
              angle += this._computeAngle(i, mode, defaultAngle);
          }
          for(i = start; i < start + count; i++){
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
              angle = endAngle;
              if (reset) {
                  if (animationOpts.animateScale) {
                      outerRadius = 0;
                  }
                  if (animationOpts.animateRotate) {
                      startAngle = endAngle = datasetStartAngle;
                  }
              }
              const properties = {
                  x: centerX,
                  y: centerY,
                  innerRadius: 0,
                  outerRadius,
                  startAngle,
                  endAngle,
                  options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)
              };
              this.updateElement(arc, i, properties, mode);
          }
      }
      countVisibleElements() {
          const meta = this._cachedMeta;
          let count = 0;
          meta.data.forEach((element, index)=>{
              if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {
                  count++;
              }
          });
          return count;
      }
   _computeAngle(index, mode, defaultAngle) {
          return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
      }
  }
  class PieController extends DoughnutController {
      static id = 'pie';
   static defaults = {
          cutout: 0,
          rotation: 0,
          circumference: 360,
          radius: '100%'
      };
  }
  class RadarController extends DatasetController {
      static id = 'radar';
   static defaults = {
          datasetElementType: 'line',
          dataElementType: 'point',
          indexAxis: 'r',
          showLine: true,
          elements: {
              line: {
                  fill: 'start'
              }
          }
      };
   static overrides = {
          aspectRatio: 1,
          scales: {
              r: {
                  type: 'radialLinear'
              }
          }
      };
   getLabelAndValue(index) {
          const vScale = this._cachedMeta.vScale;
          const parsed = this.getParsed(index);
          return {
              label: vScale.getLabels()[index],
              value: '' + vScale.getLabelForValue(parsed[vScale.axis])
          };
      }
      parseObjectData(meta, data, start, count) {
          return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
      }
      update(mode) {
          const meta = this._cachedMeta;
          const line = meta.dataset;
          const points = meta.data || [];
          const labels = meta.iScale.getLabels();
          line.points = points;
          if (mode !== 'resize') {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                  options.borderWidth = 0;
              }
              const properties = {
                  _loop: true,
                  _fullLoop: labels.length === points.length,
                  options
              };
              this.updateElement(line, undefined, properties, mode);
          }
          this.updateElements(points, 0, points.length, mode);
      }
      updateElements(points, start, count, mode) {
          const scale = this._cachedMeta.rScale;
          const reset = mode === 'reset';
          for(let i = start; i < start + count; i++){
              const point = points[i];
              const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);
              const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
              const x = reset ? scale.xCenter : pointPosition.x;
              const y = reset ? scale.yCenter : pointPosition.y;
              const properties = {
                  x,
                  y,
                  angle: pointPosition.angle,
                  skip: isNaN(x) || isNaN(y),
                  options
              };
              this.updateElement(point, i, properties, mode);
          }
      }
  }
  class ScatterController extends DatasetController {
      static id = 'scatter';
   static defaults = {
          datasetElementType: false,
          dataElementType: 'point',
          showLine: false,
          fill: false
      };
   static overrides = {
          interaction: {
              mode: 'point'
          },
          scales: {
              x: {
                  type: 'linear'
              },
              y: {
                  type: 'linear'
              }
          }
      };
   getLabelAndValue(index) {
          const meta = this._cachedMeta;
          const labels = this.chart.data.labels || [];
          const { xScale , yScale  } = meta;
          const parsed = this.getParsed(index);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          return {
              label: labels[index] || '',
              value: '(' + x + ', ' + y + ')'
          };
      }
      update(mode) {
          const meta = this._cachedMeta;
          const { data: points = []  } = meta;
          const animationsDisabled = this.chart._animationsDisabled;
          let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          this._drawStart = start;
          this._drawCount = count;
          if (_scaleRangesChanged(meta)) {
              start = 0;
              count = points.length;
          }
          if (this.options.showLine) {
              if (!this.datasetElementType) {
                  this.addElements();
              }
              const { dataset: line , _dataset  } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(line, undefined, {
                  animated: !animationsDisabled,
                  options
              }, mode);
          } else if (this.datasetElementType) {
              delete meta.dataset;
              this.datasetElementType = false;
          }
          this.updateElements(points, start, count, mode);
      }
      addElements() {
          const { showLine  } = this.options;
          if (!this.datasetElementType && showLine) {
              this.datasetElementType = this.chart.registry.getElement('line');
          }
          super.addElements();
      }
      updateElements(points, start, count, mode) {
          const reset = mode === 'reset';
          const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;
          const firstOpts = this.resolveDataElementOptions(start, mode);
          const sharedOptions = this.getSharedOptions(firstOpts);
          const includeOptions = this.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const { spanGaps , segment  } = this.options;
          const maxGapLength = isNumber$1(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';
          let prevParsed = start > 0 && this.getParsed(start - 1);
          for(let i = start; i < start + count; ++i){
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = isNullOrUndef(parsed[vAxis]);
              const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
              const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                  properties.parsed = parsed;
                  properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                  properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);
              }
              if (!directUpdate) {
                  this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
          }
          this.updateSharedOptions(sharedOptions, mode, firstOpts);
      }
   getMaxOverflow() {
          const meta = this._cachedMeta;
          const data = meta.data || [];
          if (!this.options.showLine) {
              let max = 0;
              for(let i = data.length - 1; i >= 0; --i){
                  max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
              }
              return max > 0 && max;
          }
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          if (!data.length) {
              return border;
          }
          const firstPoint = data[0].size(this.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
      }
  }
  var controllers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  BarController: BarController,
  BubbleController: BubbleController,
  DoughnutController: DoughnutController,
  LineController: LineController,
  PieController: PieController,
  PolarAreaController: PolarAreaController,
  RadarController: RadarController,
  ScatterController: ScatterController
  });
  /**
   * @namespace Chart._adapters
   * @since 2.8.0
   * @private
   */ function abstract() {
      throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
  }
  /**
   * Date adapter (current used by the time scale)
   * @namespace Chart._adapters._date
   * @memberof Chart._adapters
   * @private
   */ class DateAdapterBase {
      /**
     * Override default date adapter methods.
     * Accepts type parameter to define options type.
     * @example
     * Chart._adapters._date.override<{myAdapterOption: string}>({
     *   init() {
     *     console.log(this.options.myAdapterOption);
     *   }
     * })
     */ static override(members) {
          Object.assign(DateAdapterBase.prototype, members);
      }
      options;
      constructor(options){
          this.options = options || {};
      }
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      init() {}
      formats() {
          return abstract();
      }
      parse() {
          return abstract();
      }
      format() {
          return abstract();
      }
      add() {
          return abstract();
      }
      diff() {
          return abstract();
      }
      startOf() {
          return abstract();
      }
      endOf() {
          return abstract();
      }
  }
  var adapters = {
      _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
      const { controller , data , _sorted  } = metaset;
      const iScale = controller._cachedMeta.iScale;
      if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {
          const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
          if (!intersect) {
              return lookupMethod(data, axis, value);
          } else if (controller._sharedOptions) {
              const el = data[0];
              const range = typeof el.getRange === 'function' && el.getRange(axis);
              if (range) {
                  const start = lookupMethod(data, axis, value - range);
                  const end = lookupMethod(data, axis, value + range);
                  return {
                      lo: start.lo,
                      hi: end.hi
                  };
              }
          }
      }
      return {
          lo: 0,
          hi: data.length - 1
      };
  }
   function evaluateInteractionItems(chart, axis, position, handler, intersect) {
      const metasets = chart.getSortedVisibleDatasetMetas();
      const value = position[axis];
      for(let i = 0, ilen = metasets.length; i < ilen; ++i){
          const { index , data  } = metasets[i];
          const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);
          for(let j = lo; j <= hi; ++j){
              const element = data[j];
              if (!element.skip) {
                  handler(element, index, j);
              }
          }
      }
  }
   function getDistanceMetricForAxis(axis) {
      const useX = axis.indexOf('x') !== -1;
      const useY = axis.indexOf('y') !== -1;
      return function(pt1, pt2) {
          const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
      };
  }
   function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
      const items = [];
      if (!includeInvisible && !chart.isPointInArea(position)) {
          return items;
      }
      const evaluationFunc = function(element, datasetIndex, index) {
          if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
              return;
          }
          if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({
                  element,
                  datasetIndex,
                  index
              });
          }
      };
      evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
      return items;
  }
   function getNearestRadialItems(chart, position, axis, useFinalPosition) {
      let items = [];
      function evaluationFunc(element, datasetIndex, index) {
          const { startAngle , endAngle  } = element.getProps([
              'startAngle',
              'endAngle'
          ], useFinalPosition);
          const { angle  } = getAngleFromPoint(element, {
              x: position.x,
              y: position.y
          });
          if (_angleBetween(angle, startAngle, endAngle)) {
              items.push({
                  element,
                  datasetIndex,
                  index
              });
          }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
  }
   function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      let items = [];
      const distanceMetric = getDistanceMetricForAxis(axis);
      let minDistance = Number.POSITIVE_INFINITY;
      function evaluationFunc(element, datasetIndex, index) {
          const inRange = element.inRange(position.x, position.y, useFinalPosition);
          if (intersect && !inRange) {
              return;
          }
          const center = element.getCenterPoint(useFinalPosition);
          const pointInArea = !!includeInvisible || chart.isPointInArea(center);
          if (!pointInArea && !inRange) {
              return;
          }
          const distance = distanceMetric(position, center);
          if (distance < minDistance) {
              items = [
                  {
                      element,
                      datasetIndex,
                      index
                  }
              ];
              minDistance = distance;
          } else if (distance === minDistance) {
              items.push({
                  element,
                  datasetIndex,
                  index
              });
          }
      }
      evaluateInteractionItems(chart, axis, position, evaluationFunc);
      return items;
  }
   function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
      if (!includeInvisible && !chart.isPointInArea(position)) {
          return [];
      }
      return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
   function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
      const items = [];
      const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
      let intersectsItem = false;
      evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{
          if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
              items.push({
                  element,
                  datasetIndex,
                  index
              });
              intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
          }
      });
      if (intersect && !intersectsItem) {
          return [];
      }
      return items;
  }
   var Interaction = {
      modes: {
   index (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || 'x';
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
              const elements = [];
              if (!items.length) {
                  return [];
              }
              chart.getSortedVisibleDatasetMetas().forEach((meta)=>{
                  const index = items[0].index;
                  const element = meta.data[index];
                  if (element && !element.skip) {
                      elements.push({
                          element,
                          datasetIndex: meta.index,
                          index
                      });
                  }
              });
              return elements;
          },
   dataset (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
              if (items.length > 0) {
                  const datasetIndex = items[0].datasetIndex;
                  const data = chart.getDatasetMeta(datasetIndex).data;
                  items = [];
                  for(let i = 0; i < data.length; ++i){
                      items.push({
                          element: data[i],
                          datasetIndex,
                          index: i
                      });
                  }
              }
              return items;
          },
   point (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
          },
   nearest (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
          },
   x (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);
          },
   y (chart, e, options, useFinalPosition) {
              const position = getRelativePosition(e, chart);
              return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);
          }
      }
  };
  const STATIC_POSITIONS = [
      'left',
      'top',
      'right',
      'bottom'
  ];
  function filterByPosition(array, position) {
      return array.filter((v)=>v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
      return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
      return array.sort((a, b)=>{
          const v0 = reverse ? b : a;
          const v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
      });
  }
  function wrapBoxes(boxes) {
      const layoutBoxes = [];
      let i, ilen, box, pos, stack, stackWeight;
      for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){
          box = boxes[i];
          ({ position: pos , options: { stack , stackWeight =1  }  } = box);
          layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight
          });
      }
      return layoutBoxes;
  }
  function buildStacks(layouts) {
      const stacks = {};
      for (const wrap of layouts){
          const { stack , pos , stackWeight  } = wrap;
          if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
          }
          const _stack = stacks[stack] || (stacks[stack] = {
              count: 0,
              placed: 0,
              weight: 0,
              size: 0
          });
          _stack.count++;
          _stack.weight += stackWeight;
      }
      return stacks;
  }
   function setLayoutDims(layouts, params) {
      const stacks = buildStacks(layouts);
      const { vBoxMaxWidth , hBoxMaxHeight  } = params;
      let i, ilen, layout;
      for(i = 0, ilen = layouts.length; i < ilen; ++i){
          layout = layouts[i];
          const { fullSize  } = layout.box;
          const stack = stacks[layout.stack];
          const factor = stack && layout.stackWeight / stack.weight;
          if (layout.horizontal) {
              layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
          } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
          }
      }
      return stacks;
  }
  function buildLayoutBoxes(boxes) {
      const layoutBoxes = wrapBoxes(boxes);
      const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);
      const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
      const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
      const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
      const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
      const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
      const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
      return {
          fullSize,
          leftAndTop: left.concat(top),
          rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
          chartArea: filterByPosition(layoutBoxes, 'chartArea'),
          vertical: left.concat(right).concat(centerVertical),
          horizontal: top.concat(bottom).concat(centerHorizontal)
      };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
      return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
      const { pos , box  } = layout;
      const maxPadding = chartArea.maxPadding;
      if (!isObject$1(pos)) {
          if (layout.size) {
              chartArea[pos] -= layout.size;
          }
          const stack = stacks[layout.stack] || {
              size: 0,
              count: 1
          };
          stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
          layout.size = stack.size / stack.count;
          chartArea[pos] += layout.size;
      }
      if (box.getPadding) {
          updateMaxPadding(maxPadding, box.getPadding());
      }
      const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
      const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
      const widthChanged = newWidth !== chartArea.w;
      const heightChanged = newHeight !== chartArea.h;
      chartArea.w = newWidth;
      chartArea.h = newHeight;
      return layout.horizontal ? {
          same: widthChanged,
          other: heightChanged
      } : {
          same: heightChanged,
          other: widthChanged
      };
  }
  function handleMaxPadding(chartArea) {
      const maxPadding = chartArea.maxPadding;
      function updatePos(pos) {
          const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
          chartArea[pos] += change;
          return change;
      }
      chartArea.y += updatePos('top');
      chartArea.x += updatePos('left');
      updatePos('right');
      updatePos('bottom');
  }
  function getMargins(horizontal, chartArea) {
      const maxPadding = chartArea.maxPadding;
      function marginForPositions(positions) {
          const margin = {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
          };
          positions.forEach((pos)=>{
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
          });
          return margin;
      }
      return horizontal ? marginForPositions([
          'left',
          'right'
      ]) : marginForPositions([
          'top',
          'bottom'
      ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
      const refitBoxes = [];
      let i, ilen, layout, box, refit, changed;
      for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){
          layout = boxes[i];
          box = layout.box;
          box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
          const { same , other  } = updateDims(chartArea, params, layout, stacks);
          refit |= same && refitBoxes.length;
          changed = changed || other;
          if (!box.fullSize) {
              refitBoxes.push(layout);
          }
      }
      return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top, width, height) {
      box.top = top;
      box.left = left;
      box.right = left + width;
      box.bottom = top + height;
      box.width = width;
      box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
      const userPadding = params.padding;
      let { x , y  } = chartArea;
      for (const layout of boxes){
          const box = layout.box;
          const stack = stacks[layout.stack] || {
              placed: 0,
              weight: 1
          };
          const weight = layout.stackWeight / stack.weight || 1;
          if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (defined(stack.start)) {
                  y = stack.start;
              }
              if (box.fullSize) {
                  setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
              } else {
                  setBoxDims(box, chartArea.left + stack.placed, y, width, height);
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
          } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (defined(stack.start)) {
                  x = stack.start;
              }
              if (box.fullSize) {
                  setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
              } else {
                  setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
          }
      }
      chartArea.x = x;
      chartArea.y = y;
  }
  var layouts = {
   addBox (chart, item) {
          if (!chart.boxes) {
              chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || 'top';
          item.weight = item.weight || 0;
          item._layers = item._layers || function() {
              return [
                  {
                      z: 0,
                      draw (chartArea) {
                          item.draw(chartArea);
                      }
                  }
              ];
          };
          chart.boxes.push(item);
      },
   removeBox (chart, layoutItem) {
          const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index !== -1) {
              chart.boxes.splice(index, 1);
          }
      },
   configure (chart, item, options) {
          item.fullSize = options.fullSize;
          item.position = options.position;
          item.weight = options.weight;
      },
   update (chart, width, height, minPadding) {
          if (!chart) {
              return;
          }
          const padding = toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          each(chart.boxes, (box)=>{
              if (typeof box.beforeLayout === 'function') {
                  box.beforeLayout();
              }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign({
              maxPadding,
              w: availableWidth,
              h: availableHeight,
              x: padding.left,
              y: padding.top
          }, padding);
          const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params, stacks);
          fitBoxes(verticalBoxes, chartArea, params, stacks);
          if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
          chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w
          };
          each(boxes.chartArea, (layout)=>{
              const box = layout.box;
              Object.assign(box, chart.chartArea);
              box.update(chartArea.w, chartArea.h, {
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0
              });
          });
      }
  };
  class BasePlatform {
   acquireContext(canvas, aspectRatio) {}
   releaseContext(context) {
          return false;
      }
   addEventListener(chart, type, listener) {}
   removeEventListener(chart, type, listener) {}
   getDevicePixelRatio() {
          return 1;
      }
   getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
              width,
              height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
      }
   isAttached(canvas) {
          return true;
      }
   updateConfig(config) {
      }
  }
  class BasicPlatform extends BasePlatform {
      acquireContext(item) {
          return item && item.getContext && item.getContext('2d') || null;
      }
      updateConfig(config) {
          config.options.animation = false;
      }
  }
  const EXPANDO_KEY = '$chartjs';
   const EVENT_TYPES = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup',
      pointerenter: 'mouseenter',
      pointerdown: 'mousedown',
      pointermove: 'mousemove',
      pointerup: 'mouseup',
      pointerleave: 'mouseout',
      pointerout: 'mouseout'
  };
  const isNullOrEmpty = (value)=>value === null || value === '';
   function initCanvas(canvas, aspectRatio) {
      const style = canvas.style;
      const renderHeight = canvas.getAttribute('height');
      const renderWidth = canvas.getAttribute('width');
      canvas[EXPANDO_KEY] = {
          initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                  display: style.display,
                  height: style.height,
                  width: style.width
              }
          }
      };
      style.display = style.display || 'block';
      style.boxSizing = style.boxSizing || 'border-box';
      if (isNullOrEmpty(renderWidth)) {
          const displayWidth = readUsedSize(canvas, 'width');
          if (displayWidth !== undefined) {
              canvas.width = displayWidth;
          }
      }
      if (isNullOrEmpty(renderHeight)) {
          if (canvas.style.height === '') {
              canvas.height = canvas.width / (aspectRatio || 2);
          } else {
              const displayHeight = readUsedSize(canvas, 'height');
              if (displayHeight !== undefined) {
                  canvas.height = displayHeight;
              }
          }
      }
      return canvas;
  }
  const eventListenerOptions = supportsEventListenerOptions ? {
      passive: true
  } : false;
  function addListener(node, type, listener) {
      if (node) {
          node.addEventListener(type, listener, eventListenerOptions);
      }
  }
  function removeListener(chart, type, listener) {
      if (chart && chart.canvas) {
          chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
  }
  function fromNativeEvent(event, chart) {
      const type = EVENT_TYPES[event.type] || event.type;
      const { x , y  } = getRelativePosition(event, chart);
      return {
          type,
          chart,
          native: event,
          x: x !== undefined ? x : null,
          y: y !== undefined ? y : null
      };
  }
  function nodeListContains(nodeList, canvas) {
      for (const node of nodeList){
          if (node === canvas || node.contains(canvas)) {
              return true;
          }
      }
  }
  function createAttachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries)=>{
          let trigger = false;
          for (const entry of entries){
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
          }
          if (trigger) {
              listener();
          }
      });
      observer.observe(document, {
          childList: true,
          subtree: true
      });
      return observer;
  }
  function createDetachObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const observer = new MutationObserver((entries)=>{
          let trigger = false;
          for (const entry of entries){
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
          }
          if (trigger) {
              listener();
          }
      });
      observer.observe(document, {
          childList: true,
          subtree: true
      });
      return observer;
  }
  const drpListeningCharts = new Map();
  let oldDevicePixelRatio = 0;
  function onWindowResize() {
      const dpr = window.devicePixelRatio;
      if (dpr === oldDevicePixelRatio) {
          return;
      }
      oldDevicePixelRatio = dpr;
      drpListeningCharts.forEach((resize, chart)=>{
          if (chart.currentDevicePixelRatio !== dpr) {
              resize();
          }
      });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
      if (!drpListeningCharts.size) {
          window.addEventListener('resize', onWindowResize);
      }
      drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
      drpListeningCharts.delete(chart);
      if (!drpListeningCharts.size) {
          window.removeEventListener('resize', onWindowResize);
      }
  }
  function createResizeObserver(chart, type, listener) {
      const canvas = chart.canvas;
      const container = canvas && _getParentNode(canvas);
      if (!container) {
          return;
      }
      const resize = throttled((width, height)=>{
          const w = container.clientWidth;
          listener(width, height);
          if (w < container.clientWidth) {
              listener();
          }
      }, window);
      const observer = new ResizeObserver((entries)=>{
          const entry = entries[0];
          const width = entry.contentRect.width;
          const height = entry.contentRect.height;
          if (width === 0 && height === 0) {
              return;
          }
          resize(width, height);
      });
      observer.observe(container);
      listenDevicePixelRatioChanges(chart, resize);
      return observer;
  }
  function releaseObserver(chart, type, observer) {
      if (observer) {
          observer.disconnect();
      }
      if (type === 'resize') {
          unlistenDevicePixelRatioChanges(chart);
      }
  }
  function createProxyAndListen(chart, type, listener) {
      const canvas = chart.canvas;
      const proxy = throttled((event)=>{
          if (chart.ctx !== null) {
              listener(fromNativeEvent(event, chart));
          }
      }, chart);
      addListener(canvas, type, proxy);
      return proxy;
  }
   class DomPlatform extends BasePlatform {
   acquireContext(canvas, aspectRatio) {
          const context = canvas && canvas.getContext && canvas.getContext('2d');
          if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
          }
          return null;
      }
   releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) {
              return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          [
              'height',
              'width'
          ].forEach((prop)=>{
              const value = initial[prop];
              if (isNullOrUndef(value)) {
                  canvas.removeAttribute(prop);
              } else {
                  canvas.setAttribute(prop, value);
              }
          });
          const style = initial.style || {};
          Object.keys(style).forEach((key)=>{
              canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
      }
   addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver
          };
          const handler = handlers[type] || createProxyAndListen;
          proxies[type] = handler(chart, type, listener);
      }
   removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
              return;
          }
          const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver
          };
          const handler = handlers[type] || removeListener;
          handler(chart, type, proxy);
          proxies[type] = undefined;
      }
      getDevicePixelRatio() {
          return window.devicePixelRatio;
      }
   getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
      }
   isAttached(canvas) {
          const container = canvas && _getParentNode(canvas);
          return !!(container && container.isConnected);
      }
  }
  function _detectPlatform(canvas) {
      if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {
          return BasicPlatform;
      }
      return DomPlatform;
  }
  class Element {
      static defaults = {};
      static defaultRoutes = undefined;
      x;
      y;
      active = false;
      options;
      $animations;
      tooltipPosition(useFinalPosition) {
          const { x , y  } = this.getProps([
              'x',
              'y'
          ], useFinalPosition);
          return {
              x,
              y
          };
      }
      hasValue() {
          return isNumber$1(this.x) && isNumber$1(this.y);
      }
      getProps(props, final) {
          const anims = this.$animations;
          if (!final || !anims) {
              // let's not create an object, if not needed
              return this;
          }
          const ret = {};
          props.forEach((prop)=>{
              ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
          });
          return ret;
      }
  }
  function autoSkip(scale, ticks) {
      const tickOpts = scale.options.ticks;
      const determinedMaxTicks = determineMaxTicks(scale);
      const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
      const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      const numMajorIndices = majorIndices.length;
      const first = majorIndices[0];
      const last = majorIndices[numMajorIndices - 1];
      const newTicks = [];
      if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
          return newTicks;
      }
      const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
      if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
          skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){
              skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return newTicks;
      }
      skip(ticks, newTicks, spacing);
      return newTicks;
  }
  function determineMaxTicks(scale) {
      const offset = scale.options.offset;
      const tickLength = scale._tickSize();
      const maxScale = scale._length / tickLength + (offset ? 0 : 1);
      const maxChart = scale._maxLength / tickLength;
      return Math.floor(Math.min(maxScale, maxChart));
  }
   function calculateSpacing(majorIndices, ticks, ticksLimit) {
      const evenMajorSpacing = getEvenSpacing(majorIndices);
      const spacing = ticks.length / ticksLimit;
      if (!evenMajorSpacing) {
          return Math.max(spacing, 1);
      }
      const factors = _factorize(evenMajorSpacing);
      for(let i = 0, ilen = factors.length - 1; i < ilen; i++){
          const factor = factors[i];
          if (factor > spacing) {
              return factor;
          }
      }
      return Math.max(spacing, 1);
  }
   function getMajorIndices(ticks) {
      const result = [];
      let i, ilen;
      for(i = 0, ilen = ticks.length; i < ilen; i++){
          if (ticks[i].major) {
              result.push(i);
          }
      }
      return result;
  }
   function skipMajors(ticks, newTicks, majorIndices, spacing) {
      let count = 0;
      let next = majorIndices[0];
      let i;
      spacing = Math.ceil(spacing);
      for(i = 0; i < ticks.length; i++){
          if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
          }
      }
  }
   function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
      const start = valueOrDefault(majorStart, 0);
      const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
      let count = 0;
      let length, i, next;
      spacing = Math.ceil(spacing);
      if (majorEnd) {
          length = majorEnd - majorStart;
          spacing = length / Math.floor(length / spacing);
      }
      next = start;
      while(next < 0){
          count++;
          next = Math.round(start + count * spacing);
      }
      for(i = Math.max(start, 0); i < end; i++){
          if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
          }
      }
  }
   function getEvenSpacing(arr) {
      const len = arr.length;
      let i, diff;
      if (len < 2) {
          return false;
      }
      for(diff = arr[0], i = 1; i < len; ++i){
          if (arr[i] - arr[i - 1] !== diff) {
              return false;
          }
      }
      return diff;
  }
  const reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;
  const offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
  const getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);
   function sample(arr, numItems) {
      const result = [];
      const increment = arr.length / numItems;
      const len = arr.length;
      let i = 0;
      for(; i < len; i += increment){
          result.push(arr[Math.floor(i)]);
      }
      return result;
  }
   function getPixelForGridLine(scale, index, offsetGridLines) {
      const length = scale.ticks.length;
      const validIndex = Math.min(index, length - 1);
      const start = scale._startPixel;
      const end = scale._endPixel;
      const epsilon = 1e-6;
      let lineValue = scale.getPixelForTick(validIndex);
      let offset;
      if (offsetGridLines) {
          if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
          } else if (index === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
              offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
          }
          lineValue += validIndex < index ? offset : -offset;
          if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
          }
      }
      return lineValue;
  }
   function garbageCollect(caches, length) {
      each(caches, (cache)=>{
          const gc = cache.gc;
          const gcLen = gc.length / 2;
          let i;
          if (gcLen > length) {
              for(i = 0; i < gcLen; ++i){
                  delete cache.data[gc[i]];
              }
              gc.splice(0, gcLen);
          }
      });
  }
   function getTickMarkLength(options) {
      return options.drawTicks ? options.tickLength : 0;
  }
   function getTitleHeight(options, fallback) {
      if (!options.display) {
          return 0;
      }
      const font = toFont(options.font, fallback);
      const padding = toPadding(options.padding);
      const lines = isArray$1(options.text) ? options.text.length : 1;
      return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
      return createContext(parent, {
          scale,
          type: 'scale'
      });
  }
  function createTickContext(parent, index, tick) {
      return createContext(parent, {
          tick,
          index,
          type: 'tick'
      });
  }
  function titleAlign(align, position, reverse) {
       let ret = _toLeftRightCenter(align);
      if (reverse && position !== 'right' || !reverse && position === 'right') {
          ret = reverseAlign(ret);
      }
      return ret;
  }
  function titleArgs(scale, offset, position, align) {
      const { top , left , bottom , right , chart  } = scale;
      const { chartArea , scales  } = chart;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      const height = bottom - top;
      const width = right - left;
      if (scale.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          if (isObject$1(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
          } else if (position === 'center') {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
          } else {
              titleY = offsetFromEdge(scale, position, offset);
          }
          maxWidth = right - left;
      } else {
          if (isObject$1(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
          } else if (position === 'center') {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
          } else {
              titleX = offsetFromEdge(scale, position, offset);
          }
          titleY = _alignStartEnd(align, bottom, top);
          rotation = position === 'left' ? -HALF_PI : HALF_PI;
      }
      return {
          titleX,
          titleY,
          maxWidth,
          rotation
      };
  }
  class Scale extends Element {
      constructor(cfg){
          super();
           this.id = cfg.id;
           this.type = cfg.type;
           this.options = undefined;
           this.ctx = cfg.ctx;
           this.chart = cfg.chart;
           this.top = undefined;
           this.bottom = undefined;
           this.left = undefined;
           this.right = undefined;
           this.width = undefined;
           this.height = undefined;
          this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
          };
           this.maxWidth = undefined;
           this.maxHeight = undefined;
           this.paddingTop = undefined;
           this.paddingBottom = undefined;
           this.paddingLeft = undefined;
           this.paddingRight = undefined;
           this.axis = undefined;
           this.labelRotation = undefined;
          this.min = undefined;
          this.max = undefined;
          this._range = undefined;
           this.ticks = [];
           this._gridLineItems = null;
           this._labelItems = null;
           this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
           this._startPixel = undefined;
           this._endPixel = undefined;
          this._reversePixels = false;
          this._userMax = undefined;
          this._userMin = undefined;
          this._suggestedMax = undefined;
          this._suggestedMin = undefined;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = undefined;
      }
   init(options) {
          this.options = options.setContext(this.getContext());
          this.axis = options.axis;
          this._userMin = this.parse(options.min);
          this._userMax = this.parse(options.max);
          this._suggestedMin = this.parse(options.suggestedMin);
          this._suggestedMax = this.parse(options.suggestedMax);
      }
   parse(raw, index) {
          return raw;
      }
   getUserBounds() {
          let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;
          _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
              min: finiteOrDefault(_userMin, _suggestedMin),
              max: finiteOrDefault(_userMax, _suggestedMax),
              minDefined: isNumberFinite(_userMin),
              maxDefined: isNumberFinite(_userMax)
          };
      }
   getMinMax(canStack) {
          let { min , max , minDefined , maxDefined  } = this.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
              return {
                  min,
                  max
              };
          }
          const metas = this.getMatchingVisibleMetas();
          for(let i = 0, ilen = metas.length; i < ilen; ++i){
              range = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                  min = Math.min(min, range.min);
              }
              if (!maxDefined) {
                  max = Math.max(max, range.max);
              }
          }
          min = maxDefined && min > max ? max : min;
          max = minDefined && min > max ? min : max;
          return {
              min: finiteOrDefault(min, finiteOrDefault(max, min)),
              max: finiteOrDefault(max, finiteOrDefault(min, max))
          };
      }
   getPadding() {
          return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0
          };
      }
   getTicks() {
          return this.ticks;
      }
   getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
      }
   getLabelItems(chartArea = this.chart.chartArea) {
          const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
          return items;
      }
      beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
      }
      beforeUpdate() {
          callback(this.options.beforeUpdate, [
              this
          ]);
      }
   update(maxWidth, maxHeight, margins) {
          const { beginAtZero , grace , ticks: tickOpts  } = this.options;
          const sampleSize = tickOpts.sampleSize;
          this.beforeUpdate();
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins = Object.assign({
              left: 0,
              right: 0,
              top: 0,
              bottom: 0
          }, margins);
          this.ticks = null;
          this._labelSizes = null;
          this._gridLineItems = null;
          this._labelItems = null;
          this.beforeSetDimensions();
          this.setDimensions();
          this.afterSetDimensions();
          this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
          if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = _addGrace(this, grace, beginAtZero);
              this._dataLimitsCached = true;
          }
          this.beforeBuildTicks();
          this.ticks = this.buildTicks() || [];
          this.afterBuildTicks();
          const samplingEnabled = sampleSize < this.ticks.length;
          this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
          this.configure();
          this.beforeCalculateLabelRotation();
          this.calculateLabelRotation();
          this.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
          }
          if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
          }
          this.beforeFit();
          this.fit();
          this.afterFit();
          this.afterUpdate();
      }
   configure() {
          let reversePixels = this.options.reverse;
          let startPixel, endPixel;
          if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
          } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
          }
          this._startPixel = startPixel;
          this._endPixel = endPixel;
          this._reversePixels = reversePixels;
          this._length = endPixel - startPixel;
          this._alignToPixels = this.options.alignToPixels;
      }
      afterUpdate() {
          callback(this.options.afterUpdate, [
              this
          ]);
      }
      beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [
              this
          ]);
      }
      setDimensions() {
          if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
          } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
          }
          this.paddingLeft = 0;
          this.paddingTop = 0;
          this.paddingRight = 0;
          this.paddingBottom = 0;
      }
      afterSetDimensions() {
          callback(this.options.afterSetDimensions, [
              this
          ]);
      }
      _callHooks(name) {
          this.chart.notifyPlugins(name, this.getContext());
          callback(this.options[name], [
              this
          ]);
      }
      beforeDataLimits() {
          this._callHooks('beforeDataLimits');
      }
      determineDataLimits() {}
      afterDataLimits() {
          this._callHooks('afterDataLimits');
      }
      beforeBuildTicks() {
          this._callHooks('beforeBuildTicks');
      }
   buildTicks() {
          return [];
      }
      afterBuildTicks() {
          this._callHooks('afterBuildTicks');
      }
      beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [
              this
          ]);
      }
   generateTickLabels(ticks) {
          const tickOpts = this.options.ticks;
          let i, ilen, tick;
          for(i = 0, ilen = ticks.length; i < ilen; i++){
              tick = ticks[i];
              tick.label = callback(tickOpts.callback, [
                  tick.value,
                  i,
                  ticks
              ], this);
          }
      }
      afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [
              this
          ]);
      }
      beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [
              this
          ]);
      }
      calculateLabelRotation() {
          const options = this.options;
          const tickOpts = options.ticks;
          const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
              this.labelRotation = minRotation;
              return;
          }
          const labelSizes = this._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
          tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
              labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
              labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          this.labelRotation = labelRotation;
      }
      afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [
              this
          ]);
      }
      afterAutoSkip() {}
      beforeFit() {
          callback(this.options.beforeFit, [
              this
          ]);
      }
      fit() {
          const minSize = {
              width: 0,
              height: 0
          };
          const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;
          const display = this._isVisible();
          const isHorizontal = this.isHorizontal();
          if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart.options.font);
              if (isHorizontal) {
                  minSize.width = this.maxWidth;
                  minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                  minSize.height = this.maxHeight;
                  minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                  const { first , last , widest , highest  } = this._getLabelSizes();
                  const tickPadding = tickOpts.padding * 2;
                  const angleRadians = toRadians(this.labelRotation);
                  const cos = Math.cos(angleRadians);
                  const sin = Math.sin(angleRadians);
                  if (isHorizontal) {
                      const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                      minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                  } else {
                      const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                      minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                  }
                  this._calculatePadding(first, last, sin, cos);
              }
          }
          this._handleMargins();
          if (isHorizontal) {
              this.width = this._length = chart.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
          } else {
              this.width = minSize.width;
              this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
          }
      }
      _calculatePadding(first, last, sin, cos) {
          const { ticks: { align , padding  } , position  } = this.options;
          const isRotated = this.labelRotation !== 0;
          const labelsBelowTicks = position !== 'top' && this.axis === 'x';
          if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                  if (labelsBelowTicks) {
                      paddingLeft = cos * first.width;
                      paddingRight = sin * last.height;
                  } else {
                      paddingLeft = sin * first.height;
                      paddingRight = cos * last.width;
                  }
              } else if (align === 'start') {
                  paddingRight = last.width;
              } else if (align === 'end') {
                  paddingLeft = first.width;
              } else if (align !== 'inner') {
                  paddingLeft = first.width / 2;
                  paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
              this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
          } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === 'start') {
                  paddingTop = 0;
                  paddingBottom = first.height;
              } else if (align === 'end') {
                  paddingTop = last.height;
                  paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
          }
      }
   _handleMargins() {
          if (this._margins) {
              this._margins.left = Math.max(this.paddingLeft, this._margins.left);
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(this.paddingRight, this._margins.right);
              this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
          }
      }
      afterFit() {
          callback(this.options.afterFit, [
              this
          ]);
      }
   isHorizontal() {
          const { axis , position  } = this.options;
          return position === 'top' || position === 'bottom' || axis === 'x';
      }
   isFullSize() {
          return this.options.fullSize;
      }
   _convertTicksToLabels(ticks) {
          this.beforeTickToLabelConversion();
          this.generateTickLabels(ticks);
          let i, ilen;
          for(i = 0, ilen = ticks.length; i < ilen; i++){
              if (isNullOrUndef(ticks[i].label)) {
                  ticks.splice(i, 1);
                  ilen--;
                  i--;
              }
          }
          this.afterTickToLabelConversion();
      }
   _getLabelSizes() {
          let labelSizes = this._labelSizes;
          if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                  ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
          }
          return labelSizes;
      }
   _computeLabelSizes(ticks, length, maxTicksLimit) {
          const { ctx , _longestTextCache: caches  } = this;
          const widths = [];
          const heights = [];
          const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
          for(i = 0; i < length; i += increment){
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString = tickFont.string;
              cache = caches[fontString] = caches[fontString] || {
                  data: {},
                  gc: []
              };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (!isNullOrUndef(label) && !isArray$1(label)) {
                  width = _measureText(ctx, cache.data, cache.gc, width, label);
                  height = lineHeight;
              } else if (isArray$1(label)) {
                  for(j = 0, jlen = label.length; j < jlen; ++j){
                      nestedLabel =  label[j];
                      if (!isNullOrUndef(nestedLabel) && !isArray$1(nestedLabel)) {
                          width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                          height += lineHeight;
                      }
                  }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = (idx)=>({
                  width: widths[idx] || 0,
                  height: heights[idx] || 0
              });
          return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights
          };
      }
   getLabelForValue(value) {
          return value;
      }
   getPixelForValue(value, index) {
          return NaN;
      }
   getValueForPixel(pixel) {}
   getPixelForTick(index) {
          const ticks = this.ticks;
          if (index < 0 || index > ticks.length - 1) {
              return null;
          }
          return this.getPixelForValue(ticks[index].value);
      }
   getPixelForDecimal(decimal) {
          if (this._reversePixels) {
              decimal = 1 - decimal;
          }
          const pixel = this._startPixel + decimal * this._length;
          return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
      }
   getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
      }
   getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
      }
   getBaseValue() {
          const { min , max  } = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
      }
   getContext(index) {
          const ticks = this.ticks || [];
          if (index >= 0 && index < ticks.length) {
              const tick = ticks[index];
              return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
          }
          return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
      }
   _tickSize() {
          const optionTicks = this.options.ticks;
          const rot = toRadians(this.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = this._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
      }
   _isVisible() {
          const display = this.options.display;
          if (display !== 'auto') {
              return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
      }
   _computeGridLineItems(chartArea) {
          const axis = this.axis;
          const chart = this.chart;
          const options = this.options;
          const { grid , position , border  } = options;
          const offset = grid.offset;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = border.setContext(this.getContext());
          const axisWidth = borderOpts.display ? borderOpts.width : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function(pixel) {
              return _alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === 'top') {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
          } else if (position === 'bottom') {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
          } else if (position === 'left') {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
          } else if (position === 'right') {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
          } else if (axis === 'x') {
              if (position === 'center') {
                  borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
              } else if (isObject$1(position)) {
                  const positionAxisID = Object.keys(position)[0];
                  const value = position[positionAxisID];
                  borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
          } else if (axis === 'y') {
              if (position === 'center') {
                  borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
              } else if (isObject$1(position)) {
                  const positionAxisID = Object.keys(position)[0];
                  const value = position[positionAxisID];
                  borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
          }
          const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
          const step = Math.max(1, Math.ceil(ticksLength / limit));
          for(i = 0; i < ticksLength; i += step){
              const context = this.getContext(i);
              const optsAtIndex = grid.setContext(context);
              const optsAtIndexBorder = border.setContext(context);
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndexBorder.dash || [];
              const borderDashOffset = optsAtIndexBorder.dashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === undefined) {
                  continue;
              }
              alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
              if (isHorizontal) {
                  tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                  ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                  tx1,
                  ty1,
                  tx2,
                  ty2,
                  x1,
                  y1,
                  x2,
                  y2,
                  width: lineWidth,
                  color: lineColor,
                  borderDash,
                  borderDashOffset,
                  tickWidth,
                  tickColor,
                  tickBorderDash,
                  tickBorderDashOffset
              });
          }
          this._ticksLength = ticksLength;
          this._borderValue = borderValue;
          return items;
      }
   _computeLabelItems(chartArea) {
          const axis = this.axis;
          const options = this.options;
          const { position , ticks: optionTicks  } = options;
          const isHorizontal = this.isHorizontal();
          const ticks = this.ticks;
          const { align , crossAlign , padding , mirror  } = optionTicks;
          const tl = getTickMarkLength(options.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -toRadians(this.labelRotation);
          const items = [];
          let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = 'middle';
          if (position === 'top') {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
          } else if (position === 'bottom') {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
          } else if (position === 'left') {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
          } else if (position === 'right') {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
          } else if (axis === 'x') {
              if (position === 'center') {
                  y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (isObject$1(position)) {
                  const positionAxisID = Object.keys(position)[0];
                  const value = position[positionAxisID];
                  y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
          } else if (axis === 'y') {
              if (position === 'center') {
                  x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (isObject$1(position)) {
                  const positionAxisID = Object.keys(position)[0];
                  const value = position[positionAxisID];
                  x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === 'y') {
              if (align === 'start') {
                  textBaseline = 'top';
              } else if (align === 'end') {
                  textBaseline = 'bottom';
              }
          }
          const labelSizes = this._getLabelSizes();
          for(i = 0, ilen = ticks.length; i < ilen; ++i){
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = isArray$1(label) ? label.length : 1;
              const halfCount = lineCount / 2;
              const color = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                  x = pixel;
                  if (textAlign === 'inner') {
                      if (i === ilen - 1) {
                          tickTextAlign = !this.options.reverse ? 'right' : 'left';
                      } else if (i === 0) {
                          tickTextAlign = !this.options.reverse ? 'left' : 'right';
                      } else {
                          tickTextAlign = 'center';
                      }
                  }
                  if (position === 'top') {
                      if (crossAlign === 'near' || rotation !== 0) {
                          textOffset = -lineCount * lineHeight + lineHeight / 2;
                      } else if (crossAlign === 'center') {
                          textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                      } else {
                          textOffset = -labelSizes.highest.height + lineHeight / 2;
                      }
                  } else {
                      if (crossAlign === 'near' || rotation !== 0) {
                          textOffset = lineHeight / 2;
                      } else if (crossAlign === 'center') {
                          textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                      } else {
                          textOffset = labelSizes.highest.height - lineCount * lineHeight;
                      }
                  }
                  if (mirror) {
                      textOffset *= -1;
                  }
                  if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                      x += lineHeight / 2 * Math.sin(rotation);
                  }
              } else {
                  y = pixel;
                  textOffset = (1 - lineCount) * lineHeight / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                  const labelPadding = toPadding(optsAtIndex.backdropPadding);
                  const height = labelSizes.heights[i];
                  const width = labelSizes.widths[i];
                  let top = textOffset - labelPadding.top;
                  let left = 0 - labelPadding.left;
                  switch(textBaseline){
                      case 'middle':
                          top -= height / 2;
                          break;
                      case 'bottom':
                          top -= height;
                          break;
                  }
                  switch(textAlign){
                      case 'center':
                          left -= width / 2;
                          break;
                      case 'right':
                          left -= width;
                          break;
                      case 'inner':
                          if (i === ilen - 1) {
                              left -= width;
                          } else if (i > 0) {
                              left -= width / 2;
                          }
                          break;
                  }
                  backdrop = {
                      left,
                      top,
                      width: width + labelPadding.width,
                      height: height + labelPadding.height,
                      color: optsAtIndex.backdropColor
                  };
              }
              items.push({
                  label,
                  font,
                  textOffset,
                  options: {
                      rotation,
                      color,
                      strokeColor,
                      strokeWidth,
                      textAlign: tickTextAlign,
                      textBaseline,
                      translation: [
                          x,
                          y
                      ],
                      backdrop
                  }
              });
          }
          return items;
      }
      _getXAxisLabelAlignment() {
          const { position , ticks  } = this.options;
          const rotation = -toRadians(this.labelRotation);
          if (rotation) {
              return position === 'top' ? 'left' : 'right';
          }
          let align = 'center';
          if (ticks.align === 'start') {
              align = 'left';
          } else if (ticks.align === 'end') {
              align = 'right';
          } else if (ticks.align === 'inner') {
              align = 'inner';
          }
          return align;
      }
      _getYAxisLabelAlignment(tl) {
          const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;
          const labelSizes = this._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === 'left') {
              if (mirror) {
                  x = this.right + padding;
                  if (crossAlign === 'near') {
                      textAlign = 'left';
                  } else if (crossAlign === 'center') {
                      textAlign = 'center';
                      x += widest / 2;
                  } else {
                      textAlign = 'right';
                      x += widest;
                  }
              } else {
                  x = this.right - tickAndPadding;
                  if (crossAlign === 'near') {
                      textAlign = 'right';
                  } else if (crossAlign === 'center') {
                      textAlign = 'center';
                      x -= widest / 2;
                  } else {
                      textAlign = 'left';
                      x = this.left;
                  }
              }
          } else if (position === 'right') {
              if (mirror) {
                  x = this.left + padding;
                  if (crossAlign === 'near') {
                      textAlign = 'right';
                  } else if (crossAlign === 'center') {
                      textAlign = 'center';
                      x -= widest / 2;
                  } else {
                      textAlign = 'left';
                      x -= widest;
                  }
              } else {
                  x = this.left + tickAndPadding;
                  if (crossAlign === 'near') {
                      textAlign = 'left';
                  } else if (crossAlign === 'center') {
                      textAlign = 'center';
                      x += widest / 2;
                  } else {
                      textAlign = 'right';
                      x = this.right;
                  }
              }
          } else {
              textAlign = 'right';
          }
          return {
              textAlign,
              x
          };
      }
   _computeLabelArea() {
          if (this.options.ticks.mirror) {
              return;
          }
          const chart = this.chart;
          const position = this.options.position;
          if (position === 'left' || position === 'right') {
              return {
                  top: 0,
                  left: this.left,
                  bottom: chart.height,
                  right: this.right
              };
          }
          if (position === 'top' || position === 'bottom') {
              return {
                  top: this.top,
                  left: 0,
                  bottom: this.bottom,
                  right: chart.width
              };
          }
      }
   drawBackground() {
          const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;
          if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
          }
      }
      getLineWidthForValue(value) {
          const grid = this.options.grid;
          if (!this._isVisible() || !grid.display) {
              return 0;
          }
          const ticks = this.ticks;
          const index = ticks.findIndex((t)=>t.value === value);
          if (index >= 0) {
              const opts = grid.setContext(this.getContext(index));
              return opts.lineWidth;
          }
          return 0;
      }
   drawGrid(chartArea) {
          const grid = this.options.grid;
          const ctx = this.ctx;
          const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style)=>{
              if (!style.width || !style.color) {
                  return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
          };
          if (grid.display) {
              for(i = 0, ilen = items.length; i < ilen; ++i){
                  const item = items[i];
                  if (grid.drawOnChartArea) {
                      drawLine({
                          x: item.x1,
                          y: item.y1
                      }, {
                          x: item.x2,
                          y: item.y2
                      }, item);
                  }
                  if (grid.drawTicks) {
                      drawLine({
                          x: item.tx1,
                          y: item.ty1
                      }, {
                          x: item.tx2,
                          y: item.ty2
                      }, {
                          color: item.tickColor,
                          width: item.tickWidth,
                          borderDash: item.tickBorderDash,
                          borderDashOffset: item.tickBorderDashOffset
                      });
                  }
              }
          }
      }
   drawBorder() {
          const { chart , ctx , options: { border , grid  }  } = this;
          const borderOpts = border.setContext(this.getContext());
          const axisWidth = border.display ? borderOpts.width : 0;
          if (!axisWidth) {
              return;
          }
          const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
          const borderValue = this._borderValue;
          let x1, x2, y1, y2;
          if (this.isHorizontal()) {
              x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
              x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
              y1 = y2 = borderValue;
          } else {
              y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
              y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
              x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.width;
          ctx.strokeStyle = borderOpts.color;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
      }
   drawLabels(chartArea) {
          const optionTicks = this.options.ticks;
          if (!optionTicks.display) {
              return;
          }
          const ctx = this.ctx;
          const area = this._computeLabelArea();
          if (area) {
              clipArea(ctx, area);
          }
          const items = this.getLabelItems(chartArea);
          for (const item of items){
              const renderTextOptions = item.options;
              const tickFont = item.font;
              const label = item.label;
              const y = item.textOffset;
              renderText(ctx, label, 0, y, tickFont, renderTextOptions);
          }
          if (area) {
              unclipArea(ctx);
          }
      }
   drawTitle() {
          const { ctx , options: { position , title , reverse  }  } = this;
          if (!title.display) {
              return;
          }
          const font = toFont(title.font);
          const padding = toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === 'bottom' || position === 'center' || isObject$1(position)) {
              offset += padding.bottom;
              if (isArray$1(title.text)) {
                  offset += font.lineHeight * (title.text.length - 1);
              }
          } else {
              offset += padding.top;
          }
          const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
              color: title.color,
              maxWidth,
              rotation,
              textAlign: titleAlign(align, position, reverse),
              textBaseline: 'middle',
              translation: [
                  titleX,
                  titleY
              ]
          });
      }
      draw(chartArea) {
          if (!this._isVisible()) {
              return;
          }
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawBorder();
          this.drawTitle();
          this.drawLabels(chartArea);
      }
   _layers() {
          const opts = this.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
          const bz = valueOrDefault(opts.border && opts.border.z, 0);
          if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [
                  {
                      z: tz,
                      draw: (chartArea)=>{
                          this.draw(chartArea);
                      }
                  }
              ];
          }
          return [
              {
                  z: gz,
                  draw: (chartArea)=>{
                      this.drawBackground();
                      this.drawGrid(chartArea);
                      this.drawTitle();
                  }
              },
              {
                  z: bz,
                  draw: ()=>{
                      this.drawBorder();
                  }
              },
              {
                  z: tz,
                  draw: (chartArea)=>{
                      this.drawLabels(chartArea);
                  }
              }
          ];
      }
   getMatchingVisibleMetas(type) {
          const metas = this.chart.getSortedVisibleDatasetMetas();
          const axisID = this.axis + 'AxisID';
          const result = [];
          let i, ilen;
          for(i = 0, ilen = metas.length; i < ilen; ++i){
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                  result.push(meta);
              }
          }
          return result;
      }
   _resolveTickFontOptions(index) {
          const opts = this.options.ticks.setContext(this.getContext(index));
          return toFont(opts.font);
      }
   _maxDigits() {
          const fontSize = this._resolveTickFontOptions(0).lineHeight;
          return (this.isHorizontal() ? this.width : this.height) / fontSize;
      }
  }
  class TypedRegistry {
      constructor(type, scope, override){
          this.type = type;
          this.scope = scope;
          this.override = override;
          this.items = Object.create(null);
      }
      isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
      }
   register(item) {
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
          }
          const items = this.items;
          const id = item.id;
          const scope = this.scope + '.' + id;
          if (!id) {
              throw new Error('class does not have id: ' + item);
          }
          if (id in items) {
              return scope;
          }
          items[id] = item;
          registerDefaults(item, scope, parentScope);
          if (this.override) {
              defaults.override(item.id, item.overrides);
          }
          return scope;
      }
   get(id) {
          return this.items[id];
      }
   unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope = this.scope;
          if (id in items) {
              delete items[id];
          }
          if (scope && id in defaults[scope]) {
              delete defaults[scope][id];
              if (this.override) {
                  delete overrides[id];
              }
          }
      }
  }
  function registerDefaults(item, scope, parentScope) {
      const itemDefaults = merge(Object.create(null), [
          parentScope ? defaults.get(parentScope) : {},
          defaults.get(scope),
          item.defaults
      ]);
      defaults.set(scope, itemDefaults);
      if (item.defaultRoutes) {
          routeDefaults(scope, item.defaultRoutes);
      }
      if (item.descriptors) {
          defaults.describe(scope, item.descriptors);
      }
  }
  function routeDefaults(scope, routes) {
      Object.keys(routes).forEach((property)=>{
          const propertyParts = property.split('.');
          const sourceName = propertyParts.pop();
          const sourceScope = [
              scope
          ].concat(propertyParts).join('.');
          const parts = routes[property].split('.');
          const targetName = parts.pop();
          const targetScope = parts.join('.');
          defaults.route(sourceScope, sourceName, targetScope, targetName);
      });
  }
  function isIChartComponent(proto) {
      return 'id' in proto && 'defaults' in proto;
  }
  class Registry {
      constructor(){
          this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
          this.elements = new TypedRegistry(Element, 'elements');
          this.plugins = new TypedRegistry(Object, 'plugins');
          this.scales = new TypedRegistry(Scale, 'scales');
          this._typedRegistries = [
              this.controllers,
              this.scales,
              this.elements
          ];
      }
   add(...args) {
          this._each('register', args);
      }
      remove(...args) {
          this._each('unregister', args);
      }
   addControllers(...args) {
          this._each('register', args, this.controllers);
      }
   addElements(...args) {
          this._each('register', args, this.elements);
      }
   addPlugins(...args) {
          this._each('register', args, this.plugins);
      }
   addScales(...args) {
          this._each('register', args, this.scales);
      }
   getController(id) {
          return this._get(id, this.controllers, 'controller');
      }
   getElement(id) {
          return this._get(id, this.elements, 'element');
      }
   getPlugin(id) {
          return this._get(id, this.plugins, 'plugin');
      }
   getScale(id) {
          return this._get(id, this.scales, 'scale');
      }
   removeControllers(...args) {
          this._each('unregister', args, this.controllers);
      }
   removeElements(...args) {
          this._each('unregister', args, this.elements);
      }
   removePlugins(...args) {
          this._each('unregister', args, this.plugins);
      }
   removeScales(...args) {
          this._each('unregister', args, this.scales);
      }
   _each(method, args, typedRegistry) {
          [
              ...args
          ].forEach((arg)=>{
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
                  this._exec(method, reg, arg);
              } else {
                  each(arg, (item)=>{
                      const itemReg = typedRegistry || this._getRegistryForType(item);
                      this._exec(method, itemReg, item);
                  });
              }
          });
      }
   _exec(method, registry, component) {
          const camelMethod = _capitalize(method);
          callback(component['before' + camelMethod], [], component);
          registry[method](component);
          callback(component['after' + camelMethod], [], component);
      }
   _getRegistryForType(type) {
          for(let i = 0; i < this._typedRegistries.length; i++){
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                  return reg;
              }
          }
          return this.plugins;
      }
   _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === undefined) {
              throw new Error('"' + id + '" is not a registered ' + type + '.');
          }
          return item;
      }
  }
  var registry = /* #__PURE__ */ new Registry();
  class PluginService {
      constructor(){
          this._init = [];
      }
   notify(chart, hook, args, filter) {
          if (hook === 'beforeInit') {
              this._init = this._createDescriptors(chart, true);
              this._notify(this._init, chart, 'install');
          }
          const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
          const result = this._notify(descriptors, chart, hook, args);
          if (hook === 'afterDestroy') {
              this._notify(descriptors, chart, 'stop');
              this._notify(this._init, chart, 'uninstall');
          }
          return result;
      }
   _notify(descriptors, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors){
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [
                  chart,
                  args,
                  descriptor.options
              ];
              if (callback(method, params, plugin) === false && args.cancelable) {
                  return false;
              }
          }
          return true;
      }
      invalidate() {
          if (!isNullOrUndef(this._cache)) {
              this._oldCache = this._cache;
              this._cache = undefined;
          }
      }
   _descriptors(chart) {
          if (this._cache) {
              return this._cache;
          }
          const descriptors = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors;
      }
      _createDescriptors(chart, all) {
          const config = chart && chart.config;
          const options = valueOrDefault(config.options && config.options.plugins, {});
          const plugins = allPlugins(config);
          return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
      }
   _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors = this._cache;
          const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
          this._notify(diff(descriptors, previousDescriptors), chart, 'start');
      }
  }
   function allPlugins(config) {
      const localIds = {};
      const plugins = [];
      const keys = Object.keys(registry.plugins.items);
      for(let i = 0; i < keys.length; i++){
          plugins.push(registry.getPlugin(keys[i]));
      }
      const local = config.plugins || [];
      for(let i = 0; i < local.length; i++){
          const plugin = local[i];
          if (plugins.indexOf(plugin) === -1) {
              plugins.push(plugin);
              localIds[plugin.id] = true;
          }
      }
      return {
          plugins,
          localIds
      };
  }
  function getOpts(options, all) {
      if (!all && options === false) {
          return null;
      }
      if (options === true) {
          return {};
      }
      return options;
  }
  function createDescriptors(chart, { plugins , localIds  }, options, all) {
      const result = [];
      const context = chart.getContext();
      for (const plugin of plugins){
          const id = plugin.id;
          const opts = getOpts(options[id], all);
          if (opts === null) {
              continue;
          }
          result.push({
              plugin,
              options: pluginOpts(chart.config, {
                  plugin,
                  local: localIds[id]
              }, opts, context)
          });
      }
      return result;
  }
  function pluginOpts(config, { plugin , local  }, opts, context) {
      const keys = config.pluginScopeKeys(plugin);
      const scopes = config.getOptionScopes(opts, keys);
      if (local && plugin.defaults) {
          scopes.push(plugin.defaults);
      }
      return config.createResolver(scopes, context, [
          ''
      ], {
          scriptable: false,
          indexable: false,
          allKeys: true
      });
  }
  function getIndexAxis(type, options) {
      const datasetDefaults = defaults.datasets[type] || {};
      const datasetOptions = (options.datasets || {})[type] || {};
      return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
      let axis = id;
      if (id === '_index_') {
          axis = indexAxis;
      } else if (id === '_value_') {
          axis = indexAxis === 'x' ? 'y' : 'x';
      }
      return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
      return axis === indexAxis ? '_index_' : '_value_';
  }
  function idMatchesAxis(id) {
      if (id === 'x' || id === 'y' || id === 'r') {
          return id;
      }
  }
  function axisFromPosition(position) {
      if (position === 'top' || position === 'bottom') {
          return 'x';
      }
      if (position === 'left' || position === 'right') {
          return 'y';
      }
  }
  function determineAxis(id, ...scaleOptions) {
      if (idMatchesAxis(id)) {
          return id;
      }
      for (const opts of scaleOptions){
          const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
          if (axis) {
              return axis;
          }
      }
      throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
      if (dataset[axis + 'AxisID'] === id) {
          return {
              axis
          };
      }
  }
  function retrieveAxisFromDatasets(id, config) {
      if (config.data && config.data.datasets) {
          const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);
          if (boundDs.length) {
              return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);
          }
      }
      return {};
  }
  function mergeScaleConfig(config, options) {
      const chartDefaults = overrides[config.type] || {
          scales: {}
      };
      const configScales = options.scales || {};
      const chartIndexAxis = getIndexAxis(config.type, options);
      const scales = Object.create(null);
      Object.keys(configScales).forEach((id)=>{
          const scaleConf = configScales[id];
          if (!isObject$1(scaleConf)) {
              return console.error(`Invalid scale configuration for scale: ${id}`);
          }
          if (scaleConf._proxy) {
              return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
          }
          const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
          const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
          const defaultScaleOptions = chartDefaults.scales || {};
          scales[id] = mergeIf(Object.create(null), [
              {
                  axis
              },
              scaleConf,
              defaultScaleOptions[axis],
              defaultScaleOptions[defaultId]
          ]);
      });
      config.data.datasets.forEach((dataset)=>{
          const type = dataset.type || config.type;
          const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
          const datasetDefaults = overrides[type] || {};
          const defaultScaleOptions = datasetDefaults.scales || {};
          Object.keys(defaultScaleOptions).forEach((defaultID)=>{
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + 'AxisID'] || axis;
              scales[id] = scales[id] || Object.create(null);
              mergeIf(scales[id], [
                  {
                      axis
                  },
                  configScales[id],
                  defaultScaleOptions[defaultID]
              ]);
          });
      });
      Object.keys(scales).forEach((key)=>{
          const scale = scales[key];
          mergeIf(scale, [
              defaults.scales[scale.type],
              defaults.scale
          ]);
      });
      return scales;
  }
  function initOptions(config) {
      const options = config.options || (config.options = {});
      options.plugins = valueOrDefault(options.plugins, {});
      options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
      data = data || {};
      data.datasets = data.datasets || [];
      data.labels = data.labels || [];
      return data;
  }
  function initConfig(config) {
      config = config || {};
      config.data = initData(config.data);
      initOptions(config);
      return config;
  }
  const keyCache = new Map();
  const keysCached = new Set();
  function cachedKeys(cacheKey, generate) {
      let keys = keyCache.get(cacheKey);
      if (!keys) {
          keys = generate();
          keyCache.set(cacheKey, keys);
          keysCached.add(keys);
      }
      return keys;
  }
  const addIfFound = (set, obj, key)=>{
      const opts = resolveObjectKey(obj, key);
      if (opts !== undefined) {
          set.add(opts);
      }
  };
  let Config$1 = class Config {
      constructor(config){
          this._config = initConfig(config);
          this._scopeCache = new Map();
          this._resolverCache = new Map();
      }
      get platform() {
          return this._config.platform;
      }
      get type() {
          return this._config.type;
      }
      set type(type) {
          this._config.type = type;
      }
      get data() {
          return this._config.data;
      }
      set data(data) {
          this._config.data = initData(data);
      }
      get options() {
          return this._config.options;
      }
      set options(options) {
          this._config.options = options;
      }
      get plugins() {
          return this._config.plugins;
      }
      update() {
          const config = this._config;
          this.clearCache();
          initOptions(config);
      }
      clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
      }
   datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, ()=>[
                  [
                      `datasets.${datasetType}`,
                      ''
                  ]
              ]);
      }
   datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[
                  [
                      `datasets.${datasetType}.transitions.${transition}`,
                      `transitions.${transition}`
                  ],
                  [
                      `datasets.${datasetType}`,
                      ''
                  ]
              ]);
      }
   datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${datasetType}-${elementType}`, ()=>[
                  [
                      `datasets.${datasetType}.elements.${elementType}`,
                      `datasets.${datasetType}`,
                      `elements.${elementType}`,
                      ''
                  ]
              ]);
      }
   pluginScopeKeys(plugin) {
          const id = plugin.id;
          const type = this.type;
          return cachedKeys(`${type}-plugin-${id}`, ()=>[
                  [
                      `plugins.${id}`,
                      ...plugin.additionalOptionScopes || []
                  ]
              ]);
      }
   _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          if (!cache || resetCache) {
              cache = new Map();
              _scopeCache.set(mainScope, cache);
          }
          return cache;
      }
   getOptionScopes(mainScope, keyLists, resetCache) {
          const { options , type  } = this;
          const cache = this._cachedScopes(mainScope, resetCache);
          const cached = cache.get(keyLists);
          if (cached) {
              return cached;
          }
          const scopes = new Set();
          keyLists.forEach((keys)=>{
              if (mainScope) {
                  scopes.add(mainScope);
                  keys.forEach((key)=>addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key)=>addIfFound(scopes, options, key));
              keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));
              keys.forEach((key)=>addIfFound(scopes, defaults, key));
              keys.forEach((key)=>addIfFound(scopes, descriptors, key));
          });
          const array = Array.from(scopes);
          if (array.length === 0) {
              array.push(Object.create(null));
          }
          if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
          }
          return array;
      }
   chartOptionScopes() {
          const { options , type  } = this;
          return [
              options,
              overrides[type] || {},
              defaults.datasets[type] || {},
              {
                  type
              },
              defaults,
              descriptors
          ];
      }
   resolveNamedOptions(scopes, names, context, prefixes = [
          ''
      ]) {
          const result = {
              $shared: true
          };
          const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);
          let options = resolver;
          if (needContext(resolver, names)) {
              result.$shared = false;
              context = isFunction(context) ? context() : context;
              const subResolver = this.createResolver(scopes, context, subPrefixes);
              options = _attachContext(resolver, context, subResolver);
          }
          for (const prop of names){
              result[prop] = options[prop];
          }
          return result;
      }
   createResolver(scopes, context, prefixes = [
          ''
      ], descriptorDefaults) {
          const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);
          return isObject$1(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;
      }
  };
  function getResolver(resolverCache, scopes, prefixes) {
      let cache = resolverCache.get(scopes);
      if (!cache) {
          cache = new Map();
          resolverCache.set(scopes, cache);
      }
      const cacheKey = prefixes.join();
      let cached = cache.get(cacheKey);
      if (!cached) {
          const resolver = _createResolver(scopes, prefixes);
          cached = {
              resolver,
              subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))
          };
          cache.set(cacheKey, cached);
      }
      return cached;
  }
  const hasFunction = (value)=>isObject$1(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));
  function needContext(proxy, names) {
      const { isScriptable , isIndexable  } = _descriptors(proxy);
      for (const prop of names){
          const scriptable = isScriptable(prop);
          const indexable = isIndexable(prop);
          const value = (indexable || scriptable) && proxy[prop];
          if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray$1(value)) {
              return true;
          }
      }
      return false;
  }
  var version = "4.4.7";
  const KNOWN_POSITIONS = [
      'top',
      'bottom',
      'left',
      'right',
      'chartArea'
  ];
  function positionIsHorizontal(position, axis) {
      return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';
  }
  function compare2Level(l1, l2) {
      return function(a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
      };
  }
  function onAnimationsComplete(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      chart.notifyPlugins('afterRender');
      callback(animationOptions && animationOptions.onComplete, [
          context
      ], chart);
  }
  function onAnimationProgress(context) {
      const chart = context.chart;
      const animationOptions = chart.options.animation;
      callback(animationOptions && animationOptions.onProgress, [
          context
      ], chart);
  }
   function getCanvas(item) {
      if (_isDomSupported() && typeof item === 'string') {
          item = document.getElementById(item);
      } else if (item && item.length) {
          item = item[0];
      }
      if (item && item.canvas) {
          item = item.canvas;
      }
      return item;
  }
  const instances = {};
  const getChart = (key)=>{
      const canvas = getCanvas(key);
      return Object.values(instances).filter((c)=>c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
      const keys = Object.keys(obj);
      for (const key of keys){
          const intKey = +key;
          if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move > 0 || intKey > start) {
                  obj[intKey + move] = value;
              }
          }
      }
  }
   function determineLastEvent(e, lastEvent, inChartArea, isClick) {
      if (!inChartArea || e.type === 'mouseout') {
          return null;
      }
      if (isClick) {
          return lastEvent;
      }
      return e;
  }
  function getSizeForArea(scale, chartArea, field) {
      return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
      const { xScale , yScale  } = meta;
      if (xScale && yScale) {
          return {
              left: getSizeForArea(xScale, chartArea, 'left'),
              right: getSizeForArea(xScale, chartArea, 'right'),
              top: getSizeForArea(yScale, chartArea, 'top'),
              bottom: getSizeForArea(yScale, chartArea, 'bottom')
          };
      }
      return chartArea;
  }
  class Chart {
      static defaults = defaults;
      static instances = instances;
      static overrides = overrides;
      static registry = registry;
      static version = version;
      static getChart = getChart;
      static register(...items) {
          registry.add(...items);
          invalidatePlugins();
      }
      static unregister(...items) {
          registry.remove(...items);
          invalidatePlugins();
      }
      constructor(item, userConfig){
          const config = this.config = new Config$1(userConfig);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
              throw new Error('Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' + ' must be destroyed before the canvas with ID \'' + existingChart.canvas.id + '\' can be reused.');
          }
          const options = config.createResolver(config.chartOptionScopes(), this.getContext());
          this.platform = new (config.platform || _detectPlatform(initialCanvas))();
          this.platform.updateConfig(config);
          const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
          const canvas = context && context.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = uid();
          this.ctx = context;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = undefined;
          this.boxes = [];
          this.currentDevicePixelRatio = undefined;
          this.chartArea = undefined;
          this._active = [];
          this._lastEvent = undefined;
          this._listeners = {};
           this._responsiveListeners = undefined;
          this._sortedMetasets = [];
          this.scales = {};
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = undefined;
          this.$context = undefined;
          this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);
          this._dataChanges = [];
          instances[this.id] = this;
          if (!context || !canvas) {
              console.error("Failed to create chart: can't acquire context from the given item");
              return;
          }
          animator.listen(this, 'complete', onAnimationsComplete);
          animator.listen(this, 'progress', onAnimationProgress);
          this._initialize();
          if (this.attached) {
              this.update();
          }
      }
      get aspectRatio() {
          const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;
          if (!isNullOrUndef(aspectRatio)) {
              return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
          }
          return height ? width / height : null;
      }
      get data() {
          return this.config.data;
      }
      set data(data) {
          this.config.data = data;
      }
      get options() {
          return this._options;
      }
      set options(options) {
          this.config.options = options;
      }
      get registry() {
          return registry;
      }
   _initialize() {
          this.notifyPlugins('beforeInit');
          if (this.options.responsive) {
              this.resize();
          } else {
              retinaScale(this, this.options.devicePixelRatio);
          }
          this.bindEvents();
          this.notifyPlugins('afterInit');
          return this;
      }
      clear() {
          clearCanvas(this.canvas, this.ctx);
          return this;
      }
      stop() {
          animator.stop(this);
          return this;
      }
   resize(width, height) {
          if (!animator.running(this)) {
              this._resize(width, height);
          } else {
              this._resizeBeforeDraw = {
                  width,
                  height
              };
          }
      }
      _resize(width, height) {
          const options = this.options;
          const canvas = this.canvas;
          const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
          const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
          const mode = this.width ? 'resize' : 'attach';
          this.width = newSize.width;
          this.height = newSize.height;
          this._aspectRatio = this.aspectRatio;
          if (!retinaScale(this, newRatio, true)) {
              return;
          }
          this.notifyPlugins('resize', {
              size: newSize
          });
          callback(options.onResize, [
              this,
              newSize
          ], this);
          if (this.attached) {
              if (this._doResize(mode)) {
                  this.render();
              }
          }
      }
      ensureScalesHaveIDs() {
          const options = this.options;
          const scalesOptions = options.scales || {};
          each(scalesOptions, (axisOptions, axisID)=>{
              axisOptions.id = axisID;
          });
      }
   buildOrUpdateScales() {
          const options = this.options;
          const scaleOpts = options.scales;
          const scales = this.scales;
          const updated = Object.keys(scales).reduce((obj, id)=>{
              obj[id] = false;
              return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
              items = items.concat(Object.keys(scaleOpts).map((id)=>{
                  const scaleOptions = scaleOpts[id];
                  const axis = determineAxis(id, scaleOptions);
                  const isRadial = axis === 'r';
                  const isHorizontal = axis === 'x';
                  return {
                      options: scaleOptions,
                      dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
                      dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
                  };
              }));
          }
          each(items, (item)=>{
              const scaleOptions = item.options;
              const id = scaleOptions.id;
              const axis = determineAxis(id, scaleOptions);
              const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
              if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
                  scaleOptions.position = item.dposition;
              }
              updated[id] = true;
              let scale = null;
              if (id in scales && scales[id].type === scaleType) {
                  scale = scales[id];
              } else {
                  const scaleClass = registry.getScale(scaleType);
                  scale = new scaleClass({
                      id,
                      type: scaleType,
                      ctx: this.ctx,
                      chart: this
                  });
                  scales[scale.id] = scale;
              }
              scale.init(scaleOptions, options);
          });
          each(updated, (hasUpdated, id)=>{
              if (!hasUpdated) {
                  delete scales[id];
              }
          });
          each(scales, (scale)=>{
              layouts.configure(this, scale, scale.options);
              layouts.addBox(this, scale);
          });
      }
   _updateMetasets() {
          const metasets = this._metasets;
          const numData = this.data.datasets.length;
          const numMeta = metasets.length;
          metasets.sort((a, b)=>a.index - b.index);
          if (numMeta > numData) {
              for(let i = numData; i < numMeta; ++i){
                  this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
          }
          this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
      }
   _removeUnreferencedMetasets() {
          const { _metasets: metasets , data: { datasets  }  } = this;
          if (metasets.length > datasets.length) {
              delete this._stacks;
          }
          metasets.forEach((meta, index)=>{
              if (datasets.filter((x)=>x === meta._dataset).length === 0) {
                  this._destroyDatasetMeta(index);
              }
          });
      }
      buildOrUpdateControllers() {
          const newControllers = [];
          const datasets = this.data.datasets;
          let i, ilen;
          this._removeUnreferencedMetasets();
          for(i = 0, ilen = datasets.length; i < ilen; i++){
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                  this._destroyDatasetMeta(i);
                  meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = '' + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                  meta.controller.updateIndex(i);
                  meta.controller.linkScales();
              } else {
                  const ControllerClass = registry.getController(type);
                  const { datasetElementType , dataElementType  } = defaults.datasets[type];
                  Object.assign(ControllerClass, {
                      dataElementType: registry.getElement(dataElementType),
                      datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                  });
                  meta.controller = new ControllerClass(this, i);
                  newControllers.push(meta.controller);
              }
          }
          this._updateMetasets();
          return newControllers;
      }
   _resetElements() {
          each(this.data.datasets, (dataset, datasetIndex)=>{
              this.getDatasetMeta(datasetIndex).controller.reset();
          }, this);
      }
   reset() {
          this._resetElements();
          this.notifyPlugins('reset');
      }
      update(mode) {
          const config = this.config;
          config.update();
          const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
          const animsDisabled = this._animationsDisabled = !options.animation;
          this._updateScales();
          this._checkEventBindings();
          this._updateHiddenIndices();
          this._plugins.invalidate();
          if (this.notifyPlugins('beforeUpdate', {
              mode,
              cancelable: true
          }) === false) {
              return;
          }
          const newControllers = this.buildOrUpdateControllers();
          this.notifyPlugins('beforeElementsUpdate');
          let minPadding = 0;
          for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){
              const { controller  } = this.getDatasetMeta(i);
              const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
          this._updateLayout(minPadding);
          if (!animsDisabled) {
              each(newControllers, (controller)=>{
                  controller.reset();
              });
          }
          this._updateDatasets(mode);
          this.notifyPlugins('afterUpdate', {
              mode
          });
          this._layers.sort(compare2Level('z', '_idx'));
          const { _active , _lastEvent  } = this;
          if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
          } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
          }
          this.render();
      }
   _updateScales() {
          each(this.scales, (scale)=>{
              layouts.removeBox(this, scale);
          });
          this.ensureScalesHaveIDs();
          this.buildOrUpdateScales();
      }
   _checkEventBindings() {
          const options = this.options;
          const existingEvents = new Set(Object.keys(this._listeners));
          const newEvents = new Set(options.events);
          if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
              this.unbindEvents();
              this.bindEvents();
          }
      }
   _updateHiddenIndices() {
          const { _hiddenIndices  } = this;
          const changes = this._getUniformDataChanges() || [];
          for (const { method , start , count  } of changes){
              const move = method === '_removeElements' ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move);
          }
      }
   _getUniformDataChanges() {
          const _dataChanges = this._dataChanges;
          if (!_dataChanges || !_dataChanges.length) {
              return;
          }
          this._dataChanges = [];
          const datasetCount = this.data.datasets.length;
          const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));
          const changeSet = makeSet(0);
          for(let i = 1; i < datasetCount; i++){
              if (!setsEqual(changeSet, makeSet(i))) {
                  return;
              }
          }
          return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({
                  method: a[1],
                  start: +a[2],
                  count: +a[3]
              }));
      }
   _updateLayout(minPadding) {
          if (this.notifyPlugins('beforeLayout', {
              cancelable: true
          }) === false) {
              return;
          }
          layouts.update(this, this.width, this.height, minPadding);
          const area = this.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          this._layers = [];
          each(this.boxes, (box)=>{
              if (noArea && box.position === 'chartArea') {
                  return;
              }
              if (box.configure) {
                  box.configure();
              }
              this._layers.push(...box._layers());
          }, this);
          this._layers.forEach((item, index)=>{
              item._idx = index;
          });
          this.notifyPlugins('afterLayout');
      }
   _updateDatasets(mode) {
          if (this.notifyPlugins('beforeDatasetsUpdate', {
              mode,
              cancelable: true
          }) === false) {
              return;
          }
          for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
              this.getDatasetMeta(i).controller.configure();
          }
          for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
              this._updateDataset(i, isFunction(mode) ? mode({
                  datasetIndex: i
              }) : mode);
          }
          this.notifyPlugins('afterDatasetsUpdate', {
              mode
          });
      }
   _updateDataset(index, mode) {
          const meta = this.getDatasetMeta(index);
          const args = {
              meta,
              index,
              mode,
              cancelable: true
          };
          if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
              return;
          }
          meta.controller._update(mode);
          args.cancelable = false;
          this.notifyPlugins('afterDatasetUpdate', args);
      }
      render() {
          if (this.notifyPlugins('beforeRender', {
              cancelable: true
          }) === false) {
              return;
          }
          if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                  animator.start(this);
              }
          } else {
              this.draw();
              onAnimationsComplete({
                  chart: this
              });
          }
      }
      draw() {
          let i;
          if (this._resizeBeforeDraw) {
              const { width , height  } = this._resizeBeforeDraw;
              this._resizeBeforeDraw = null;
              this._resize(width, height);
          }
          this.clear();
          if (this.width <= 0 || this.height <= 0) {
              return;
          }
          if (this.notifyPlugins('beforeDraw', {
              cancelable: true
          }) === false) {
              return;
          }
          const layers = this._layers;
          for(i = 0; i < layers.length && layers[i].z <= 0; ++i){
              layers[i].draw(this.chartArea);
          }
          this._drawDatasets();
          for(; i < layers.length; ++i){
              layers[i].draw(this.chartArea);
          }
          this.notifyPlugins('afterDraw');
      }
   _getSortedDatasetMetas(filterVisible) {
          const metasets = this._sortedMetasets;
          const result = [];
          let i, ilen;
          for(i = 0, ilen = metasets.length; i < ilen; ++i){
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                  result.push(meta);
              }
          }
          return result;
      }
   getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
      }
   _drawDatasets() {
          if (this.notifyPlugins('beforeDatasetsDraw', {
              cancelable: true
          }) === false) {
              return;
          }
          const metasets = this.getSortedVisibleDatasetMetas();
          for(let i = metasets.length - 1; i >= 0; --i){
              this._drawDataset(metasets[i]);
          }
          this.notifyPlugins('afterDatasetsDraw');
      }
   _drawDataset(meta) {
          const ctx = this.ctx;
          const clip = meta._clip;
          const useClip = !clip.disabled;
          const area = getDatasetArea(meta, this.chartArea);
          const args = {
              meta,
              index: meta.index,
              cancelable: true
          };
          if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
              return;
          }
          if (useClip) {
              clipArea(ctx, {
                  left: clip.left === false ? 0 : area.left - clip.left,
                  right: clip.right === false ? this.width : area.right + clip.right,
                  top: clip.top === false ? 0 : area.top - clip.top,
                  bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
              });
          }
          meta.controller.draw();
          if (useClip) {
              unclipArea(ctx);
          }
          args.cancelable = false;
          this.notifyPlugins('afterDatasetDraw', args);
      }
   isPointInArea(point) {
          return _isPointInArea(point, this.chartArea, this._minPadding);
      }
      getElementsAtEventForMode(e, mode, options, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === 'function') {
              return method(this, e, options, useFinalPosition);
          }
          return [];
      }
      getDatasetMeta(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          const metasets = this._metasets;
          let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();
          if (!meta) {
              meta = {
                  type: null,
                  data: [],
                  dataset: null,
                  controller: null,
                  hidden: null,
                  xAxisID: null,
                  yAxisID: null,
                  order: dataset && dataset.order || 0,
                  index: datasetIndex,
                  _dataset: dataset,
                  _parsed: [],
                  _sorted: false
              };
              metasets.push(meta);
          }
          return meta;
      }
      getContext() {
          return this.$context || (this.$context = createContext(null, {
              chart: this,
              type: 'chart'
          }));
      }
      getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
      }
      isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
              return false;
          }
          const meta = this.getDatasetMeta(datasetIndex);
          return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
      }
      setDatasetVisibility(datasetIndex, visible) {
          const meta = this.getDatasetMeta(datasetIndex);
          meta.hidden = !visible;
      }
      toggleDataVisibility(index) {
          this._hiddenIndices[index] = !this._hiddenIndices[index];
      }
      getDataVisibility(index) {
          return !this._hiddenIndices[index];
      }
   _updateVisibility(datasetIndex, dataIndex, visible) {
          const mode = visible ? 'show' : 'hide';
          const meta = this.getDatasetMeta(datasetIndex);
          const anims = meta.controller._resolveAnimations(undefined, mode);
          if (defined(dataIndex)) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
          } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, {
                  visible
              });
              this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);
          }
      }
      hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, false);
      }
      show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, true);
      }
   _destroyDatasetMeta(datasetIndex) {
          const meta = this._metasets[datasetIndex];
          if (meta && meta.controller) {
              meta.controller._destroy();
          }
          delete this._metasets[datasetIndex];
      }
      _stop() {
          let i, ilen;
          this.stop();
          animator.remove(this);
          for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){
              this._destroyDatasetMeta(i);
          }
      }
      destroy() {
          this.notifyPlugins('beforeDestroy');
          const { canvas , ctx  } = this;
          this._stop();
          this.config.clearCache();
          if (canvas) {
              this.unbindEvents();
              clearCanvas(canvas, ctx);
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
          }
          delete instances[this.id];
          this.notifyPlugins('afterDestroy');
      }
      toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
      }
   bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
              this.bindResponsiveEvents();
          } else {
              this.attached = true;
          }
      }
   bindUserEvents() {
          const listeners = this._listeners;
          const platform = this.platform;
          const _add = (type, listener)=>{
              platform.addEventListener(this, type, listener);
              listeners[type] = listener;
          };
          const listener = (e, x, y)=>{
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
          };
          each(this.options.events, (type)=>_add(type, listener));
      }
   bindResponsiveEvents() {
          if (!this._responsiveListeners) {
              this._responsiveListeners = {};
          }
          const listeners = this._responsiveListeners;
          const platform = this.platform;
          const _add = (type, listener)=>{
              platform.addEventListener(this, type, listener);
              listeners[type] = listener;
          };
          const _remove = (type, listener)=>{
              if (listeners[type]) {
                  platform.removeEventListener(this, type, listener);
                  delete listeners[type];
              }
          };
          const listener = (width, height)=>{
              if (this.canvas) {
                  this.resize(width, height);
              }
          };
          let detached;
          const attached = ()=>{
              _remove('attach', attached);
              this.attached = true;
              this.resize();
              _add('resize', listener);
              _add('detach', detached);
          };
          detached = ()=>{
              this.attached = false;
              _remove('resize', listener);
              this._stop();
              this._resize(0, 0);
              _add('attach', attached);
          };
          if (platform.isAttached(this.canvas)) {
              attached();
          } else {
              detached();
          }
      }
   unbindEvents() {
          each(this._listeners, (listener, type)=>{
              this.platform.removeEventListener(this, type, listener);
          });
          this._listeners = {};
          each(this._responsiveListeners, (listener, type)=>{
              this.platform.removeEventListener(this, type, listener);
          });
          this._responsiveListeners = undefined;
      }
      updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? 'set' : 'remove';
          let meta, item, i, ilen;
          if (mode === 'dataset') {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller['_' + prefix + 'DatasetHoverStyle']();
          }
          for(i = 0, ilen = items.length; i < ilen; ++i){
              item = items[i];
              const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                  controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
              }
          }
      }
   getActiveElements() {
          return this._active || [];
      }
   setActiveElements(activeElements) {
          const lastActive = this._active || [];
          const active = activeElements.map(({ datasetIndex , index  })=>{
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                  throw new Error('No dataset found at index ' + datasetIndex);
              }
              return {
                  datasetIndex,
                  element: meta.data[index],
                  index
              };
          });
          const changed = !_elementsEqual(active, lastActive);
          if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
          }
      }
   notifyPlugins(hook, args, filter) {
          return this._plugins.notify(this, hook, args, filter);
      }
   isPluginEnabled(pluginId) {
          return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;
      }
   _updateHoverStyles(active, lastActive, replay) {
          const hoverOptions = this.options.hover;
          const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
          }
      }
   _eventHandler(e, replay) {
          const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e)
          };
          const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);
          if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {
              return;
          }
          const changed = this._handleEvent(e, replay, args.inChartArea);
          args.cancelable = false;
          this.notifyPlugins('afterEvent', args, eventFilter);
          if (changed || args.changed) {
              this.render();
          }
          return this;
      }
   _handleEvent(e, replay, inChartArea) {
          const { _active: lastActive = [] , options  } = this;
          const useFinalPosition = replay;
          const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
          const isClick = _isClickEvent(e);
          const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
          if (inChartArea) {
              this._lastEvent = null;
              callback(options.onHover, [
                  e,
                  active,
                  this
              ], this);
              if (isClick) {
                  callback(options.onClick, [
                      e,
                      active,
                      this
                  ], this);
              }
          }
          const changed = !_elementsEqual(active, lastActive);
          if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
          }
          this._lastEvent = lastEvent;
          return changed;
      }
   _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
          if (e.type === 'mouseout') {
              return [];
          }
          if (!inChartArea) {
              return lastActive;
          }
          const hoverOptions = this.options.hover;
          return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
      }
  }
  function invalidatePlugins() {
      return each(Chart.instances, (chart)=>chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
      const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;
      let angleMargin = pixelMargin / outerRadius;
      // Draw an inner border by clipping the arc and drawing a double-width border
      // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
      ctx.beginPath();
      ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
      if (innerRadius > pixelMargin) {
          angleMargin = pixelMargin / innerRadius;
          ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
      } else {
          ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
      }
      ctx.closePath();
      ctx.clip();
  }
  function toRadiusCorners(value) {
      return _readValueToProps(value, [
          'outerStart',
          'outerEnd',
          'innerStart',
          'innerEnd'
      ]);
  }
  /**
   * Parse border radius from the provided options
   */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
      const o = toRadiusCorners(arc.options.borderRadius);
      const halfThickness = (outerRadius - innerRadius) / 2;
      const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
      // Outer limits are complicated. We want to compute the available angular distance at
      // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
      // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
      //
      // If the borderRadius is large, that value can become negative.
      // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
      // we know that the thickness term will dominate and compute the limits at that point
      const computeOuterLimit = (val)=>{
          const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
          return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
      };
      return {
          outerStart: computeOuterLimit(o.outerStart),
          outerEnd: computeOuterLimit(o.outerEnd),
          innerStart: _limitValue(o.innerStart, 0, innerLimit),
          innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
      };
  }
  /**
   * Convert (r, 𝜃) to (x, y)
   */ function rThetaToXY(r, theta, x, y) {
      return {
          x: x + r * Math.cos(theta),
          y: y + r * Math.sin(theta)
      };
  }
  /**
   * Path the arc, respecting border radius by separating into left and right halves.
   *
   *   Start      End
   *
   *    1--->a--->2    Outer
   *   /           \
   *   8           3
   *   |           |
   *   |           |
   *   7           4
   *   \           /
   *    6<---b<---5    Inner
   */ function pathArc(ctx, element, offset, spacing, end, circular) {
      const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;
      const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
      const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
      let spacingOffset = 0;
      const alpha = end - start;
      if (spacing) {
          // When spacing is present, it is the same for all items
          // So we adjust the start and end angle of the arc such that
          // the distance is the same as it would be without the spacing
          const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
          const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
          const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
          const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
          spacingOffset = (alpha - adjustedAngle) / 2;
      }
      const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;
      const angleOffset = (alpha - beta) / 2;
      const startAngle = start + angleOffset + spacingOffset;
      const endAngle = end - angleOffset - spacingOffset;
      const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
      const outerStartAdjustedRadius = outerRadius - outerStart;
      const outerEndAdjustedRadius = outerRadius - outerEnd;
      const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
      const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
      const innerStartAdjustedRadius = innerRadius + innerStart;
      const innerEndAdjustedRadius = innerRadius + innerEnd;
      const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
      const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
      ctx.beginPath();
      if (circular) {
          // The first arc segments from point 1 to point a to point 2
          const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
          ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
          ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
          // The corner segment from point 2 to point 3
          if (outerEnd > 0) {
              const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
          }
          // The line from point 3 to point 4
          const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
          ctx.lineTo(p4.x, p4.y);
          // The corner segment from point 4 to point 5
          if (innerEnd > 0) {
              const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
          }
          // The inner arc from point 5 to point b to point 6
          const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
          ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
          ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
          // The corner segment from point 6 to point 7
          if (innerStart > 0) {
              const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
          }
          // The line from point 7 to point 8
          const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
          ctx.lineTo(p8.x, p8.y);
          // The corner segment from point 8 to point 1
          if (outerStart > 0) {
              const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
              ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
          }
      } else {
          ctx.moveTo(x, y);
          const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
          const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerStartX, outerStartY);
          const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
          const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
          ctx.lineTo(outerEndX, outerEndY);
      }
      ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
      const { fullCircles , startAngle , circumference  } = element;
      let endAngle = element.endAngle;
      if (fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          for(let i = 0; i < fullCircles; ++i){
              ctx.fill();
          }
          if (!isNaN(circumference)) {
              endAngle = startAngle + (circumference % TAU || TAU);
          }
      }
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.fill();
      return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
      const { fullCircles , startAngle , circumference , options  } = element;
      const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;
      const inner = options.borderAlign === 'inner';
      if (!borderWidth) {
          return;
      }
      ctx.setLineDash(borderDash || []);
      ctx.lineDashOffset = borderDashOffset;
      if (inner) {
          ctx.lineWidth = borderWidth * 2;
          ctx.lineJoin = borderJoinStyle || 'round';
      } else {
          ctx.lineWidth = borderWidth;
          ctx.lineJoin = borderJoinStyle || 'bevel';
      }
      let endAngle = element.endAngle;
      if (fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          for(let i = 0; i < fullCircles; ++i){
              ctx.stroke();
          }
          if (!isNaN(circumference)) {
              endAngle = startAngle + (circumference % TAU || TAU);
          }
      }
      if (inner) {
          clipArc(ctx, element, endAngle);
      }
      if (!fullCircles) {
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.stroke();
      }
  }
  class ArcElement extends Element {
      static id = 'arc';
      static defaults = {
          borderAlign: 'center',
          borderColor: '#fff',
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: undefined,
          borderRadius: 0,
          borderWidth: 2,
          offset: 0,
          spacing: 0,
          angle: undefined,
          circular: true
      };
      static defaultRoutes = {
          backgroundColor: 'backgroundColor'
      };
      static descriptors = {
          _scriptable: true,
          _indexable: (name)=>name !== 'borderDash'
      };
      circumference;
      endAngle;
      fullCircles;
      innerRadius;
      outerRadius;
      pixelMargin;
      startAngle;
      constructor(cfg){
          super();
          this.options = undefined;
          this.circumference = undefined;
          this.startAngle = undefined;
          this.endAngle = undefined;
          this.innerRadius = undefined;
          this.outerRadius = undefined;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
              Object.assign(this, cfg);
          }
      }
      inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps([
              'x',
              'y'
          ], useFinalPosition);
          const { angle , distance  } = getAngleFromPoint(point, {
              x: chartX,
              y: chartY
          });
          const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([
              'startAngle',
              'endAngle',
              'innerRadius',
              'outerRadius',
              'circumference'
          ], useFinalPosition);
          const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
          const _circumference = valueOrDefault(circumference, endAngle - startAngle);
          const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
          const betweenAngles = _circumference >= TAU || nonZeroBetween;
          const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
          return betweenAngles && withinRadius;
      }
      getCenterPoint(useFinalPosition) {
          const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([
              'x',
              'y',
              'startAngle',
              'endAngle',
              'innerRadius',
              'outerRadius'
          ], useFinalPosition);
          const { offset , spacing  } = this.options;
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
          return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius
          };
      }
      tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
      }
      draw(ctx) {
          const { options , circumference  } = this;
          const offset = (options.offset || 0) / 4;
          const spacing = (options.spacing || 0) / 2;
          const circular = options.circular;
          this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
          this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
          if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
              return;
          }
          ctx.save();
          const halfAngle = (this.startAngle + this.endAngle) / 2;
          ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
          const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
          const radiusOffset = offset * fix;
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          drawArc(ctx, this, radiusOffset, spacing, circular);
          drawBorder(ctx, this, radiusOffset, spacing, circular);
          ctx.restore();
      }
  }
  function setStyle(ctx, options, style = options) {
      ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
      ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
      ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
      ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
      ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
      ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
      ctx.lineTo(target.x, target.y);
  }
   function getLineMethod(options) {
      if (options.stepped) {
          return _steppedLineTo;
      }
      if (options.tension || options.cubicInterpolationMode === 'monotone') {
          return _bezierCurveTo;
      }
      return lineTo;
  }
  function pathVars(points, segment, params = {}) {
      const count = points.length;
      const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;
      const { start: segmentStart , end: segmentEnd  } = segment;
      const start = Math.max(paramsStart, segmentStart);
      const end = Math.min(paramsEnd, segmentEnd);
      const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
      return {
          count,
          start,
          loop: segment.loop,
          ilen: end < start && !outside ? count + end - start : end - start
      };
  }
   function pathSegment(ctx, line, segment, params) {
      const { points , options  } = line;
      const { count , start , loop , ilen  } = pathVars(points, segment, params);
      const lineMethod = getLineMethod(options);
      let { move =true , reverse  } = params || {};
      let i, point, prev;
      for(i = 0; i <= ilen; ++i){
          point = points[(start + (reverse ? ilen - i : i)) % count];
          if (point.skip) {
              continue;
          } else if (move) {
              ctx.moveTo(point.x, point.y);
              move = false;
          } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          prev = point;
      }
      if (loop) {
          point = points[(start + (reverse ? ilen : 0)) % count];
          lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      return !!loop;
  }
   function fastPathSegment(ctx, line, segment, params) {
      const points = line.points;
      const { count , start , ilen  } = pathVars(points, segment, params);
      const { move =true , reverse  } = params || {};
      let avgX = 0;
      let countX = 0;
      let i, point, prevX, minY, maxY, lastY;
      const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;
      const drawX = ()=>{
          if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
          }
      };
      if (move) {
          point = points[pointIndex(0)];
          ctx.moveTo(point.x, point.y);
      }
      for(i = 0; i <= ilen; ++i){
          point = points[pointIndex(i)];
          if (point.skip) {
              continue;
          }
          const x = point.x;
          const y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
              if (y < minY) {
                  minY = y;
              } else if (y > maxY) {
                  maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
          } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
          }
          lastY = y;
      }
      drawX();
  }
   function _getSegmentMethod(line) {
      const opts = line.options;
      const borderDash = opts.borderDash && opts.borderDash.length;
      const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
      return useFastPath ? fastPathSegment : pathSegment;
  }
   function _getInterpolationMethod(options) {
      if (options.stepped) {
          return _steppedInterpolation;
      }
      if (options.tension || options.cubicInterpolationMode === 'monotone') {
          return _bezierInterpolation;
      }
      return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
      let path = line._path;
      if (!path) {
          path = line._path = new Path2D();
          if (line.path(path, start, count)) {
              path.closePath();
          }
      }
      setStyle(ctx, line.options);
      ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
      const { segments , options  } = line;
      const segmentMethod = _getSegmentMethod(line);
      for (const segment of segments){
          setStyle(ctx, options, segment.style);
          ctx.beginPath();
          if (segmentMethod(ctx, line, segment, {
              start,
              end: start + count - 1
          })) {
              ctx.closePath();
          }
          ctx.stroke();
      }
  }
  const usePath2D = typeof Path2D === 'function';
  function draw(ctx, line, start, count) {
      if (usePath2D && !line.options.segment) {
          strokePathWithCache(ctx, line, start, count);
      } else {
          strokePathDirect(ctx, line, start, count);
      }
  }
  class LineElement extends Element {
      static id = 'line';
   static defaults = {
          borderCapStyle: 'butt',
          borderDash: [],
          borderDashOffset: 0,
          borderJoinStyle: 'miter',
          borderWidth: 3,
          capBezierPoints: true,
          cubicInterpolationMode: 'default',
          fill: false,
          spanGaps: false,
          stepped: false,
          tension: 0
      };
   static defaultRoutes = {
          backgroundColor: 'backgroundColor',
          borderColor: 'borderColor'
      };
      static descriptors = {
          _scriptable: true,
          _indexable: (name)=>name !== 'borderDash' && name !== 'fill'
      };
      constructor(cfg){
          super();
          this.animated = true;
          this.options = undefined;
          this._chart = undefined;
          this._loop = undefined;
          this._fullLoop = undefined;
          this._path = undefined;
          this._points = undefined;
          this._segments = undefined;
          this._decimated = false;
          this._pointsUpdated = false;
          this._datasetIndex = undefined;
          if (cfg) {
              Object.assign(this, cfg);
          }
      }
      updateControlPoints(chartArea, indexAxis) {
          const options = this.options;
          if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
              this._pointsUpdated = true;
          }
      }
      set points(points) {
          this._points = points;
          delete this._segments;
          delete this._path;
          this._pointsUpdated = false;
      }
      get points() {
          return this._points;
      }
      get segments() {
          return this._segments || (this._segments = _computeSegments(this, this.options.segment));
      }
   first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
      }
   last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
      }
   interpolate(point, property) {
          const options = this.options;
          const value = point[property];
          const points = this.points;
          const segments = _boundSegments(this, {
              property,
              start: value,
              end: value
          });
          if (!segments.length) {
              return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options);
          let i, ilen;
          for(i = 0, ilen = segments.length; i < ilen; ++i){
              const { start , end  } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                  result.push(p1);
                  continue;
              }
              const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
      }
   pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
      }
   path(ctx, start, count) {
          const segments = this.segments;
          const segmentMethod = _getSegmentMethod(this);
          let loop = this._loop;
          start = start || 0;
          count = count || this.points.length - start;
          for (const segment of segments){
              loop &= segmentMethod(ctx, this, segment, {
                  start,
                  end: start + count - 1
              });
          }
          return !!loop;
      }
   draw(ctx, chartArea, start, count) {
          const options = this.options || {};
          const points = this.points || [];
          if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
          }
          if (this.animated) {
              this._pointsUpdated = false;
              this._path = undefined;
          }
      }
  }
  function inRange$1(el, pos, axis, useFinalPosition) {
      const options = el.options;
      const { [axis]: value  } = el.getProps([
          axis
      ], useFinalPosition);
      return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  class PointElement extends Element {
      static id = 'point';
      parsed;
      skip;
      stop;
      /**
     * @type {any}
     */ static defaults = {
          borderWidth: 1,
          hitRadius: 1,
          hoverBorderWidth: 1,
          hoverRadius: 4,
          pointStyle: 'circle',
          radius: 3,
          rotation: 0
      };
      /**
     * @type {any}
     */ static defaultRoutes = {
          backgroundColor: 'backgroundColor',
          borderColor: 'borderColor'
      };
      constructor(cfg){
          super();
          this.options = undefined;
          this.parsed = undefined;
          this.skip = undefined;
          this.stop = undefined;
          if (cfg) {
              Object.assign(this, cfg);
          }
      }
      inRange(mouseX, mouseY, useFinalPosition) {
          const options = this.options;
          const { x , y  } = this.getProps([
              'x',
              'y'
          ], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
      }
      inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, 'x', useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, 'y', useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
          const { x , y  } = this.getProps([
              'x',
              'y'
          ], useFinalPosition);
          return {
              x,
              y
          };
      }
      size(options) {
          options = options || this.options || {};
          let radius = options.radius || 0;
          radius = Math.max(radius, radius && options.hoverRadius || 0);
          const borderWidth = radius && options.borderWidth || 0;
          return (radius + borderWidth) * 2;
      }
      draw(ctx, area) {
          const options = this.options;
          if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
              return;
          }
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.fillStyle = options.backgroundColor;
          drawPoint(ctx, options, this.x, this.y);
      }
      getRange() {
          const options = this.options || {};
          // @ts-expect-error Fallbacks should never be hit in practice
          return options.radius + options.hitRadius;
      }
  }
  function getBarBounds(bar, useFinalPosition) {
      const { x , y , base , width , height  } =  bar.getProps([
          'x',
          'y',
          'base',
          'width',
          'height'
      ], useFinalPosition);
      let left, right, top, bottom, half;
      if (bar.horizontal) {
          half = height / 2;
          left = Math.min(x, base);
          right = Math.max(x, base);
          top = y - half;
          bottom = y + half;
      } else {
          half = width / 2;
          left = x - half;
          right = x + half;
          top = Math.min(y, base);
          bottom = Math.max(y, base);
      }
      return {
          left,
          top,
          right,
          bottom
      };
  }
  function skipOrLimit(skip, value, min, max) {
      return skip ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
      const value = bar.options.borderWidth;
      const skip = bar.borderSkipped;
      const o = toTRBL(value);
      return {
          t: skipOrLimit(skip.top, o.top, 0, maxH),
          r: skipOrLimit(skip.right, o.right, 0, maxW),
          b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
          l: skipOrLimit(skip.left, o.left, 0, maxW)
      };
  }
  function parseBorderRadius(bar, maxW, maxH) {
      const { enableBorderRadius  } = bar.getProps([
          'enableBorderRadius'
      ]);
      const value = bar.options.borderRadius;
      const o = toTRBLCorners(value);
      const maxR = Math.min(maxW, maxH);
      const skip = bar.borderSkipped;
      const enableBorder = enableBorderRadius || isObject$1(value);
      return {
          topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
          topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
          bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
          bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
      };
  }
  function boundingRects(bar) {
      const bounds = getBarBounds(bar);
      const width = bounds.right - bounds.left;
      const height = bounds.bottom - bounds.top;
      const border = parseBorderWidth(bar, width / 2, height / 2);
      const radius = parseBorderRadius(bar, width / 2, height / 2);
      return {
          outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius
          },
          inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                  topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                  topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                  bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                  bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
              }
          }
      };
  }
  function inRange(bar, x, y, useFinalPosition) {
      const skipX = x === null;
      const skipY = y === null;
      const skipBoth = skipX && skipY;
      const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
      return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
      return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
   function addNormalRectPath(ctx, rect) {
      ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
      const x = rect.x !== refRect.x ? -amount : 0;
      const y = rect.y !== refRect.y ? -amount : 0;
      const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
      const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
      return {
          x: rect.x + x,
          y: rect.y + y,
          w: rect.w + w,
          h: rect.h + h,
          radius: rect.radius
      };
  }
  class BarElement extends Element {
      static id = 'bar';
   static defaults = {
          borderSkipped: 'start',
          borderWidth: 0,
          borderRadius: 0,
          inflateAmount: 'auto',
          pointStyle: undefined
      };
   static defaultRoutes = {
          backgroundColor: 'backgroundColor',
          borderColor: 'borderColor'
      };
      constructor(cfg){
          super();
          this.options = undefined;
          this.horizontal = undefined;
          this.base = undefined;
          this.width = undefined;
          this.height = undefined;
          this.inflateAmount = undefined;
          if (cfg) {
              Object.assign(this, cfg);
          }
      }
      draw(ctx) {
          const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;
          const { inner , outer  } = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill('evenodd');
          }
          ctx.beginPath();
          addRectPath(ctx, inflateRect(inner, inflateAmount));
          ctx.fillStyle = backgroundColor;
          ctx.fill();
          ctx.restore();
      }
      inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
      }
      inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
      }
      inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
      }
      getCenterPoint(useFinalPosition) {
          const { x , y , base , horizontal  } =  this.getProps([
              'x',
              'y',
              'base',
              'horizontal'
          ], useFinalPosition);
          return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2
          };
      }
      getRange(axis) {
          return axis === 'x' ? this.width / 2 : this.height / 2;
      }
  }
  var elements = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArcElement: ArcElement,
  BarElement: BarElement,
  LineElement: LineElement,
  PointElement: PointElement
  });
  const BORDER_COLORS = [
      'rgb(54, 162, 235)',
      'rgb(255, 99, 132)',
      'rgb(255, 159, 64)',
      'rgb(255, 205, 86)',
      'rgb(75, 192, 192)',
      'rgb(153, 102, 255)',
      'rgb(201, 203, 207)' // grey
  ];
  // Border colors with 50% transparency
  const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));
  function getBorderColor(i) {
      return BORDER_COLORS[i % BORDER_COLORS.length];
  }
  function getBackgroundColor(i) {
      return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i) {
      dataset.borderColor = getBorderColor(i);
      dataset.backgroundColor = getBackgroundColor(i);
      return ++i;
  }
  function colorizeDoughnutDataset(dataset, i) {
      dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));
      return i;
  }
  function colorizePolarAreaDataset(dataset, i) {
      dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));
      return i;
  }
  function getColorizer(chart) {
      let i = 0;
      return (dataset, datasetIndex)=>{
          const controller = chart.getDatasetMeta(datasetIndex).controller;
          if (controller instanceof DoughnutController) {
              i = colorizeDoughnutDataset(dataset, i);
          } else if (controller instanceof PolarAreaController) {
              i = colorizePolarAreaDataset(dataset, i);
          } else if (controller) {
              i = colorizeDefaultDataset(dataset, i);
          }
      };
  }
  function containsColorsDefinitions(descriptors) {
      let k;
      for(k in descriptors){
          if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
              return true;
          }
      }
      return false;
  }
  function containsColorsDefinition(descriptor) {
      return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  function containsDefaultColorsDefenitions() {
      return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';
  }
  var plugin_colors = {
      id: 'colors',
      defaults: {
          enabled: true,
          forceOverride: false
      },
      beforeLayout (chart, _args, options) {
          if (!options.enabled) {
              return;
          }
          const { data: { datasets  } , options: chartOptions  } = chart.config;
          const { elements  } = chartOptions;
          const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
          if (!options.forceOverride && containsColorDefenition) {
              return;
          }
          const colorizer = getColorizer(chart);
          datasets.forEach(colorizer);
      }
  };
  function lttbDecimation(data, start, count, availableWidth, options) {
   const samples = options.samples || availableWidth;
      if (samples >= count) {
          return data.slice(start, start + count);
      }
      const decimated = [];
      const bucketWidth = (count - 2) / (samples - 2);
      let sampledIndex = 0;
      const endIndex = start + count - 1;
      let a = start;
      let i, maxAreaPoint, maxArea, area, nextA;
      decimated[sampledIndex++] = data[a];
      for(i = 0; i < samples - 2; i++){
          let avgX = 0;
          let avgY = 0;
          let j;
          const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
          const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
          const avgRangeLength = avgRangeEnd - avgRangeStart;
          for(j = avgRangeStart; j < avgRangeEnd; j++){
              avgX += data[j].x;
              avgY += data[j].y;
          }
          avgX /= avgRangeLength;
          avgY /= avgRangeLength;
          const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
          const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
          const { x: pointAx , y: pointAy  } = data[a];
          maxArea = area = -1;
          for(j = rangeOffs; j < rangeTo; j++){
              area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
              if (area > maxArea) {
                  maxArea = area;
                  maxAreaPoint = data[j];
                  nextA = j;
              }
          }
          decimated[sampledIndex++] = maxAreaPoint;
          a = nextA;
      }
      decimated[sampledIndex++] = data[endIndex];
      return decimated;
  }
  function minMaxDecimation(data, start, count, availableWidth) {
      let avgX = 0;
      let countX = 0;
      let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
      const decimated = [];
      const endIndex = start + count - 1;
      const xMin = data[start].x;
      const xMax = data[endIndex].x;
      const dx = xMax - xMin;
      for(i = start; i < start + count; ++i){
          point = data[i];
          x = (point.x - xMin) / dx * availableWidth;
          y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
              if (y < minY) {
                  minY = y;
                  minIndex = i;
              } else if (y > maxY) {
                  maxY = y;
                  maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
          } else {
              const lastIndex = i - 1;
              if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                  const intermediateIndex1 = Math.min(minIndex, maxIndex);
                  const intermediateIndex2 = Math.max(minIndex, maxIndex);
                  if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                      decimated.push({
                          ...data[intermediateIndex1],
                          x: avgX
                      });
                  }
                  if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                      decimated.push({
                          ...data[intermediateIndex2],
                          x: avgX
                      });
                  }
              }
              if (i > 0 && lastIndex !== startIndex) {
                  decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
          }
      }
      return decimated;
  }
  function cleanDecimatedDataset(dataset) {
      if (dataset._decimated) {
          const data = dataset._data;
          delete dataset._decimated;
          delete dataset._data;
          Object.defineProperty(dataset, 'data', {
              configurable: true,
              enumerable: true,
              writable: true,
              value: data
          });
      }
  }
  function cleanDecimatedData(chart) {
      chart.data.datasets.forEach((dataset)=>{
          cleanDecimatedDataset(dataset);
      });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
      const pointCount = points.length;
      let start = 0;
      let count;
      const { iScale  } = meta;
      const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();
      if (minDefined) {
          start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
      }
      if (maxDefined) {
          count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
      } else {
          count = pointCount - start;
      }
      return {
          start,
          count
      };
  }
  var plugin_decimation = {
      id: 'decimation',
      defaults: {
          algorithm: 'min-max',
          enabled: false
      },
      beforeElementsUpdate: (chart, args, options)=>{
          if (!options.enabled) {
              cleanDecimatedData(chart);
              return;
          }
          const availableWidth = chart.width;
          chart.data.datasets.forEach((dataset, datasetIndex)=>{
              const { _data , indexAxis  } = dataset;
              const meta = chart.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (resolve([
                  indexAxis,
                  chart.options.indexAxis
              ]) === 'y') {
                  return;
              }
              if (!meta.controller.supportsDecimation) {
                  return;
              }
              const xAxis = chart.scales[meta.xAxisID];
              if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                  return;
              }
              if (chart.options.parsing) {
                  return;
              }
              let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                  cleanDecimatedDataset(dataset);
                  return;
              }
              if (isNullOrUndef(_data)) {
                  dataset._data = data;
                  delete dataset.data;
                  Object.defineProperty(dataset, 'data', {
                      configurable: true,
                      enumerable: true,
                      get: function() {
                          return this._decimated;
                      },
                      set: function(d) {
                          this._data = d;
                      }
                  });
              }
              let decimated;
              switch(options.algorithm){
                  case 'lttb':
                      decimated = lttbDecimation(data, start, count, availableWidth, options);
                      break;
                  case 'min-max':
                      decimated = minMaxDecimation(data, start, count, availableWidth);
                      break;
                  default:
                      throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
              }
              dataset._decimated = decimated;
          });
      },
      destroy (chart) {
          cleanDecimatedData(chart);
      }
  };
  function _segments(line, target, property) {
      const segments = line.segments;
      const points = line.points;
      const tpoints = target.points;
      const parts = [];
      for (const segment of segments){
          let { start , end  } = segment;
          end = _findSegmentEnd(start, end, points);
          const bounds = _getBounds(property, points[start], points[end], segment.loop);
          if (!target.segments) {
              parts.push({
                  source: segment,
                  target: bounds,
                  start: points[start],
                  end: points[end]
              });
              continue;
          }
          const targetSegments = _boundSegments(target, bounds);
          for (const tgt of targetSegments){
              const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
              const fillSources = _boundSegment(segment, points, subBounds);
              for (const fillSource of fillSources){
                  parts.push({
                      source: fillSource,
                      target: tgt,
                      start: {
                          [property]: _getEdge(bounds, subBounds, 'start', Math.max)
                      },
                      end: {
                          [property]: _getEdge(bounds, subBounds, 'end', Math.min)
                      }
                  });
              }
          }
      }
      return parts;
  }
  function _getBounds(property, first, last, loop) {
      if (loop) {
          return;
      }
      let start = first[property];
      let end = last[property];
      if (property === 'angle') {
          start = _normalizeAngle(start);
          end = _normalizeAngle(end);
      }
      return {
          property,
          start,
          end
      };
  }
  function _pointsFromSegments(boundary, line) {
      const { x =null , y =null  } = boundary || {};
      const linePoints = line.points;
      const points = [];
      line.segments.forEach(({ start , end  })=>{
          end = _findSegmentEnd(start, end, linePoints);
          const first = linePoints[start];
          const last = linePoints[end];
          if (y !== null) {
              points.push({
                  x: first.x,
                  y
              });
              points.push({
                  x: last.x,
                  y
              });
          } else if (x !== null) {
              points.push({
                  x,
                  y: first.y
              });
              points.push({
                  x,
                  y: last.y
              });
          }
      });
      return points;
  }
  function _findSegmentEnd(start, end, points) {
      for(; end > start; end--){
          const point = points[end];
          if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
          }
      }
      return end;
  }
  function _getEdge(a, b, prop, fn) {
      if (a && b) {
          return fn(a[prop], b[prop]);
      }
      return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
      let points = [];
      let _loop = false;
      if (isArray$1(boundary)) {
          _loop = true;
          points = boundary;
      } else {
          points = _pointsFromSegments(boundary, line);
      }
      return points.length ? new LineElement({
          points,
          options: {
              tension: 0
          },
          _loop,
          _fullLoop: _loop
      }) : null;
  }
  function _shouldApplyFill(source) {
      return source && source.fill !== false;
  }
  function _resolveTarget(sources, index, propagate) {
      const source = sources[index];
      let fill = source.fill;
      const visited = [
          index
      ];
      let target;
      if (!propagate) {
          return fill;
      }
      while(fill !== false && visited.indexOf(fill) === -1){
          if (!isNumberFinite(fill)) {
              return fill;
          }
          target = sources[fill];
          if (!target) {
              return false;
          }
          if (target.visible) {
              return fill;
          }
          visited.push(fill);
          fill = target.fill;
      }
      return false;
  }
   function _decodeFill(line, index, count) {
       const fill = parseFillOption(line);
      if (isObject$1(fill)) {
          return isNaN(fill.value) ? false : fill;
      }
      let target = parseFloat(fill);
      if (isNumberFinite(target) && Math.floor(target) === target) {
          return decodeTargetIndex(fill[0], index, target, count);
      }
      return [
          'origin',
          'start',
          'end',
          'stack',
          'shape'
      ].indexOf(fill) >= 0 && fill;
  }
  function decodeTargetIndex(firstCh, index, target, count) {
      if (firstCh === '-' || firstCh === '+') {
          target = index + target;
      }
      if (target === index || target < 0 || target >= count) {
          return false;
      }
      return target;
  }
   function _getTargetPixel(fill, scale) {
      let pixel = null;
      if (fill === 'start') {
          pixel = scale.bottom;
      } else if (fill === 'end') {
          pixel = scale.top;
      } else if (isObject$1(fill)) {
          pixel = scale.getPixelForValue(fill.value);
      } else if (scale.getBasePixel) {
          pixel = scale.getBasePixel();
      }
      return pixel;
  }
   function _getTargetValue(fill, scale, startValue) {
      let value;
      if (fill === 'start') {
          value = startValue;
      } else if (fill === 'end') {
          value = scale.options.reverse ? scale.min : scale.max;
      } else if (isObject$1(fill)) {
          value = fill.value;
      } else {
          value = scale.getBaseValue();
      }
      return value;
  }
   function parseFillOption(line) {
      const options = line.options;
      const fillOption = options.fill;
      let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
      if (fill === undefined) {
          fill = !!options.backgroundColor;
      }
      if (fill === false || fill === null) {
          return false;
      }
      if (fill === true) {
          return 'origin';
      }
      return fill;
  }
  function _buildStackLine(source) {
      const { scale , index , line  } = source;
      const points = [];
      const segments = line.segments;
      const sourcePoints = line.points;
      const linesBelow = getLinesBelow(scale, index);
      linesBelow.push(_createBoundaryLine({
          x: null,
          y: scale.bottom
      }, line));
      for(let i = 0; i < segments.length; i++){
          const segment = segments[i];
          for(let j = segment.start; j <= segment.end; j++){
              addPointsBelow(points, sourcePoints[j], linesBelow);
          }
      }
      return new LineElement({
          points,
          options: {}
      });
  }
   function getLinesBelow(scale, index) {
      const below = [];
      const metas = scale.getMatchingVisibleMetas('line');
      for(let i = 0; i < metas.length; i++){
          const meta = metas[i];
          if (meta.index === index) {
              break;
          }
          if (!meta.hidden) {
              below.unshift(meta.dataset);
          }
      }
      return below;
  }
   function addPointsBelow(points, sourcePoint, linesBelow) {
      const postponed = [];
      for(let j = 0; j < linesBelow.length; j++){
          const line = linesBelow[j];
          const { first , last , point  } = findPoint(line, sourcePoint, 'x');
          if (!point || first && last) {
              continue;
          }
          if (first) {
              postponed.unshift(point);
          } else {
              points.push(point);
              if (!last) {
                  break;
              }
          }
      }
      points.push(...postponed);
  }
   function findPoint(line, sourcePoint, property) {
      const point = line.interpolate(sourcePoint, property);
      if (!point) {
          return {};
      }
      const pointValue = point[property];
      const segments = line.segments;
      const linePoints = line.points;
      let first = false;
      let last = false;
      for(let i = 0; i < segments.length; i++){
          const segment = segments[i];
          const firstValue = linePoints[segment.start][property];
          const lastValue = linePoints[segment.end][property];
          if (_isBetween(pointValue, firstValue, lastValue)) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
          }
      }
      return {
          first,
          last,
          point
      };
  }
  class simpleArc {
      constructor(opts){
          this.x = opts.x;
          this.y = opts.y;
          this.radius = opts.radius;
      }
      pathSegment(ctx, bounds, opts) {
          const { x , y , radius  } = this;
          bounds = bounds || {
              start: 0,
              end: TAU
          };
          ctx.arc(x, y, radius, bounds.end, bounds.start, true);
          return !opts.bounds;
      }
      interpolate(point) {
          const { x , y , radius  } = this;
          const angle = point.angle;
          return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle
          };
      }
  }
  function _getTarget(source) {
      const { chart , fill , line  } = source;
      if (isNumberFinite(fill)) {
          return getLineByIndex(chart, fill);
      }
      if (fill === 'stack') {
          return _buildStackLine(source);
      }
      if (fill === 'shape') {
          return true;
      }
      const boundary = computeBoundary(source);
      if (boundary instanceof simpleArc) {
          return boundary;
      }
      return _createBoundaryLine(boundary, line);
  }
   function getLineByIndex(chart, index) {
      const meta = chart.getDatasetMeta(index);
      const visible = meta && chart.isDatasetVisible(index);
      return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
      const scale = source.scale || {};
      if (scale.getPointPositionForValue) {
          return computeCircularBoundary(source);
      }
      return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
      const { scale ={} , fill  } = source;
      const pixel = _getTargetPixel(fill, scale);
      if (isNumberFinite(pixel)) {
          const horizontal = scale.isHorizontal();
          return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel
          };
      }
      return null;
  }
  function computeCircularBoundary(source) {
      const { scale , fill  } = source;
      const options = scale.options;
      const length = scale.getLabels().length;
      const start = options.reverse ? scale.max : scale.min;
      const value = _getTargetValue(fill, scale, start);
      const target = [];
      if (options.grid.circular) {
          const center = scale.getPointPositionForValue(0, start);
          return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value)
          });
      }
      for(let i = 0; i < length; ++i){
          target.push(scale.getPointPositionForValue(i, value));
      }
      return target;
  }
  function _drawfill(ctx, source, area) {
      const target = _getTarget(source);
      const { line , scale , axis  } = source;
      const lineOpts = line.options;
      const fillOption = lineOpts.fill;
      const color = lineOpts.backgroundColor;
      const { above =color , below =color  } = fillOption || {};
      if (target && line.points.length) {
          clipArea(ctx, area);
          doFill(ctx, {
              line,
              target,
              above,
              below,
              area,
              scale,
              axis
          });
          unclipArea(ctx);
      }
  }
  function doFill(ctx, cfg) {
      const { line , target , above , below , area , scale  } = cfg;
      const property = line._loop ? 'angle' : cfg.axis;
      ctx.save();
      if (property === 'x' && below !== above) {
          clipVertical(ctx, target, area.top);
          fill(ctx, {
              line,
              target,
              color: above,
              scale,
              property
          });
          ctx.restore();
          ctx.save();
          clipVertical(ctx, target, area.bottom);
      }
      fill(ctx, {
          line,
          target,
          color: below,
          scale,
          property
      });
      ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
      const { segments , points  } = target;
      let first = true;
      let lineLoop = false;
      ctx.beginPath();
      for (const segment of segments){
          const { start , end  } = segment;
          const firstPoint = points[start];
          const lastPoint = points[_findSegmentEnd(start, end, points)];
          if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
          } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
          }
          lineLoop = !!target.pathSegment(ctx, segment, {
              move: lineLoop
          });
          if (lineLoop) {
              ctx.closePath();
          } else {
              ctx.lineTo(lastPoint.x, clipY);
          }
      }
      ctx.lineTo(target.first().x, clipY);
      ctx.closePath();
      ctx.clip();
  }
  function fill(ctx, cfg) {
      const { line , target , property , color , scale  } = cfg;
      const segments = _segments(line, target, property);
      for (const { source: src , target: tgt , start , end  } of segments){
          const { style: { backgroundColor =color  } = {}  } = src;
          const notShape = target !== true;
          ctx.save();
          ctx.fillStyle = backgroundColor;
          clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
          ctx.beginPath();
          const lineLoop = !!line.pathSegment(ctx, src);
          let loop;
          if (notShape) {
              if (lineLoop) {
                  ctx.closePath();
              } else {
                  interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, {
                  move: lineLoop,
                  reverse: true
              });
              loop = lineLoop && targetLoop;
              if (!loop) {
                  interpolatedLineTo(ctx, target, start, property);
              }
          }
          ctx.closePath();
          ctx.fill(loop ? 'evenodd' : 'nonzero');
          ctx.restore();
      }
  }
  function clipBounds(ctx, scale, bounds) {
      const { top , bottom  } = scale.chart.chartArea;
      const { property , start , end  } = bounds || {};
      if (property === 'x') {
          ctx.beginPath();
          ctx.rect(start, top, end - start, bottom - top);
          ctx.clip();
      }
  }
  function interpolatedLineTo(ctx, target, point, property) {
      const interpolatedPoint = target.interpolate(point, property);
      if (interpolatedPoint) {
          ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
      }
  }
  var index = {
      id: 'filler',
      afterDatasetsUpdate (chart, _args, options) {
          const count = (chart.data.datasets || []).length;
          const sources = [];
          let meta, i, line, source;
          for(i = 0; i < count; ++i){
              meta = chart.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                  source = {
                      visible: chart.isDatasetVisible(i),
                      index: i,
                      fill: _decodeFill(line, i, count),
                      chart,
                      axis: meta.controller.options.indexAxis,
                      scale: meta.vScale,
                      line
                  };
              }
              meta.$filler = source;
              sources.push(source);
          }
          for(i = 0; i < count; ++i){
              source = sources[i];
              if (!source || source.fill === false) {
                  continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
          }
      },
      beforeDraw (chart, _args, options) {
          const draw = options.drawTime === 'beforeDraw';
          const metasets = chart.getSortedVisibleDatasetMetas();
          const area = chart.chartArea;
          for(let i = metasets.length - 1; i >= 0; --i){
              const source = metasets[i].$filler;
              if (!source) {
                  continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw && source.fill) {
                  _drawfill(chart.ctx, source, area);
              }
          }
      },
      beforeDatasetsDraw (chart, _args, options) {
          if (options.drawTime !== 'beforeDatasetsDraw') {
              return;
          }
          const metasets = chart.getSortedVisibleDatasetMetas();
          for(let i = metasets.length - 1; i >= 0; --i){
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                  _drawfill(chart.ctx, source, chart.chartArea);
              }
          }
      },
      beforeDatasetDraw (chart, args, options) {
          const source = args.meta.$filler;
          if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {
              return;
          }
          _drawfill(chart.ctx, source, chart.chartArea);
      },
      defaults: {
          propagate: true,
          drawTime: 'beforeDatasetDraw'
      }
  };
  const getBoxSize = (labelOpts, fontSize)=>{
      let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;
      if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
      }
      return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
      };
  };
  const itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  class Legend extends Element {
   constructor(config){
          super();
          this._added = false;
          this.legendHitBoxes = [];
   this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this.legendItems = undefined;
          this.columnSizes = undefined;
          this.lineWidths = undefined;
          this.maxHeight = undefined;
          this.maxWidth = undefined;
          this.top = undefined;
          this.bottom = undefined;
          this.left = undefined;
          this.right = undefined;
          this.height = undefined;
          this.width = undefined;
          this._margins = undefined;
          this.position = undefined;
          this.weight = undefined;
          this.fullSize = undefined;
      }
      update(maxWidth, maxHeight, margins) {
          this.maxWidth = maxWidth;
          this.maxHeight = maxHeight;
          this._margins = margins;
          this.setDimensions();
          this.buildLabels();
          this.fit();
      }
      setDimensions() {
          if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
          } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
          }
      }
      buildLabels() {
          const labelOpts = this.options.labels || {};
          let legendItems = callback(labelOpts.generateLabels, [
              this.chart
          ], this) || [];
          if (labelOpts.filter) {
              legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));
          }
          if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));
          }
          if (this.options.reverse) {
              legendItems.reverse();
          }
          this.legendItems = legendItems;
      }
      fit() {
          const { options , ctx  } = this;
          if (!options.display) {
              this.width = this.height = 0;
              return;
          }
          const labelOpts = options.labels;
          const labelFont = toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = this._computeTitleHeight();
          const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (this.isHorizontal()) {
              width = this.maxWidth;
              height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
              height = this.maxHeight;
              width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
          }
          this.width = Math.min(width, options.maxWidth || this.maxWidth);
          this.height = Math.min(height, options.maxHeight || this.maxHeight);
      }
   _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;
          const hitboxes = this.legendHitBoxes = [];
          const lineWidths = this.lineWidths = [
              0
          ];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          let row = -1;
          let top = -lineHeight;
          this.legendItems.forEach((legendItem, i)=>{
              const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
              if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                  totalHeight += lineHeight;
                  lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                  top += lineHeight;
                  row++;
              }
              hitboxes[i] = {
                  left: 0,
                  top,
                  row,
                  width: itemWidth,
                  height: itemHeight
              };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
      }
      _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
          const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;
          const hitboxes = this.legendHitBoxes = [];
          const columnSizes = this.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let col = 0;
          this.legendItems.forEach((legendItem, i)=>{
              const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
              if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                  totalWidth += currentColWidth + padding;
                  columnSizes.push({
                      width: currentColWidth,
                      height: currentColHeight
                  });
                  left += currentColWidth + padding;
                  col++;
                  currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = {
                  left,
                  top: currentColHeight,
                  col,
                  width: itemWidth,
                  height: itemHeight
              };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({
              width: currentColWidth,
              height: currentColHeight
          });
          return totalWidth;
      }
      adjustHitBoxes() {
          if (!this.options.display) {
              return;
          }
          const titleHeight = this._computeTitleHeight();
          const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;
          const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
          if (this.isHorizontal()) {
              let row = 0;
              let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
              for (const hitbox of hitboxes){
                  if (row !== hitbox.row) {
                      row = hitbox.row;
                      left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                  }
                  hitbox.top += this.top + titleHeight + padding;
                  hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                  left += hitbox.width + padding;
              }
          } else {
              let col = 0;
              let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
              for (const hitbox of hitboxes){
                  if (hitbox.col !== col) {
                      col = hitbox.col;
                      top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                  }
                  hitbox.top = top;
                  hitbox.left += this.left + padding;
                  hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                  top += hitbox.height + padding;
              }
          }
      }
      isHorizontal() {
          return this.options.position === 'top' || this.options.position === 'bottom';
      }
      draw() {
          if (this.options.display) {
              const ctx = this.ctx;
              clipArea(ctx, this);
              this._draw();
              unclipArea(ctx);
          }
      }
   _draw() {
          const { options: opts , columnSizes , lineWidths , ctx  } = this;
          const { align , labels: labelOpts  } = opts;
          const defaultColor = defaults.color;
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const labelFont = toFont(labelOpts.font);
          const { padding  } = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          this.drawTitle();
          ctx.textAlign = rtlHelper.textAlign('left');
          ctx.textBaseline = 'middle';
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function(x, y, legendItem) {
              if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
                  return;
              }
              ctx.save();
              const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
              ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
              ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');
              ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
              ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
              ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
              if (labelOpts.usePointStyle) {
                  const drawOptions = {
                      radius: boxHeight * Math.SQRT2 / 2,
                      pointStyle: legendItem.pointStyle,
                      rotation: legendItem.rotation,
                      borderWidth: lineWidth
                  };
                  const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                  const centerY = y + halfFontSize;
                  drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
              } else {
                  const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                  const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                  const borderRadius = toTRBLCorners(legendItem.borderRadius);
                  ctx.beginPath();
                  if (Object.values(borderRadius).some((v)=>v !== 0)) {
                      addRoundedRectPath(ctx, {
                          x: xBoxLeft,
                          y: yBoxTop,
                          w: boxWidth,
                          h: boxHeight,
                          radius: borderRadius
                      });
                  } else {
                      ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                  }
                  ctx.fill();
                  if (lineWidth !== 0) {
                      ctx.stroke();
                  }
              }
              ctx.restore();
          };
          const fillText = function(x, y, legendItem) {
              renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                  strikethrough: legendItem.hidden,
                  textAlign: rtlHelper.textAlign(legendItem.textAlign)
              });
          };
          const isHorizontal = this.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
              cursor = {
                  x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                  y: this.top + padding + titleHeight,
                  line: 0
              };
          } else {
              cursor = {
                  x: this.left + padding,
                  y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                  line: 0
              };
          }
          overrideTextDirection(this.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          this.legendItems.forEach((legendItem, i)=>{
              ctx.strokeStyle = legendItem.fontColor;
              ctx.fillStyle = legendItem.fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                  if (i > 0 && x + width + padding > this.right) {
                      y = cursor.y += lineHeight;
                      cursor.line++;
                      x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                  }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                  x = cursor.x = x + columnSizes[cursor.line].width + padding;
                  cursor.line++;
                  y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                  cursor.x += width + padding;
              } else if (typeof legendItem.text !== 'string') {
                  const fontLineHeight = labelFont.lineHeight;
                  cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
              } else {
                  cursor.y += lineHeight;
              }
          });
          restoreTextDirection(this.ctx, opts.textDirection);
      }
   drawTitle() {
          const opts = this.options;
          const titleOpts = opts.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) {
              return;
          }
          const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
          const ctx = this.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = this.left;
          let maxWidth = this.width;
          if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = _alignStartEnd(opts.align, left, this.right - maxWidth);
          } else {
              const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);
              y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
          ctx.textBaseline = 'middle';
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          renderText(ctx, titleOpts.text, x, y, titleFont);
      }
   _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
      }
   _getLegendItemAt(x, y) {
          let i, hitBox, lh;
          if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
              lh = this.legendHitBoxes;
              for(i = 0; i < lh.length; ++i){
                  hitBox = lh[i];
                  if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
                      return this.legendItems[i];
                  }
              }
          }
          return null;
      }
   handleEvent(e) {
          const opts = this.options;
          if (!isListened(e.type, opts)) {
              return;
          }
          const hoveredItem = this._getLegendItemAt(e.x, e.y);
          if (e.type === 'mousemove' || e.type === 'mouseout') {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                  callback(opts.onLeave, [
                      e,
                      previous,
                      this
                  ], this);
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                  callback(opts.onHover, [
                      e,
                      hoveredItem,
                      this
                  ], this);
              }
          } else if (hoveredItem) {
              callback(opts.onClick, [
                  e,
                  hoveredItem,
                  this
              ], this);
          }
      }
  }
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
      const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
      const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
      return {
          itemWidth,
          itemHeight
      };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
      let legendItemText = legendItem.text;
      if (legendItemText && typeof legendItemText !== 'string') {
          legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);
      }
      return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
      let itemHeight = _itemHeight;
      if (typeof legendItem.text !== 'string') {
          itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
      }
      return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
      const labelHeight = legendItem.text ? legendItem.text.length : 0;
      return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
      if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {
          return true;
      }
      if (opts.onClick && (type === 'click' || type === 'mouseup')) {
          return true;
      }
      return false;
  }
  var plugin_legend = {
      id: 'legend',
   _element: Legend,
      start (chart, _args, options) {
          const legend = chart.legend = new Legend({
              ctx: chart.ctx,
              options,
              chart
          });
          layouts.configure(chart, legend, options);
          layouts.addBox(chart, legend);
      },
      stop (chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
      },
      beforeUpdate (chart, _args, options) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options);
          legend.options = options;
      },
      afterUpdate (chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
      },
      afterEvent (chart, args) {
          if (!args.replay) {
              chart.legend.handleEvent(args.event);
          }
      },
      defaults: {
          display: true,
          position: 'top',
          align: 'center',
          fullSize: true,
          reverse: false,
          weight: 1000,
          onClick (e, legendItem, legend) {
              const index = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index)) {
                  ci.hide(index);
                  legendItem.hidden = true;
              } else {
                  ci.show(index);
                  legendItem.hidden = false;
              }
          },
          onHover: null,
          onLeave: null,
          labels: {
              color: (ctx)=>ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels (chart) {
                  const datasets = chart.data.datasets;
                  const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;
                  return chart._getSortedDatasetMetas().map((meta)=>{
                      const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
                      const borderWidth = toPadding(style.borderWidth);
                      return {
                          text: datasets[meta.index].label,
                          fillStyle: style.backgroundColor,
                          fontColor: color,
                          hidden: !meta.visible,
                          lineCap: style.borderCapStyle,
                          lineDash: style.borderDash,
                          lineDashOffset: style.borderDashOffset,
                          lineJoin: style.borderJoinStyle,
                          lineWidth: (borderWidth.width + borderWidth.height) / 4,
                          strokeStyle: style.borderColor,
                          pointStyle: pointStyle || style.pointStyle,
                          rotation: style.rotation,
                          textAlign: textAlign || style.textAlign,
                          borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                          datasetIndex: meta.index
                      };
                  }, this);
              }
          },
          title: {
              color: (ctx)=>ctx.chart.options.color,
              display: false,
              position: 'center',
              text: ''
          }
      },
      descriptors: {
          _scriptable: (name)=>!name.startsWith('on'),
          labels: {
              _scriptable: (name)=>![
                      'generateLabels',
                      'filter',
                      'sort'
                  ].includes(name)
          }
      }
  };
  class Title extends Element {
   constructor(config){
          super();
          this.chart = config.chart;
          this.options = config.options;
          this.ctx = config.ctx;
          this._padding = undefined;
          this.top = undefined;
          this.bottom = undefined;
          this.left = undefined;
          this.right = undefined;
          this.width = undefined;
          this.height = undefined;
          this.position = undefined;
          this.weight = undefined;
          this.fullSize = undefined;
      }
      update(maxWidth, maxHeight) {
          const opts = this.options;
          this.left = 0;
          this.top = 0;
          if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
          }
          this.width = this.right = maxWidth;
          this.height = this.bottom = maxHeight;
          const lineCount = isArray$1(opts.text) ? opts.text.length : 1;
          this._padding = toPadding(opts.padding);
          const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
          if (this.isHorizontal()) {
              this.height = textSize;
          } else {
              this.width = textSize;
          }
      }
      isHorizontal() {
          const pos = this.options.position;
          return pos === 'top' || pos === 'bottom';
      }
      _drawArgs(offset) {
          const { top , left , bottom , right , options  } = this;
          const align = options.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
              titleX = _alignStartEnd(align, left, right);
              titleY = top + offset;
              maxWidth = right - left;
          } else {
              if (options.position === 'left') {
                  titleX = left + offset;
                  titleY = _alignStartEnd(align, bottom, top);
                  rotation = PI * -0.5;
              } else {
                  titleX = right - offset;
                  titleY = _alignStartEnd(align, top, bottom);
                  rotation = PI * 0.5;
              }
              maxWidth = bottom - top;
          }
          return {
              titleX,
              titleY,
              maxWidth,
              rotation
          };
      }
      draw() {
          const ctx = this.ctx;
          const opts = this.options;
          if (!opts.display) {
              return;
          }
          const fontOpts = toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + this._padding.top;
          const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);
          renderText(ctx, opts.text, 0, 0, fontOpts, {
              color: opts.color,
              maxWidth,
              rotation,
              textAlign: _toLeftRightCenter(opts.align),
              textBaseline: 'middle',
              translation: [
                  titleX,
                  titleY
              ]
          });
      }
  }
  function createTitle(chart, titleOpts) {
      const title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart
      });
      layouts.configure(chart, title, titleOpts);
      layouts.addBox(chart, title);
      chart.titleBlock = title;
  }
  var plugin_title = {
      id: 'title',
   _element: Title,
      start (chart, _args, options) {
          createTitle(chart, options);
      },
      stop (chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
      },
      beforeUpdate (chart, _args, options) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options);
          title.options = options;
      },
      defaults: {
          align: 'center',
          display: false,
          font: {
              weight: 'bold'
          },
          fullSize: true,
          padding: 10,
          position: 'top',
          text: '',
          weight: 2000
      },
      defaultRoutes: {
          color: 'color'
      },
      descriptors: {
          _scriptable: true,
          _indexable: false
      }
  };
  const map = new WeakMap();
  var plugin_subtitle = {
      id: 'subtitle',
      start (chart, _args, options) {
          const title = new Title({
              ctx: chart.ctx,
              options,
              chart
          });
          layouts.configure(chart, title, options);
          layouts.addBox(chart, title);
          map.set(chart, title);
      },
      stop (chart) {
          layouts.removeBox(chart, map.get(chart));
          map.delete(chart);
      },
      beforeUpdate (chart, _args, options) {
          const title = map.get(chart);
          layouts.configure(chart, title, options);
          title.options = options;
      },
      defaults: {
          align: 'center',
          display: false,
          font: {
              weight: 'normal'
          },
          fullSize: true,
          padding: 0,
          position: 'top',
          text: '',
          weight: 1500
      },
      defaultRoutes: {
          color: 'color'
      },
      descriptors: {
          _scriptable: true,
          _indexable: false
      }
  };
  const positioners = {
   average (items) {
          if (!items.length) {
              return false;
          }
          let i, len;
          let xSet = new Set();
          let y = 0;
          let count = 0;
          for(i = 0, len = items.length; i < len; ++i){
              const el = items[i].element;
              if (el && el.hasValue()) {
                  const pos = el.tooltipPosition();
                  xSet.add(pos.x);
                  y += pos.y;
                  ++count;
              }
          }
          if (count === 0 || xSet.size === 0) {
              return false;
          }
          const xAverage = [
              ...xSet
          ].reduce((a, b)=>a + b) / xSet.size;
          return {
              x: xAverage,
              y: y / count
          };
      },
   nearest (items, eventPosition) {
          if (!items.length) {
              return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i, len, nearestElement;
          for(i = 0, len = items.length; i < len; ++i){
              const el = items[i].element;
              if (el && el.hasValue()) {
                  const center = el.getCenterPoint();
                  const d = distanceBetweenPoints(eventPosition, center);
                  if (d < minDistance) {
                      minDistance = d;
                      nearestElement = el;
                  }
              }
          }
          if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
          }
          return {
              x,
              y
          };
      }
  };
  function pushOrConcat(base, toPush) {
      if (toPush) {
          if (isArray$1(toPush)) {
              Array.prototype.push.apply(base, toPush);
          } else {
              base.push(toPush);
          }
      }
      return base;
  }
   function splitNewlines(str) {
      if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
          return str.split('\n');
      }
      return str;
  }
   function createTooltipItem(chart, item) {
      const { element , datasetIndex , index  } = item;
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      const { label , value  } = controller.getLabelAndValue(index);
      return {
          chart,
          label,
          parsed: controller.getParsed(index),
          raw: chart.data.datasets[datasetIndex].data[index],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index,
          datasetIndex,
          element
      };
  }
   function getTooltipSize(tooltip, options) {
      const ctx = tooltip.chart.ctx;
      const { body , footer , title  } = tooltip;
      const { boxWidth , boxHeight  } = options;
      const bodyFont = toFont(options.bodyFont);
      const titleFont = toFont(options.titleFont);
      const footerFont = toFont(options.footerFont);
      const titleLineCount = title.length;
      const footerLineCount = footer.length;
      const bodyLineItemCount = body.length;
      const padding = toPadding(options.padding);
      let height = padding.height;
      let width = 0;
      let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
      combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
      if (titleLineCount) {
          height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
      }
      if (combinedBodyLength) {
          const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
          height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
      }
      if (footerLineCount) {
          height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
      }
      let widthPadding = 0;
      const maxLineWidth = function(line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
      };
      ctx.save();
      ctx.font = titleFont.string;
      each(tooltip.title, maxLineWidth);
      ctx.font = bodyFont.string;
      each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
      widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
      each(body, (bodyItem)=>{
          each(bodyItem.before, maxLineWidth);
          each(bodyItem.lines, maxLineWidth);
          each(bodyItem.after, maxLineWidth);
      });
      widthPadding = 0;
      ctx.font = footerFont.string;
      each(tooltip.footer, maxLineWidth);
      ctx.restore();
      width += padding.width;
      return {
          width,
          height
      };
  }
  function determineYAlign(chart, size) {
      const { y , height  } = size;
      if (y < height / 2) {
          return 'top';
      } else if (y > chart.height - height / 2) {
          return 'bottom';
      }
      return 'center';
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
      const { x , width  } = size;
      const caret = options.caretSize + options.caretPadding;
      if (xAlign === 'left' && x + width + caret > chart.width) {
          return true;
      }
      if (xAlign === 'right' && x - width - caret < 0) {
          return true;
      }
  }
  function determineXAlign(chart, options, size, yAlign) {
      const { x , width  } = size;
      const { width: chartWidth , chartArea: { left , right  }  } = chart;
      let xAlign = 'center';
      if (yAlign === 'center') {
          xAlign = x <= (left + right) / 2 ? 'left' : 'right';
      } else if (x <= width / 2) {
          xAlign = 'left';
      } else if (x >= chartWidth - width / 2) {
          xAlign = 'right';
      }
      if (doesNotFitWithAlign(xAlign, chart, options, size)) {
          xAlign = 'center';
      }
      return xAlign;
  }
   function determineAlignment(chart, options, size) {
      const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
      return {
          xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
          yAlign
      };
  }
  function alignX(size, xAlign) {
      let { x , width  } = size;
      if (xAlign === 'right') {
          x -= width;
      } else if (xAlign === 'center') {
          x -= width / 2;
      }
      return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
      let { y , height  } = size;
      if (yAlign === 'top') {
          y += paddingAndSize;
      } else if (yAlign === 'bottom') {
          y -= height + paddingAndSize;
      } else {
          y -= height / 2;
      }
      return y;
  }
   function getBackgroundPoint(options, size, alignment, chart) {
      const { caretSize , caretPadding , cornerRadius  } = options;
      const { xAlign , yAlign  } = alignment;
      const paddingAndSize = caretSize + caretPadding;
      const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
      let x = alignX(size, xAlign);
      const y = alignY(size, yAlign, paddingAndSize);
      if (yAlign === 'center') {
          if (xAlign === 'left') {
              x += paddingAndSize;
          } else if (xAlign === 'right') {
              x -= paddingAndSize;
          }
      } else if (xAlign === 'left') {
          x -= Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === 'right') {
          x += Math.max(topRight, bottomRight) + caretSize;
      }
      return {
          x: _limitValue(x, 0, chart.width - size.width),
          y: _limitValue(y, 0, chart.height - size.height)
      };
  }
  function getAlignedX(tooltip, align, options) {
      const padding = toPadding(options.padding);
      return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
   function getBeforeAfterBodyLines(callback) {
      return pushOrConcat([], splitNewlines(callback));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
      return createContext(parent, {
          tooltip,
          tooltipItems,
          type: 'tooltip'
      });
  }
  function overrideCallbacks(callbacks, context) {
      const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
      return override ? callbacks.override(override) : callbacks;
  }
  const defaultCallbacks = {
      beforeTitle: noop,
      title (tooltipItems) {
          if (tooltipItems.length > 0) {
              const item = tooltipItems[0];
              const labels = item.chart.data.labels;
              const labelCount = labels ? labels.length : 0;
              if (this && this.options && this.options.mode === 'dataset') {
                  return item.dataset.label || '';
              } else if (item.label) {
                  return item.label;
              } else if (labelCount > 0 && item.dataIndex < labelCount) {
                  return labels[item.dataIndex];
              }
          }
          return '';
      },
      afterTitle: noop,
      beforeBody: noop,
      beforeLabel: noop,
      label (tooltipItem) {
          if (this && this.options && this.options.mode === 'dataset') {
              return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
          }
          let label = tooltipItem.dataset.label || '';
          if (label) {
              label += ': ';
          }
          const value = tooltipItem.formattedValue;
          if (!isNullOrUndef(value)) {
              label += value;
          }
          return label;
      },
      labelColor (tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
              borderColor: options.borderColor,
              backgroundColor: options.backgroundColor,
              borderWidth: options.borderWidth,
              borderDash: options.borderDash,
              borderDashOffset: options.borderDashOffset,
              borderRadius: 0
          };
      },
      labelTextColor () {
          return this.options.bodyColor;
      },
      labelPointStyle (tooltipItem) {
          const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
          const options = meta.controller.getStyle(tooltipItem.dataIndex);
          return {
              pointStyle: options.pointStyle,
              rotation: options.rotation
          };
      },
      afterLabel: noop,
      afterBody: noop,
      beforeFooter: noop,
      footer: noop,
      afterFooter: noop
  };
   function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
      const result = callbacks[name].call(ctx, arg);
      if (typeof result === 'undefined') {
          return defaultCallbacks[name].call(ctx, arg);
      }
      return result;
  }
  class Tooltip extends Element {
   static positioners = positioners;
      constructor(config){
          super();
          this.opacity = 0;
          this._active = [];
          this._eventPosition = undefined;
          this._size = undefined;
          this._cachedAnimations = undefined;
          this._tooltipItems = [];
          this.$animations = undefined;
          this.$context = undefined;
          this.chart = config.chart;
          this.options = config.options;
          this.dataPoints = undefined;
          this.title = undefined;
          this.beforeBody = undefined;
          this.body = undefined;
          this.afterBody = undefined;
          this.footer = undefined;
          this.xAlign = undefined;
          this.yAlign = undefined;
          this.x = undefined;
          this.y = undefined;
          this.height = undefined;
          this.width = undefined;
          this.caretX = undefined;
          this.caretY = undefined;
          this.labelColors = undefined;
          this.labelPointStyles = undefined;
          this.labelTextColors = undefined;
      }
      initialize(options) {
          this.options = options;
          this._cachedAnimations = undefined;
          this.$context = undefined;
      }
   _resolveAnimations() {
          const cached = this._cachedAnimations;
          if (cached) {
              return cached;
          }
          const chart = this.chart;
          const options = this.options.setContext(this.getContext());
          const opts = options.enabled && chart.options.animation && options.animations;
          const animations = new Animations(this.chart, opts);
          if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
          }
          return animations;
      }
   getContext() {
          return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
      }
      getTitle(context, options) {
          const { callbacks  } = options;
          const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);
          const title = invokeCallbackWithFallback(callbacks, 'title', this, context);
          const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
      }
      getBeforeBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));
      }
      getBody(tooltipItems, options) {
          const { callbacks  } = options;
          const bodyItems = [];
          each(tooltipItems, (context)=>{
              const bodyItem = {
                  before: [],
                  lines: [],
                  after: []
              };
              const scoped = overrideCallbacks(callbacks, context);
              pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));
              pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));
              pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));
              bodyItems.push(bodyItem);
          });
          return bodyItems;
      }
      getAfterBody(tooltipItems, options) {
          return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));
      }
      getFooter(tooltipItems, options) {
          const { callbacks  } = options;
          const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);
          const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);
          const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
      }
   _createItems(options) {
          const active = this._active;
          const data = this.chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i, len;
          for(i = 0, len = active.length; i < len; ++i){
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
          }
          if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));
          }
          if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));
          }
          each(tooltipItems, (context)=>{
              const scoped = overrideCallbacks(options.callbacks, context);
              labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));
              labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));
              labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));
          });
          this.labelColors = labelColors;
          this.labelPointStyles = labelPointStyles;
          this.labelTextColors = labelTextColors;
          this.dataPoints = tooltipItems;
          return tooltipItems;
      }
      update(changed, replay) {
          const options = this.options.setContext(this.getContext());
          const active = this._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
              if (this.opacity !== 0) {
                  properties = {
                      opacity: 0
                  };
              }
          } else {
              const position = positioners[options.position].call(this, active, this._eventPosition);
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(this.chart, options, positionAndSize);
              const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                  opacity: 1,
                  x: backgroundPoint.x,
                  y: backgroundPoint.y,
                  width: size.width,
                  height: size.height,
                  caretX: position.x,
                  caretY: position.y
              };
          }
          this._tooltipItems = tooltipItems;
          this.$context = undefined;
          if (properties) {
              this._resolveAnimations().update(this, properties);
          }
          if (changed && options.external) {
              options.external.call(this, {
                  chart: this.chart,
                  tooltip: this,
                  replay
              });
          }
      }
      drawCaret(tooltipPoint, ctx, size, options) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
      }
      getCaretPosition(tooltipPoint, size, options) {
          const { xAlign , yAlign  } = this;
          const { caretSize , cornerRadius  } = options;
          const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);
          const { x: ptX , y: ptY  } = tooltipPoint;
          const { width , height  } = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === 'center') {
              y2 = ptY + height / 2;
              if (xAlign === 'left') {
                  x1 = ptX;
                  x2 = x1 - caretSize;
                  y1 = y2 + caretSize;
                  y3 = y2 - caretSize;
              } else {
                  x1 = ptX + width;
                  x2 = x1 + caretSize;
                  y1 = y2 - caretSize;
                  y3 = y2 + caretSize;
              }
              x3 = x1;
          } else {
              if (xAlign === 'left') {
                  x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === 'right') {
                  x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                  x2 = this.caretX;
              }
              if (yAlign === 'top') {
                  y1 = ptY;
                  y2 = y1 - caretSize;
                  x1 = x2 - caretSize;
                  x3 = x2 + caretSize;
              } else {
                  y1 = ptY + height;
                  y2 = y1 + caretSize;
                  x1 = x2 + caretSize;
                  x3 = x2 - caretSize;
              }
              y3 = y1;
          }
          return {
              x1,
              x2,
              x3,
              y1,
              y2,
              y3
          };
      }
      drawTitle(pt, ctx, options) {
          const title = this.title;
          const length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = 'middle';
              titleFont = toFont(options.titleFont);
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for(i = 0; i < length; ++i){
                  ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                  pt.y += titleFont.lineHeight + titleSpacing;
                  if (i + 1 === length) {
                      pt.y += options.titleMarginBottom - titleSpacing;
                  }
              }
          }
      }
   _drawColorBox(ctx, pt, i, rtlHelper, options) {
          const labelColor = this.labelColors[i];
          const labelPointStyle = this.labelPointStyles[i];
          const { boxHeight , boxWidth  } = options;
          const bodyFont = toFont(options.bodyFont);
          const colorX = getAlignedX(this, 'left', options);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options.usePointStyle) {
              const drawOptions = {
                  radius: Math.min(boxWidth, boxHeight) / 2,
                  pointStyle: labelPointStyle.pointStyle,
                  rotation: labelPointStyle.rotation,
                  borderWidth: 1
              };
              const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              drawPoint(ctx, drawOptions, centerX, centerY);
              ctx.strokeStyle = labelColor.borderColor;
              ctx.fillStyle = labelColor.backgroundColor;
              drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
              ctx.lineWidth = isObject$1(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
              ctx.strokeStyle = labelColor.borderColor;
              ctx.setLineDash(labelColor.borderDash || []);
              ctx.lineDashOffset = labelColor.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
              const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
              const borderRadius = toTRBLCorners(labelColor.borderRadius);
              if (Object.values(borderRadius).some((v)=>v !== 0)) {
                  ctx.beginPath();
                  ctx.fillStyle = options.multiKeyBackground;
                  addRoundedRectPath(ctx, {
                      x: outerX,
                      y: colorY,
                      w: boxWidth,
                      h: boxHeight,
                      radius: borderRadius
                  });
                  ctx.fill();
                  ctx.stroke();
                  ctx.fillStyle = labelColor.backgroundColor;
                  ctx.beginPath();
                  addRoundedRectPath(ctx, {
                      x: innerX,
                      y: colorY + 1,
                      w: boxWidth - 2,
                      h: boxHeight - 2,
                      radius: borderRadius
                  });
                  ctx.fill();
              } else {
                  ctx.fillStyle = options.multiKeyBackground;
                  ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                  ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                  ctx.fillStyle = labelColor.backgroundColor;
                  ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
          }
          ctx.fillStyle = this.labelTextColors[i];
      }
      drawBody(pt, ctx, options) {
          const { body  } = this;
          const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;
          const bodyFont = toFont(options.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
          const fillLineOfText = function(line) {
              ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
              pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = 'middle';
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(this, bodyAlignForCalculation, options);
          ctx.fillStyle = options.bodyColor;
          each(this.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
          for(i = 0, ilen = body.length; i < ilen; ++i){
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              each(bodyItem.before, fillLineOfText);
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                  this._drawColorBox(ctx, pt, i, rtlHelper, options);
                  bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for(j = 0, jlen = lines.length; j < jlen; ++j){
                  fillLineOfText(lines[j]);
                  bodyLineHeight = bodyFont.lineHeight;
              }
              each(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          each(this.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
      }
      drawFooter(pt, ctx, options) {
          const footer = this.footer;
          const length = footer.length;
          let footerFont, i;
          if (length) {
              const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = 'middle';
              footerFont = toFont(options.footerFont);
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for(i = 0; i < length; ++i){
                  ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                  pt.y += footerFont.lineHeight + options.footerSpacing;
              }
          }
      }
      drawBackground(pt, ctx, tooltipSize, options) {
          const { xAlign , yAlign  } = this;
          const { x , y  } = pt;
          const { width , height  } = tooltipSize;
          const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);
          ctx.fillStyle = options.backgroundColor;
          ctx.strokeStyle = options.borderColor;
          ctx.lineWidth = options.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + topLeft, y);
          if (yAlign === 'top') {
              this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width - topRight, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
          if (yAlign === 'center' && xAlign === 'right') {
              this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + width, y + height - bottomRight);
          ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
          if (yAlign === 'bottom') {
              this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x + bottomLeft, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
          if (yAlign === 'center' && xAlign === 'left') {
              this.drawCaret(pt, ctx, tooltipSize, options);
          }
          ctx.lineTo(x, y + topLeft);
          ctx.quadraticCurveTo(x, y, x + topLeft, y);
          ctx.closePath();
          ctx.fill();
          if (options.borderWidth > 0) {
              ctx.stroke();
          }
      }
   _updateAnimationTarget(options) {
          const chart = this.chart;
          const anims = this.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
              const position = positioners[options.position].call(this, this._active, this._eventPosition);
              if (!position) {
                  return;
              }
              const size = this._size = getTooltipSize(this, options);
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(chart, options, positionAndSize);
              const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
              if (animX._to !== point.x || animY._to !== point.y) {
                  this.xAlign = alignment.xAlign;
                  this.yAlign = alignment.yAlign;
                  this.width = size.width;
                  this.height = size.height;
                  this.caretX = position.x;
                  this.caretY = position.y;
                  this._resolveAnimations().update(this, point);
              }
          }
      }
   _willRender() {
          return !!this.opacity;
      }
      draw(ctx) {
          const options = this.options.setContext(this.getContext());
          let opacity = this.opacity;
          if (!opacity) {
              return;
          }
          this._updateAnimationTarget(options);
          const tooltipSize = {
              width: this.width,
              height: this.height
          };
          const pt = {
              x: this.x,
              y: this.y
          };
          opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
          const padding = toPadding(options.padding);
          const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
          if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              overrideTextDirection(ctx, options.textDirection);
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              restoreTextDirection(ctx, options.textDirection);
              ctx.restore();
          }
      }
   getActiveElements() {
          return this._active || [];
      }
   setActiveElements(activeElements, eventPosition) {
          const lastActive = this._active;
          const active = activeElements.map(({ datasetIndex , index  })=>{
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                  throw new Error('Cannot find a dataset at index ' + datasetIndex);
              }
              return {
                  datasetIndex,
                  element: meta.data[index],
                  index
              };
          });
          const changed = !_elementsEqual(lastActive, active);
          const positionChanged = this._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
          }
      }
   handleEvent(e, replay, inChartArea = true) {
          if (replay && this._ignoreReplayEvents) {
              return false;
          }
          this._ignoreReplayEvents = false;
          const options = this.options;
          const lastActive = this._active || [];
          const active = this._getActiveElements(e, lastActive, replay, inChartArea);
          const positionChanged = this._positionChanged(active, e);
          const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                  this._eventPosition = {
                      x: e.x,
                      y: e.y
                  };
                  this.update(true, replay);
              }
          }
          return changed;
      }
   _getActiveElements(e, lastActive, replay, inChartArea) {
          const options = this.options;
          if (e.type === 'mouseout') {
              return [];
          }
          if (!inChartArea) {
              return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);
          }
          const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
          if (options.reverse) {
              active.reverse();
          }
          return active;
      }
   _positionChanged(active, e) {
          const { caretX , caretY , options  } = this;
          const position = positioners[options.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
      }
  }
  var plugin_tooltip = {
      id: 'tooltip',
      _element: Tooltip,
      positioners,
      afterInit (chart, _args, options) {
          if (options) {
              chart.tooltip = new Tooltip({
                  chart,
                  options
              });
          }
      },
      beforeUpdate (chart, _args, options) {
          if (chart.tooltip) {
              chart.tooltip.initialize(options);
          }
      },
      reset (chart, _args, options) {
          if (chart.tooltip) {
              chart.tooltip.initialize(options);
          }
      },
      afterDraw (chart) {
          const tooltip = chart.tooltip;
          if (tooltip && tooltip._willRender()) {
              const args = {
                  tooltip
              };
              if (chart.notifyPlugins('beforeTooltipDraw', {
                  ...args,
                  cancelable: true
              }) === false) {
                  return;
              }
              tooltip.draw(chart.ctx);
              chart.notifyPlugins('afterTooltipDraw', args);
          }
      },
      afterEvent (chart, args) {
          if (chart.tooltip) {
              const useFinalPosition = args.replay;
              if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
                  args.changed = true;
              }
          }
      },
      defaults: {
          enabled: true,
          external: null,
          position: 'average',
          backgroundColor: 'rgba(0,0,0,0.8)',
          titleColor: '#fff',
          titleFont: {
              weight: 'bold'
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: 'left',
          bodyColor: '#fff',
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: 'left',
          footerColor: '#fff',
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
              weight: 'bold'
          },
          footerAlign: 'left',
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts)=>opts.bodyFont.size,
          boxWidth: (ctx, opts)=>opts.bodyFont.size,
          multiKeyBackground: '#fff',
          displayColors: true,
          boxPadding: 0,
          borderColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          animation: {
              duration: 400,
              easing: 'easeOutQuart'
          },
          animations: {
              numbers: {
                  type: 'number',
                  properties: [
                      'x',
                      'y',
                      'width',
                      'height',
                      'caretX',
                      'caretY'
                  ]
              },
              opacity: {
                  easing: 'linear',
                  duration: 200
              }
          },
          callbacks: defaultCallbacks
      },
      defaultRoutes: {
          bodyFont: 'font',
          footerFont: 'font',
          titleFont: 'font'
      },
      descriptors: {
          _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',
          _indexable: false,
          callbacks: {
              _scriptable: false,
              _indexable: false
          },
          animation: {
              _fallback: false
          },
          animations: {
              _fallback: 'animation'
          }
      },
      additionalOptionScopes: [
          'interaction'
      ]
  };
  var plugins = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
  });
  const addIfString = (labels, raw, index, addedLabels)=>{
      if (typeof raw === 'string') {
          index = labels.push(raw) - 1;
          addedLabels.unshift({
              index,
              label: raw
          });
      } else if (isNaN(raw)) {
          index = null;
      }
      return index;
  };
  function findOrAddLabel(labels, raw, index, addedLabels) {
      const first = labels.indexOf(raw);
      if (first === -1) {
          return addIfString(labels, raw, index, addedLabels);
      }
      const last = labels.lastIndexOf(raw);
      return first !== last ? index : first;
  }
  const validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);
  function _getLabelForValue(value) {
      const labels = this.getLabels();
      if (value >= 0 && value < labels.length) {
          return labels[value];
      }
      return value;
  }
  class CategoryScale extends Scale {
      static id = 'category';
   static defaults = {
          ticks: {
              callback: _getLabelForValue
          }
      };
      constructor(cfg){
          super(cfg);
           this._startValue = undefined;
          this._valueRange = 0;
          this._addedLabels = [];
      }
      init(scaleOptions) {
          const added = this._addedLabels;
          if (added.length) {
              const labels = this.getLabels();
              for (const { index , label  } of added){
                  if (labels[index] === label) {
                      labels.splice(index, 1);
                  }
              }
              this._addedLabels = [];
          }
          super.init(scaleOptions);
      }
      parse(raw, index) {
          if (isNullOrUndef(raw)) {
              return null;
          }
          const labels = this.getLabels();
          index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
          return validIndex(index, labels.length - 1);
      }
      determineDataLimits() {
          const { minDefined , maxDefined  } = this.getUserBounds();
          let { min , max  } = this.getMinMax(true);
          if (this.options.bounds === 'ticks') {
              if (!minDefined) {
                  min = 0;
              }
              if (!maxDefined) {
                  max = this.getLabels().length - 1;
              }
          }
          this.min = min;
          this.max = max;
      }
      buildTicks() {
          const min = this.min;
          const max = this.max;
          const offset = this.options.offset;
          const ticks = [];
          let labels = this.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          this._startValue = this.min - (offset ? 0.5 : 0);
          for(let value = min; value <= max; value++){
              ticks.push({
                  value
              });
          }
          return ticks;
      }
      getLabelForValue(value) {
          return _getLabelForValue.call(this, value);
      }
   configure() {
          super.configure();
          if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
          }
      }
      getPixelForValue(value) {
          if (typeof value !== 'number') {
              value = this.parse(value);
          }
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getPixelForTick(index) {
          const ticks = this.ticks;
          if (index < 0 || index > ticks.length - 1) {
              return null;
          }
          return this.getPixelForValue(ticks[index].value);
      }
      getValueForPixel(pixel) {
          return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
      }
      getBasePixel() {
          return this.bottom;
      }
  }
  function generateTicks$1(generationOptions, dataRange) {
      const ticks = [];
      const MIN_SPACING = 1e-14;
      const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;
      const unit = step || 1;
      const maxSpaces = maxTicks - 1;
      const { min: rmin , max: rmax  } = dataRange;
      const minDefined = !isNullOrUndef(min);
      const maxDefined = !isNullOrUndef(max);
      const countDefined = !isNullOrUndef(count);
      const minSpacing = (rmax - rmin) / (maxDigits + 1);
      let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
      let factor, niceMin, niceMax, numSpaces;
      if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
          return [
              {
                  value: rmin
              },
              {
                  value: rmax
              }
          ];
      }
      numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
      if (numSpaces > maxSpaces) {
          spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
      }
      if (!isNullOrUndef(precision)) {
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
      }
      if (bounds === 'ticks') {
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
      } else {
          niceMin = rmin;
          niceMax = rmax;
      }
      if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {
          numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
          spacing = (max - min) / numSpaces;
          niceMin = min;
          niceMax = max;
      } else if (countDefined) {
          niceMin = minDefined ? min : niceMin;
          niceMax = maxDefined ? max : niceMax;
          numSpaces = count - 1;
          spacing = (niceMax - niceMin) / numSpaces;
      } else {
          numSpaces = (niceMax - niceMin) / spacing;
          if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
              numSpaces = Math.round(numSpaces);
          } else {
              numSpaces = Math.ceil(numSpaces);
          }
      }
      const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
      factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
      niceMin = Math.round(niceMin * factor) / factor;
      niceMax = Math.round(niceMax * factor) / factor;
      let j = 0;
      if (minDefined) {
          if (includeBounds && niceMin !== min) {
              ticks.push({
                  value: min
              });
              if (niceMin < min) {
                  j++;
              }
              if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
                  j++;
              }
          } else if (niceMin < min) {
              j++;
          }
      }
      for(; j < numSpaces; ++j){
          const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
          if (maxDefined && tickValue > max) {
              break;
          }
          ticks.push({
              value: tickValue
          });
      }
      if (maxDefined && includeBounds && niceMax !== max) {
          if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
              ticks[ticks.length - 1].value = max;
          } else {
              ticks.push({
                  value: max
              });
          }
      } else if (!maxDefined || niceMax === max) {
          ticks.push({
              value: niceMax
          });
      }
      return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {
      const rad = toRadians(minRotation);
      const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
      const length = 0.75 * minSpacing * ('' + value).length;
      return Math.min(minSpacing / ratio, length);
  }
  class LinearScaleBase extends Scale {
      constructor(cfg){
          super(cfg);
           this.start = undefined;
           this.end = undefined;
           this._startValue = undefined;
           this._endValue = undefined;
          this._valueRange = 0;
      }
      parse(raw, index) {
          if (isNullOrUndef(raw)) {
              return null;
          }
          if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
              return null;
          }
          return +raw;
      }
      handleTickRangeOptions() {
          const { beginAtZero  } = this.options;
          const { minDefined , maxDefined  } = this.getUserBounds();
          let { min , max  } = this;
          const setMin = (v)=>min = minDefined ? min : v;
          const setMax = (v)=>max = maxDefined ? max : v;
          if (beginAtZero) {
              const minSign = sign(min);
              const maxSign = sign(max);
              if (minSign < 0 && maxSign < 0) {
                  setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                  setMin(0);
              }
          }
          if (min === max) {
              let offset = max === 0 ? 1 : Math.abs(max * 0.05);
              setMax(max + offset);
              if (!beginAtZero) {
                  setMin(min - offset);
              }
          }
          this.min = min;
          this.max = max;
      }
      getTickLimit() {
          const tickOpts = this.options.ticks;
          let { maxTicksLimit , stepSize  } = tickOpts;
          let maxTicks;
          if (stepSize) {
              maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
              if (maxTicks > 1000) {
                  console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                  maxTicks = 1000;
              }
          } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
      }
   computeTickLimit() {
          return Number.POSITIVE_INFINITY;
      }
      buildTicks() {
          const opts = this.options;
          const tickOpts = opts.ticks;
          let maxTicks = this.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = this._range || this;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === 'ticks') {
              _setMinAndMaxByKey(ticks, this, 'value');
          }
          if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
          } else {
              this.start = this.min;
              this.end = this.max;
          }
          return ticks;
      }
   configure() {
          const ticks = this.ticks;
          let start = this.min;
          let end = this.max;
          super.configure();
          if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
          }
          this._startValue = start;
          this._endValue = end;
          this._valueRange = end - start;
      }
      getLabelForValue(value) {
          return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
      }
  }
  class LinearScale extends LinearScaleBase {
      static id = 'linear';
   static defaults = {
          ticks: {
              callback: Ticks.formatters.numeric
          }
      };
      determineDataLimits() {
          const { min , max  } = this.getMinMax(true);
          this.min = isNumberFinite(min) ? min : 0;
          this.max = isNumberFinite(max) ? max : 1;
          this.handleTickRangeOptions();
      }
   computeTickLimit() {
          const horizontal = this.isHorizontal();
          const length = horizontal ? this.width : this.height;
          const minRotation = toRadians(this.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
          const tickFont = this._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
      }
      getPixelForValue(value) {
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
      }
  }
  const log10Floor = (v)=>Math.floor(log10(v));
  const changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
      const remain = tickVal / Math.pow(10, log10Floor(tickVal));
      return remain === 1;
  }
  function steps(min, max, rangeExp) {
      const rangeStep = Math.pow(10, rangeExp);
      const start = Math.floor(min / rangeStep);
      const end = Math.ceil(max / rangeStep);
      return end - start;
  }
  function startExp(min, max) {
      const range = max - min;
      let rangeExp = log10Floor(range);
      while(steps(min, max, rangeExp) > 10){
          rangeExp++;
      }
      while(steps(min, max, rangeExp) < 10){
          rangeExp--;
      }
      return Math.min(rangeExp, log10Floor(min));
  }
   function generateTicks(generationOptions, { min , max  }) {
      min = finiteOrDefault(generationOptions.min, min);
      const ticks = [];
      const minExp = log10Floor(min);
      let exp = startExp(min, max);
      let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
      const stepSize = Math.pow(10, exp);
      const base = minExp > exp ? Math.pow(10, minExp) : 0;
      const start = Math.round((min - base) * precision) / precision;
      const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
      let significand = Math.floor((start - offset) / Math.pow(10, exp));
      let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
      while(value < max){
          ticks.push({
              value,
              major: isMajor(value),
              significand
          });
          if (significand >= 10) {
              significand = significand < 15 ? 15 : 20;
          } else {
              significand++;
          }
          if (significand >= 20) {
              exp++;
              significand = 2;
              precision = exp >= 0 ? 1 : precision;
          }
          value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
      }
      const lastTick = finiteOrDefault(generationOptions.max, value);
      ticks.push({
          value: lastTick,
          major: isMajor(lastTick),
          significand
      });
      return ticks;
  }
  class LogarithmicScale extends Scale {
      static id = 'logarithmic';
   static defaults = {
          ticks: {
              callback: Ticks.formatters.logarithmic,
              major: {
                  enabled: true
              }
          }
      };
      constructor(cfg){
          super(cfg);
           this.start = undefined;
           this.end = undefined;
           this._startValue = undefined;
          this._valueRange = 0;
      }
      parse(raw, index) {
          const value = LinearScaleBase.prototype.parse.apply(this, [
              raw,
              index
          ]);
          if (value === 0) {
              this._zero = true;
              return undefined;
          }
          return isNumberFinite(value) && value > 0 ? value : null;
      }
      determineDataLimits() {
          const { min , max  } = this.getMinMax(true);
          this.min = isNumberFinite(min) ? Math.max(0, min) : null;
          this.max = isNumberFinite(max) ? Math.max(0, max) : null;
          if (this.options.beginAtZero) {
              this._zero = true;
          }
          if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
              this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
          }
          this.handleTickRangeOptions();
      }
      handleTickRangeOptions() {
          const { minDefined , maxDefined  } = this.getUserBounds();
          let min = this.min;
          let max = this.max;
          const setMin = (v)=>min = minDefined ? min : v;
          const setMax = (v)=>max = maxDefined ? max : v;
          if (min === max) {
              if (min <= 0) {
                  setMin(1);
                  setMax(10);
              } else {
                  setMin(changeExponent(min, -1));
                  setMax(changeExponent(max, 1));
              }
          }
          if (min <= 0) {
              setMin(changeExponent(max, -1));
          }
          if (max <= 0) {
              setMax(changeExponent(min, 1));
          }
          this.min = min;
          this.max = max;
      }
      buildTicks() {
          const opts = this.options;
          const generationOptions = {
              min: this._userMin,
              max: this._userMax
          };
          const ticks = generateTicks(generationOptions, this);
          if (opts.bounds === 'ticks') {
              _setMinAndMaxByKey(ticks, this, 'value');
          }
          if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
          } else {
              this.start = this.min;
              this.end = this.max;
          }
          return ticks;
      }
   getLabelForValue(value) {
          return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
      }
   configure() {
          const start = this.min;
          super.configure();
          this._startValue = log10(start);
          this._valueRange = log10(this.max) - log10(start);
      }
      getPixelForValue(value) {
          if (value === undefined || value === 0) {
              value = this.min;
          }
          if (value === null || isNaN(value)) {
              return NaN;
          }
          return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
      }
      getValueForPixel(pixel) {
          const decimal = this.getDecimalForPixel(pixel);
          return Math.pow(10, this._startValue + decimal * this._valueRange);
      }
  }
  function getTickBackdropHeight(opts) {
      const tickOpts = opts.ticks;
      if (tickOpts.display && opts.display) {
          const padding = toPadding(tickOpts.backdropPadding);
          return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
      }
      return 0;
  }
  function measureLabelSize(ctx, font, label) {
      label = isArray$1(label) ? label : [
          label
      ];
      return {
          w: _longestText(ctx, font.string, label),
          h: label.length * font.lineHeight
      };
  }
  function determineLimits(angle, pos, size, min, max) {
      if (angle === min || angle === max) {
          return {
              start: pos - size / 2,
              end: pos + size / 2
          };
      } else if (angle < min || angle > max) {
          return {
              start: pos - size,
              end: pos
          };
      }
      return {
          start: pos,
          end: pos + size
      };
  }
   function fitWithPointLabels(scale) {
      const orig = {
          l: scale.left + scale._padding.left,
          r: scale.right - scale._padding.right,
          t: scale.top + scale._padding.top,
          b: scale.bottom - scale._padding.bottom
      };
      const limits = Object.assign({}, orig);
      const labelSizes = [];
      const padding = [];
      const valueCount = scale._pointLabels.length;
      const pointLabelOpts = scale.options.pointLabels;
      const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
      for(let i = 0; i < valueCount; i++){
          const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
          padding[i] = opts.padding;
          const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
          const plFont = toFont(opts.font);
          const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
          labelSizes[i] = textSize;
          const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
          const angle = Math.round(toDegrees(angleRadians));
          const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
          updateLimits(limits, orig, angleRadians, hLimits, vLimits);
      }
      scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
      scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
      const sin = Math.abs(Math.sin(angle));
      const cos = Math.abs(Math.cos(angle));
      let x = 0;
      let y = 0;
      if (hLimits.start < orig.l) {
          x = (orig.l - hLimits.start) / sin;
          limits.l = Math.min(limits.l, orig.l - x);
      } else if (hLimits.end > orig.r) {
          x = (hLimits.end - orig.r) / sin;
          limits.r = Math.max(limits.r, orig.r + x);
      }
      if (vLimits.start < orig.t) {
          y = (orig.t - vLimits.start) / cos;
          limits.t = Math.min(limits.t, orig.t - y);
      } else if (vLimits.end > orig.b) {
          y = (vLimits.end - orig.b) / cos;
          limits.b = Math.max(limits.b, orig.b + y);
      }
  }
  function createPointLabelItem(scale, index, itemOpts) {
      const outerDistance = scale.drawingArea;
      const { extra , additionalAngle , padding , size  } = itemOpts;
      const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
      const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
      const y = yForAngle(pointLabelPosition.y, size.h, angle);
      const textAlign = getTextAlignForAngle(angle);
      const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
      return {
          visible: true,
          x: pointLabelPosition.x,
          y,
          textAlign,
          left,
          top: y,
          right: left + size.w,
          bottom: y + size.h
      };
  }
  function isNotOverlapped(item, area) {
      if (!area) {
          return true;
      }
      const { left , top , right , bottom  } = item;
      const apexesInArea = _isPointInArea({
          x: left,
          y: top
      }, area) || _isPointInArea({
          x: left,
          y: bottom
      }, area) || _isPointInArea({
          x: right,
          y: top
      }, area) || _isPointInArea({
          x: right,
          y: bottom
      }, area);
      return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
      const items = [];
      const valueCount = scale._pointLabels.length;
      const opts = scale.options;
      const { centerPointLabels , display  } = opts.pointLabels;
      const itemOpts = {
          extra: getTickBackdropHeight(opts) / 2,
          additionalAngle: centerPointLabels ? PI / valueCount : 0
      };
      let area;
      for(let i = 0; i < valueCount; i++){
          itemOpts.padding = padding[i];
          itemOpts.size = labelSizes[i];
          const item = createPointLabelItem(scale, i, itemOpts);
          items.push(item);
          if (display === 'auto') {
              item.visible = isNotOverlapped(item, area);
              if (item.visible) {
                  area = item;
              }
          }
      }
      return items;
  }
  function getTextAlignForAngle(angle) {
      if (angle === 0 || angle === 180) {
          return 'center';
      } else if (angle < 180) {
          return 'left';
      }
      return 'right';
  }
  function leftForTextAlign(x, w, align) {
      if (align === 'right') {
          x -= w;
      } else if (align === 'center') {
          x -= w / 2;
      }
      return x;
  }
  function yForAngle(y, h, angle) {
      if (angle === 90 || angle === 270) {
          y -= h / 2;
      } else if (angle > 270 || angle < 90) {
          y -= h;
      }
      return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
      const { left , top , right , bottom  } = item;
      const { backdropColor  } = opts;
      if (!isNullOrUndef(backdropColor)) {
          const borderRadius = toTRBLCorners(opts.borderRadius);
          const padding = toPadding(opts.backdropPadding);
          ctx.fillStyle = backdropColor;
          const backdropLeft = left - padding.left;
          const backdropTop = top - padding.top;
          const backdropWidth = right - left + padding.width;
          const backdropHeight = bottom - top + padding.height;
          if (Object.values(borderRadius).some((v)=>v !== 0)) {
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius
              });
              ctx.fill();
          } else {
              ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
          }
      }
  }
  function drawPointLabels(scale, labelCount) {
      const { ctx , options: { pointLabels  }  } = scale;
      for(let i = labelCount - 1; i >= 0; i--){
          const item = scale._pointLabelItems[i];
          if (!item.visible) {
              continue;
          }
          const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
          drawPointLabelBox(ctx, optsAtIndex, item);
          const plFont = toFont(optsAtIndex.font);
          const { x , y , textAlign  } = item;
          renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
              color: optsAtIndex.color,
              textAlign: textAlign,
              textBaseline: 'middle'
          });
      }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
      const { ctx  } = scale;
      if (circular) {
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
      } else {
          let pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);
          for(let i = 1; i < labelCount; i++){
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
          }
      }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
      const ctx = scale.ctx;
      const circular = gridLineOpts.circular;
      const { color , lineWidth  } = gridLineOpts;
      if (!circular && !labelCount || !color || !lineWidth || radius < 0) {
          return;
      }
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = lineWidth;
      ctx.setLineDash(borderOpts.dash || []);
      ctx.lineDashOffset = borderOpts.dashOffset;
      ctx.beginPath();
      pathRadiusLine(scale, radius, circular, labelCount);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();
  }
  function createPointLabelContext(parent, index, label) {
      return createContext(parent, {
          label,
          index,
          type: 'pointLabel'
      });
  }
  class RadialLinearScale extends LinearScaleBase {
      static id = 'radialLinear';
   static defaults = {
          display: true,
          animate: true,
          position: 'chartArea',
          angleLines: {
              display: true,
              lineWidth: 1,
              borderDash: [],
              borderDashOffset: 0.0
          },
          grid: {
              circular: false
          },
          startAngle: 0,
          ticks: {
              showLabelBackdrop: true,
              callback: Ticks.formatters.numeric
          },
          pointLabels: {
              backdropColor: undefined,
              backdropPadding: 2,
              display: true,
              font: {
                  size: 10
              },
              callback (label) {
                  return label;
              },
              padding: 5,
              centerPointLabels: false
          }
      };
      static defaultRoutes = {
          'angleLines.color': 'borderColor',
          'pointLabels.color': 'color',
          'ticks.color': 'color'
      };
      static descriptors = {
          angleLines: {
              _fallback: 'grid'
          }
      };
      constructor(cfg){
          super(cfg);
           this.xCenter = undefined;
           this.yCenter = undefined;
           this.drawingArea = undefined;
           this._pointLabels = [];
          this._pointLabelItems = [];
      }
      setDimensions() {
          const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
          const w = this.width = this.maxWidth - padding.width;
          const h = this.height = this.maxHeight - padding.height;
          this.xCenter = Math.floor(this.left + w / 2 + padding.left);
          this.yCenter = Math.floor(this.top + h / 2 + padding.top);
          this.drawingArea = Math.floor(Math.min(w, h) / 2);
      }
      determineDataLimits() {
          const { min , max  } = this.getMinMax(false);
          this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
          this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
          this.handleTickRangeOptions();
      }
   computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
      }
      generateTickLabels(ticks) {
          LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
          this._pointLabels = this.getLabels().map((value, index)=>{
              const label = callback(this.options.pointLabels.callback, [
                  value,
                  index
              ], this);
              return label || label === 0 ? label : '';
          }).filter((v, i)=>this.chart.getDataVisibility(i));
      }
      fit() {
          const opts = this.options;
          if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
          } else {
              this.setCenterPoint(0, 0, 0, 0);
          }
      }
      setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
          this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
          this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
      }
      getIndexAngle(index) {
          const angleMultiplier = TAU / (this._pointLabels.length || 1);
          const startAngle = this.options.startAngle || 0;
          return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
      }
      getDistanceFromCenterForValue(value) {
          if (isNullOrUndef(value)) {
              return NaN;
          }
          const scalingFactor = this.drawingArea / (this.max - this.min);
          if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
          }
          return (value - this.min) * scalingFactor;
      }
      getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) {
              return NaN;
          }
          const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
          return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
      }
      getPointLabelContext(index) {
          const pointLabels = this._pointLabels || [];
          if (index >= 0 && index < pointLabels.length) {
              const pointLabel = pointLabels[index];
              return createPointLabelContext(this.getContext(), index, pointLabel);
          }
      }
      getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
          const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
          return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle
          };
      }
      getPointPositionForValue(index, value) {
          return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
      }
      getBasePosition(index) {
          return this.getPointPositionForValue(index || 0, this.getBaseValue());
      }
      getPointLabelPosition(index) {
          const { left , top , right , bottom  } = this._pointLabelItems[index];
          return {
              left,
              top,
              right,
              bottom
          };
      }
   drawBackground() {
          const { backgroundColor , grid: { circular  }  } = this.options;
          if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
          }
      }
   drawGrid() {
          const ctx = this.ctx;
          const opts = this.options;
          const { angleLines , grid , border  } = opts;
          const labelCount = this._pointLabels.length;
          let i, offset, position;
          if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
          }
          if (grid.display) {
              this.ticks.forEach((tick, index)=>{
                  if (index !== 0 || index === 0 && this.min < 0) {
                      offset = this.getDistanceFromCenterForValue(tick.value);
                      const context = this.getContext(index);
                      const optsAtIndex = grid.setContext(context);
                      const optsAtIndexBorder = border.setContext(context);
                      drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                  }
              });
          }
          if (angleLines.display) {
              ctx.save();
              for(i = labelCount - 1; i >= 0; i--){
                  const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                  const { color , lineWidth  } = optsAtIndex;
                  if (!lineWidth || !color) {
                      continue;
                  }
                  ctx.lineWidth = lineWidth;
                  ctx.strokeStyle = color;
                  ctx.setLineDash(optsAtIndex.borderDash);
                  ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                  offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                  position = this.getPointPosition(i, offset);
                  ctx.beginPath();
                  ctx.moveTo(this.xCenter, this.yCenter);
                  ctx.lineTo(position.x, position.y);
                  ctx.stroke();
              }
              ctx.restore();
          }
      }
   drawBorder() {}
   drawLabels() {
          const ctx = this.ctx;
          const opts = this.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
              return;
          }
          const startAngle = this.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(this.xCenter, this.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          this.ticks.forEach((tick, index)=>{
              if (index === 0 && this.min >= 0 && !opts.reverse) {
                  return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index));
              const tickFont = toFont(optsAtIndex.font);
              offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
              if (optsAtIndex.showLabelBackdrop) {
                  ctx.font = tickFont.string;
                  width = ctx.measureText(tick.label).width;
                  ctx.fillStyle = optsAtIndex.backdropColor;
                  const padding = toPadding(optsAtIndex.backdropPadding);
                  ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
              }
              renderText(ctx, tick.label, 0, -offset, tickFont, {
                  color: optsAtIndex.color,
                  strokeColor: optsAtIndex.textStrokeColor,
                  strokeWidth: optsAtIndex.textStrokeWidth
              });
          });
          ctx.restore();
      }
   drawTitle() {}
  }
  const INTERVALS = {
      millisecond: {
          common: true,
          size: 1,
          steps: 1000
      },
      second: {
          common: true,
          size: 1000,
          steps: 60
      },
      minute: {
          common: true,
          size: 60000,
          steps: 60
      },
      hour: {
          common: true,
          size: 3600000,
          steps: 24
      },
      day: {
          common: true,
          size: 86400000,
          steps: 30
      },
      week: {
          common: false,
          size: 604800000,
          steps: 4
      },
      month: {
          common: true,
          size: 2.628e9,
          steps: 12
      },
      quarter: {
          common: false,
          size: 7.884e9,
          steps: 4
      },
      year: {
          common: true,
          size: 3.154e10
      }
  };
   const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);
   function sorter(a, b) {
      return a - b;
  }
   function parse$1(scale, input) {
      if (isNullOrUndef(input)) {
          return null;
      }
      const adapter = scale._adapter;
      const { parser , round , isoWeekday  } = scale._parseOpts;
      let value = input;
      if (typeof parser === 'function') {
          value = parser(value);
      }
      if (!isNumberFinite(value)) {
          value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);
      }
      if (value === null) {
          return null;
      }
      if (round) {
          value = round === 'week' && (isNumber$1(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);
      }
      return +value;
  }
   function determineUnitForAutoTicks(minUnit, min, max, capacity) {
      const ilen = UNITS.length;
      for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){
          const interval = INTERVALS[UNITS[i]];
          const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
              return UNITS[i];
          }
      }
      return UNITS[ilen - 1];
  }
   function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
      for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){
          const unit = UNITS[i];
          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
              return unit;
          }
      }
      return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
   function determineMajorUnit(unit) {
      for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){
          if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
          }
      }
  }
   function addTick(ticks, time, timestamps) {
      if (!timestamps) {
          ticks[time] = true;
      } else if (timestamps.length) {
          const { lo , hi  } = _lookup(timestamps, time);
          const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
          ticks[timestamp] = true;
      }
  }
   function setMajorTicks(scale, ticks, map, majorUnit) {
      const adapter = scale._adapter;
      const first = +adapter.startOf(ticks[0].value, majorUnit);
      const last = ticks[ticks.length - 1].value;
      let major, index;
      for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){
          index = map[major];
          if (index >= 0) {
              ticks[index].major = true;
          }
      }
      return ticks;
  }
   function ticksFromTimestamps(scale, values, majorUnit) {
      const ticks = [];
       const map = {};
      const ilen = values.length;
      let i, value;
      for(i = 0; i < ilen; ++i){
          value = values[i];
          map[value] = i;
          ticks.push({
              value,
              major: false
          });
      }
      return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
  }
  class TimeScale extends Scale {
      static id = 'time';
   static defaults = {
   bounds: 'data',
          adapters: {},
          time: {
              parser: false,
              unit: false,
              round: false,
              isoWeekday: false,
              minUnit: 'millisecond',
              displayFormats: {}
          },
          ticks: {
   source: 'auto',
              callback: false,
              major: {
                  enabled: false
              }
          }
      };
   constructor(props){
          super(props);
           this._cache = {
              data: [],
              labels: [],
              all: []
          };
           this._unit = 'day';
           this._majorUnit = undefined;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = undefined;
      }
      init(scaleOpts, opts = {}) {
          const time = scaleOpts.time || (scaleOpts.time = {});
           const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
          adapter.init(opts);
          mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
      }
   parse(raw, index) {
          if (raw === undefined) {
              return null;
          }
          return parse$1(this, raw);
      }
      beforeLayout() {
          super.beforeLayout();
          this._cache = {
              data: [],
              labels: [],
              all: []
          };
      }
      determineDataLimits() {
          const options = this.options;
          const adapter = this._adapter;
          const unit = options.time.unit || 'day';
          let { min , max , minDefined , maxDefined  } = this.getUserBounds();
   function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                  min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                  max = Math.max(max, bounds.max);
              }
          }
          if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
                  _applyBounds(this.getMinMax(false));
              }
          }
          min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          this.min = Math.min(min, max - 1);
          this.max = Math.max(min + 1, max);
      }
   _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
          }
          return {
              min,
              max
          };
      }
   buildTicks() {
          const options = this.options;
          const timeOpts = options.time;
          const tickOpts = options.ticks;
          const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();
          if (options.bounds === 'ticks' && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
          }
          const min = this.min;
          const max = this.max;
          const ticks = _filterBetween(timestamps, min, max);
          this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
          this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);
          this.initOffsets(timestamps);
          if (options.reverse) {
              ticks.reverse();
          }
          return ticksFromTimestamps(this, ticks, this._majorUnit);
      }
      afterAutoSkip() {
          if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick)=>+tick.value));
          }
      }
   initOffsets(timestamps = []) {
          let start = 0;
          let end = 0;
          let first, last;
          if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                  start = 1 - first;
              } else {
                  start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                  end = last;
              } else {
                  end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
              }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start = _limitValue(start, 0, limit);
          end = _limitValue(end, 0, limit);
          this._offsets = {
              start,
              end,
              factor: 1 / (start + 1 + end)
          };
      }
   _generate() {
          const adapter = this._adapter;
          const min = this.min;
          const max = this.max;
          const options = this.options;
          const timeOpts = options.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
          const stepSize = valueOrDefault(options.ticks.stepSize, 1);
          const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
          const hasWeekday = isNumber$1(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
              first = +adapter.startOf(first, 'isoWeek', weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
          if (adapter.diff(max, min, minor) > 100000 * stepSize) {
              throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
          }
          const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();
          for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){
              addTick(ticks, time, timestamps);
          }
          if (time === max || options.bounds === 'ticks' || count === 1) {
              addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort(sorter).map((x)=>+x);
      }
   getLabelForValue(value) {
          const adapter = this._adapter;
          const timeOpts = this.options.time;
          if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
          }
          return adapter.format(value, timeOpts.displayFormats.datetime);
      }
   format(value, format) {
          const options = this.options;
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const fmt = format || formats[unit];
          return this._adapter.format(value, fmt);
      }
   _tickFormatFunction(time, index, ticks, format) {
          const options = this.options;
          const formatter = options.ticks.callback;
          if (formatter) {
              return callback(formatter, [
                  time,
                  index,
                  ticks
              ], this);
          }
          const formats = options.time.displayFormats;
          const unit = this._unit;
          const majorUnit = this._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick = ticks[index];
          const major = majorUnit && majorFormat && tick && tick.major;
          return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
      }
   generateTickLabels(ticks) {
          let i, ilen, tick;
          for(i = 0, ilen = ticks.length; i < ilen; ++i){
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
          }
      }
   getDecimalForValue(value) {
          return value === null ? NaN : (value - this.min) / (this.max - this.min);
      }
   getPixelForValue(value) {
          const offsets = this._offsets;
          const pos = this.getDecimalForValue(value);
          return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
      }
   getValueForPixel(pixel) {
          const offsets = this._offsets;
          const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return this.min + pos * (this.max - this.min);
      }
   _getLabelSize(label) {
          const ticksOpts = this.options.ticks;
          const tickLabelWidth = this.ctx.measureText(label).width;
          const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = this._resolveTickFontOptions(0).size;
          return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
      }
   _getLabelCapacity(exampleTime) {
          const timeOpts = this.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
              exampleTime
          ], this._majorUnit), format);
          const size = this._getLabelSize(exampleLabel);
          const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
      }
   getDataTimestamps() {
          let timestamps = this._cache.data || [];
          let i, ilen;
          if (timestamps.length) {
              return timestamps;
          }
          const metas = this.getMatchingVisibleMetas();
          if (this._normalized && metas.length) {
              return this._cache.data = metas[0].controller.getAllParsedValues(this);
          }
          for(i = 0, ilen = metas.length; i < ilen; ++i){
              timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
          }
          return this._cache.data = this.normalize(timestamps);
      }
   getLabelTimestamps() {
          const timestamps = this._cache.labels || [];
          let i, ilen;
          if (timestamps.length) {
              return timestamps;
          }
          const labels = this.getLabels();
          for(i = 0, ilen = labels.length; i < ilen; ++i){
              timestamps.push(parse$1(this, labels[i]));
          }
          return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
      }
   normalize(values) {
          return _arrayUnique(values.sort(sorter));
      }
  }
  function interpolate(table, val, reverse) {
      let lo = 0;
      let hi = table.length - 1;
      let prevSource, nextSource, prevTarget, nextTarget;
      if (reverse) {
          if (val >= table[lo].pos && val <= table[hi].pos) {
              ({ lo , hi  } = _lookupByKey(table, 'pos', val));
          }
          ({ pos: prevSource , time: prevTarget  } = table[lo]);
          ({ pos: nextSource , time: nextTarget  } = table[hi]);
      } else {
          if (val >= table[lo].time && val <= table[hi].time) {
              ({ lo , hi  } = _lookupByKey(table, 'time', val));
          }
          ({ time: prevSource , pos: prevTarget  } = table[lo]);
          ({ time: nextSource , pos: nextTarget  } = table[hi]);
      }
      const span = nextSource - prevSource;
      return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  class TimeSeriesScale extends TimeScale {
      static id = 'timeseries';
   static defaults = TimeScale.defaults;
   constructor(props){
          super(props);
           this._table = [];
           this._minPos = undefined;
           this._tableRange = undefined;
      }
   initOffsets() {
          const timestamps = this._getTimestampsForTable();
          const table = this._table = this.buildLookupTable(timestamps);
          this._minPos = interpolate(table, this.min);
          this._tableRange = interpolate(table, this.max) - this._minPos;
          super.initOffsets(timestamps);
      }
   buildLookupTable(timestamps) {
          const { min , max  } = this;
          const items = [];
          const table = [];
          let i, ilen, prev, curr, next;
          for(i = 0, ilen = timestamps.length; i < ilen; ++i){
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                  items.push(curr);
              }
          }
          if (items.length < 2) {
              return [
                  {
                      time: min,
                      pos: 0
                  },
                  {
                      time: max,
                      pos: 1
                  }
              ];
          }
          for(i = 0, ilen = items.length; i < ilen; ++i){
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                  table.push({
                      time: curr,
                      pos: i / (ilen - 1)
                  });
              }
          }
          return table;
      }
   _generate() {
          const min = this.min;
          const max = this.max;
          let timestamps = super.getDataTimestamps();
          if (!timestamps.includes(min) || !timestamps.length) {
              timestamps.splice(0, 0, min);
          }
          if (!timestamps.includes(max) || timestamps.length === 1) {
              timestamps.push(max);
          }
          return timestamps.sort((a, b)=>a - b);
      }
   _getTimestampsForTable() {
          let timestamps = this._cache.all || [];
          if (timestamps.length) {
              return timestamps;
          }
          const data = this.getDataTimestamps();
          const label = this.getLabelTimestamps();
          if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
          } else {
              timestamps = data.length ? data : label;
          }
          timestamps = this._cache.all = timestamps;
          return timestamps;
      }
   getDecimalForValue(value) {
          return (interpolate(this._table, value) - this._minPos) / this._tableRange;
      }
   getValueForPixel(pixel) {
          const offsets = this._offsets;
          const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
      }
  }
  var scales = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CategoryScale: CategoryScale,
  LinearScale: LinearScale,
  LogarithmicScale: LogarithmicScale,
  RadialLinearScale: RadialLinearScale,
  TimeScale: TimeScale,
  TimeSeriesScale: TimeSeriesScale
  });
  const registerables = [
      controllers,
      elements,
      plugins,
      scales
  ];
  Chart.register(...registerables);
  /**
   * Fuse.js v7.1.0 - Lightweight fuzzy-search (http://fusejs.io)
   *
   * Copyright (c) 2025 Kiro Risk (http://kiro.me)
   * All Rights Reserved. Apache Software License 2.0
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   */
  function isArray(value) {
    return !Array.isArray
      ? getTag(value) === '[object Array]'
      : Array.isArray(value)
  }
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value
    }
    let result = value + '';
    return result == '0' && 1 / value == -Infinity ? '-0' : result
  }
  function toString(value) {
    return value == null ? '' : baseToString(value)
  }
  function isString(value) {
    return typeof value === 'string'
  }
  function isNumber(value) {
    return typeof value === 'number'
  }
  // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
  function isBoolean(value) {
    return (
      value === true ||
      value === false ||
      (isObjectLike(value) && getTag(value) == '[object Boolean]')
    )
  }
  function isObject(value) {
    return typeof value === 'object'
  }
  // Checks if `value` is object-like.
  function isObjectLike(value) {
    return isObject(value) && value !== null
  }
  function isDefined(value) {
    return value !== undefined && value !== null
  }
  function isBlank(value) {
    return !value.trim().length
  }
  // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
  function getTag(value) {
    return value == null
      ? value === undefined
        ? '[object Undefined]'
        : '[object Null]'
      : Object.prototype.toString.call(value)
  }
  const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>
    `Invalid value for key ${key}`;
  const PATTERN_LENGTH_TOO_LARGE = (max) =>
    `Pattern length exceeds max of ${max}.`;
  const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
  const INVALID_KEY_WEIGHT_VALUE = (key) =>
    `Property 'weight' in key '${key}' must be a positive integer`;
  const hasOwn = Object.prototype.hasOwnProperty;
  class KeyStore {
    constructor(keys) {
      this._keys = [];
      this._keyMap = {};
      let totalWeight = 0;
      keys.forEach((key) => {
        let obj = createKey(key);
        this._keys.push(obj);
        this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });
      // Normalize weights so that their sum is equal to 1
      this._keys.forEach((key) => {
        key.weight /= totalWeight;
      });
    }
    get(keyId) {
      return this._keyMap[keyId]
    }
    keys() {
      return this._keys
    }
    toJSON() {
      return JSON.stringify(this._keys)
    }
  }
  function createKey(key) {
    let path = null;
    let id = null;
    let src = null;
    let weight = 1;
    let getFn = null;
    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'))
      }
      const name = key.name;
      src = name;
      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name))
        }
      }
      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }
    return { path, id, weight, src, getFn }
  }
  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.')
  }
  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key
  }
  function get(obj, path) {
    let list = [];
    let arr = false;
    const deepGet = (obj, path, index) => {
      if (!isDefined(obj)) {
        return
      }
      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        let key = path[index];
        const value = obj[key];
        if (!isDefined(value)) {
          return
        }
        // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list
        if (
          index === path.length - 1 &&
          (isString(value) || isNumber(value) || isBoolean(value))
        ) {
          list.push(toString(value));
        } else if (isArray(value)) {
          arr = true;
          // Search each item in the array.
          for (let i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    };
    // Backwards compatibility (since path used to be a string)
    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0]
  }
  const MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  const BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When `true`, the algorithm will ignore diacritics (accents) in comparisons
    ignoreDiacritics: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: (a, b) =>
      a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1
  };
  const FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  const AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };
  var Config = {
    ...BasicOptions,
    ...MatchOptions,
    ...FuzzyOptions,
    ...AdvancedOptions
  };
  const SPACE = /[^ ]+/g;
  // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.
  function norm(weight = 1, mantissa = 3) {
    const cache = new Map();
    const m = Math.pow(10, mantissa);
    return {
      get(value) {
        const numTokens = value.match(SPACE).length;
        if (cache.has(numTokens)) {
          return cache.get(numTokens)
        }
        // Default function is 1/sqrt(x), weight makes that variable
        const norm = 1 / Math.pow(numTokens, 0.5 * weight);
        // In place of `toFixed(mantissa)`, for faster computation
        const n = parseFloat(Math.round(norm * m) / m);
        cache.set(numTokens, n);
        return n
      },
      clear() {
        cache.clear();
      }
    }
  }
  class FuseIndex {
    constructor({
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    setSources(docs = []) {
      this.docs = docs;
    }
    setIndexRecords(records = []) {
      this.records = records;
    }
    setKeys(keys = []) {
      this.keys = keys;
      this._keysMap = {};
      keys.forEach((key, idx) => {
        this._keysMap[key.id] = idx;
      });
    }
    create() {
      if (this.isCreated || !this.docs.length) {
        return
      }
      this.isCreated = true;
      // List is Array<String>
      if (isString(this.docs[0])) {
        this.docs.forEach((doc, docIndex) => {
          this._addString(doc, docIndex);
        });
      } else {
        // List is Array<Object>
        this.docs.forEach((doc, docIndex) => {
          this._addObject(doc, docIndex);
        });
      }
      this.norm.clear();
    }
    // Adds a doc to the end of the index
    add(doc) {
      const idx = this.size();
      if (isString(doc)) {
        this._addString(doc, idx);
      } else {
        this._addObject(doc, idx);
      }
    }
    // Removes the doc at the specified index of the index
    removeAt(idx) {
      this.records.splice(idx, 1);
      // Change ref index of every subsquent doc
      for (let i = idx, len = this.size(); i < len; i += 1) {
        this.records[i].i -= 1;
      }
    }
    getValueForItemAtKeyId(item, keyId) {
      return item[this._keysMap[keyId]]
    }
    size() {
      return this.records.length
    }
    _addString(doc, docIndex) {
      if (!isDefined(doc) || isBlank(doc)) {
        return
      }
      let record = {
        v: doc,
        i: docIndex,
        n: this.norm.get(doc)
      };
      this.records.push(record);
    }
    _addObject(doc, docIndex) {
      let record = { i: docIndex, $: {} };
      // Iterate over every key (i.e, path), and fetch the value at that key
      this.keys.forEach((key, keyIndex) => {
        let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
        if (!isDefined(value)) {
          return
        }
        if (isArray(value)) {
          let subRecords = [];
          const stack = [{ nestedArrIndex: -1, value }];
          while (stack.length) {
            const { nestedArrIndex, value } = stack.pop();
            if (!isDefined(value)) {
              continue
            }
            if (isString(value) && !isBlank(value)) {
              let subRecord = {
                v: value,
                i: nestedArrIndex,
                n: this.norm.get(value)
              };
              subRecords.push(subRecord);
            } else if (isArray(value)) {
              value.forEach((item, k) => {
                stack.push({
                  nestedArrIndex: k,
                  value: item
                });
              });
            } else ;
          }
          record.$[keyIndex] = subRecords;
        } else if (isString(value) && !isBlank(value)) {
          let subRecord = {
            v: value,
            n: this.norm.get(value)
          };
          record.$[keyIndex] = subRecord;
        }
      });
      this.records.push(record);
    }
    toJSON() {
      return {
        keys: this.keys,
        records: this.records
      }
    }
  }
  function createIndex(
    keys,
    docs,
    { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
  ) {
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex
  }
  function parseIndex(
    data,
    { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}
  ) {
    const { keys, records } = data;
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex
  }
  function computeScore$1(
    pattern,
    {
      errors = 0,
      currentLocation = 0,
      expectedLocation = 0,
      distance = Config.distance,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    const accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy
    }
    const proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy
    }
    return accuracy + proximity / distance
  }
  function convertMaskToIndices(
    matchmask = [],
    minMatchCharLength = Config.minMatchCharLength
  ) {
    let indices = [];
    let start = -1;
    let end = -1;
    let i = 0;
    for (let len = matchmask.length; i < len; i += 1) {
      let match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }
    // (i-1 - start) + 1 => i - start
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    return indices
  }
  // Machine word size
  const MAX_BITS = 32;
  function search(
    text,
    pattern,
    patternAlphabet,
    {
      location = Config.location,
      distance = Config.distance,
      threshold = Config.threshold,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      includeMatches = Config.includeMatches,
      ignoreLocation = Config.ignoreLocation
    } = {}
  ) {
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))
    }
    const patternLen = pattern.length;
    // Set starting location at beginning text and initialize the alphabet.
    const textLen = text.length;
    // Handle the case when location > text.length
    const expectedLocation = Math.max(0, Math.min(location, textLen));
    // Highest score beyond which we give up.
    let currentThreshold = threshold;
    // Is there a nearby exact match? (speedup)
    let bestLocation = expectedLocation;
    // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.
    const computeMatches = minMatchCharLength > 1 || includeMatches;
    // A mask of the matches, used for building the indices
    const matchMask = computeMatches ? Array(textLen) : [];
    let index;
    // Get all exact matches, here for speed up
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      let score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation,
        distance,
        ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (computeMatches) {
        let i = 0;
        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    }
    // Reset the best location
    bestLocation = -1;
    let lastBitArr = [];
    let finalScore = 1;
    let binMax = patternLen + textLen;
    const mask = 1 << (patternLen - 1);
    for (let i = 0; i < patternLen; i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      let binMin = 0;
      let binMid = binMax;
      while (binMin < binMid) {
        const score = computeScore$1(pattern, {
          errors: i,
          currentLocation: expectedLocation + binMid,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }
      // Use the result from this iteration as the maximum for the next.
      binMax = binMid;
      let start = Math.max(1, expectedLocation - binMid + 1);
      let finish = findAllMatches
        ? textLen
        : Math.min(expectedLocation + binMid, textLen) + patternLen;
      // Initialize the bit array
      let bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << i) - 1;
      for (let j = finish; j >= start; j -= 1) {
        let currentLocation = j - 1;
        let charMatch = patternAlphabet[text.charAt(currentLocation)];
        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        }
        // First pass: exact match
        bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;
        // Subsequent passes: fuzzy match
        if (i) {
          bitArr[j] |=
            ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];
        }
        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: i,
            currentLocation,
            expectedLocation,
            distance,
            ignoreLocation
          });
          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation;
            // Already passed `loc`, downhill from here on in.
            if (bestLocation <= expectedLocation) {
              break
            }
            // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }
      // No hope for a (better) match at greater error levels.
      const score = computeScore$1(pattern, {
        errors: i + 1,
        currentLocation: expectedLocation,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score > currentThreshold) {
        break
      }
      lastBitArr = bitArr;
    }
    const result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };
    if (computeMatches) {
      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result
  }
  function createPatternAlphabet(pattern) {
    let mask = {};
    for (let i = 0, len = pattern.length; i < len; i += 1) {
      const char = pattern.charAt(i);
      mask[char] = (mask[char] || 0) | (1 << (len - i - 1));
    }
    return mask
  }
  const stripDiacritics = String.prototype.normalize
      ? ((str) => str.normalize('NFD').replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g, ''))
      : ((str) => str);
  class BitapSearch {
    constructor(
      pattern,
      {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreDiacritics = Config.ignoreDiacritics,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      this.options = {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreDiacritics,
        ignoreLocation
      };
      pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
      this.pattern = pattern;
      this.chunks = [];
      if (!this.pattern.length) {
        return
      }
      const addChunk = (pattern, startIndex) => {
        this.chunks.push({
          pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex
        });
      };
      const len = this.pattern.length;
      if (len > MAX_BITS) {
        let i = 0;
        const remainder = len % MAX_BITS;
        const end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }
        if (remainder) {
          const startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    searchIn(text) {
      const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;
      text = isCaseSensitive ? text : text.toLowerCase();
      text = ignoreDiacritics ? stripDiacritics(text) : text;
      // Exact match
      if (this.pattern === text) {
        let result = {
          isMatch: true,
          score: 0
        };
        if (includeMatches) {
          result.indices = [[0, text.length - 1]];
        }
        return result
      }
      // Otherwise, use Bitap algorithm
      const {
        location,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        ignoreLocation
      } = this.options;
      let allIndices = [];
      let totalScore = 0;
      let hasMatches = false;
      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
        const { isMatch, score, indices } = search(text, pattern, alphabet, {
          location: location + startIndex,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          includeMatches,
          ignoreLocation
        });
        if (isMatch) {
          hasMatches = true;
        }
        totalScore += score;
        if (isMatch && indices) {
          allIndices = [...allIndices, ...indices];
        }
      });
      let result = {
        isMatch: hasMatches,
        score: hasMatches ? totalScore / this.chunks.length : 1
      };
      if (hasMatches && includeMatches) {
        result.indices = allIndices;
      }
      return result
    }
  }
  class BaseMatch {
    constructor(pattern) {
      this.pattern = pattern;
    }
    static isMultiMatch(pattern) {
      return getMatch(pattern, this.multiRegex)
    }
    static isSingleMatch(pattern) {
      return getMatch(pattern, this.singleRegex)
    }
    search(/*text*/) {}
  }
  function getMatch(pattern, exp) {
    const matches = pattern.match(exp);
    return matches ? matches[1] : null
  }
  // Token: 'file
  class ExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'exact'
    }
    static get multiRegex() {
      return /^="(.*)"$/
    }
    static get singleRegex() {
      return /^=(.*)$/
    }
    search(text) {
      const isMatch = text === this.pattern;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  }
  // Token: !fire
  class InverseExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-exact'
    }
    static get multiRegex() {
      return /^!"(.*)"$/
    }
    static get singleRegex() {
      return /^!(.*)$/
    }
    search(text) {
      const index = text.indexOf(this.pattern);
      const isMatch = index === -1;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }
  // Token: ^file
  class PrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'prefix-exact'
    }
    static get multiRegex() {
      return /^\^"(.*)"$/
    }
    static get singleRegex() {
      return /^\^(.*)$/
    }
    search(text) {
      const isMatch = text.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      }
    }
  }
  // Token: !^fire
  class InversePrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-prefix-exact'
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/
    }
    static get singleRegex() {
      return /^!\^(.*)$/
    }
    search(text) {
      const isMatch = !text.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }
  // Token: .file$
  class SuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'suffix-exact'
    }
    static get multiRegex() {
      return /^"(.*)"\$$/
    }
    static get singleRegex() {
      return /^(.*)\$$/
    }
    search(text) {
      const isMatch = text.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [text.length - this.pattern.length, text.length - 1]
      }
    }
  }
  // Token: !.file$
  class InverseSuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'inverse-suffix-exact'
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/
    }
    static get singleRegex() {
      return /^!(.*)\$$/
    }
    search(text) {
      const isMatch = !text.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      }
    }
  }
  class FuzzyMatch extends BaseMatch {
    constructor(
      pattern,
      {
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance,
        includeMatches = Config.includeMatches,
        findAllMatches = Config.findAllMatches,
        minMatchCharLength = Config.minMatchCharLength,
        isCaseSensitive = Config.isCaseSensitive,
        ignoreDiacritics = Config.ignoreDiacritics,
        ignoreLocation = Config.ignoreLocation
      } = {}
    ) {
      super(pattern);
      this._bitapSearch = new BitapSearch(pattern, {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreDiacritics,
        ignoreLocation
      });
    }
    static get type() {
      return 'fuzzy'
    }
    static get multiRegex() {
      return /^"(.*)"$/
    }
    static get singleRegex() {
      return /^(.*)$/
    }
    search(text) {
      return this._bitapSearch.searchIn(text)
    }
  }
  // Token: 'file
  class IncludeMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return 'include'
    }
    static get multiRegex() {
      return /^'"(.*)"$/
    }
    static get singleRegex() {
      return /^'(.*)$/
    }
    search(text) {
      let location = 0;
      let index;
      const indices = [];
      const patternLen = this.pattern.length;
      // Get all exact matches
      while ((index = text.indexOf(this.pattern, location)) > -1) {
        location = index + patternLen;
        indices.push([index, location - 1]);
      }
      const isMatch = !!indices.length;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices
      }
    }
  }
  // ❗Order is important. DO NOT CHANGE.
  const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch
  ];
  const searchersLen = searchers.length;
  // Regex to split by spaces, but keep anything in quotes together
  const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  const OR_TOKEN = '|';
  // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
  function parseQuery(pattern, options = {}) {
    return pattern.split(OR_TOKEN).map((item) => {
      let query = item
        .trim()
        .split(SPACE_RE)
        .filter((item) => item && !!item.trim());
      let results = [];
      for (let i = 0, len = query.length; i < len; i += 1) {
        const queryItem = query[i];
        // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
        let found = false;
        let idx = -1;
        while (!found && ++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }
        if (found) {
          continue
        }
        // 2. Handle single query matches (i.e, once that are *not* quoted)
        idx = -1;
        while (++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isSingleMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            break
          }
        }
      }
      return results
    })
  }
  // These extended matchers can return an array of matches, as opposed
  // to a singl match
  const MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);
  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */
  class ExtendedSearch {
    constructor(
      pattern,
      {
        isCaseSensitive = Config.isCaseSensitive,
        ignoreDiacritics = Config.ignoreDiacritics,
        includeMatches = Config.includeMatches,
        minMatchCharLength = Config.minMatchCharLength,
        ignoreLocation = Config.ignoreLocation,
        findAllMatches = Config.findAllMatches,
        location = Config.location,
        threshold = Config.threshold,
        distance = Config.distance
      } = {}
    ) {
      this.query = null;
      this.options = {
        isCaseSensitive,
        ignoreDiacritics,
        includeMatches,
        minMatchCharLength,
        findAllMatches,
        ignoreLocation,
        location,
        threshold,
        distance
      };
      pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;
      this.pattern = pattern;
      this.query = parseQuery(this.pattern, this.options);
    }
    static condition(_, options) {
      return options.useExtendedSearch
    }
    searchIn(text) {
      const query = this.query;
      if (!query) {
        return {
          isMatch: false,
          score: 1
        }
      }
      const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;
      text = isCaseSensitive ? text : text.toLowerCase();
      text = ignoreDiacritics ? stripDiacritics(text) : text;
      let numMatches = 0;
      let allIndices = [];
      let totalScore = 0;
      // ORs
      for (let i = 0, qLen = query.length; i < qLen; i += 1) {
        const searchers = query[i];
        // Reset indices
        allIndices.length = 0;
        numMatches = 0;
        // ANDs
        for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {
          const searcher = searchers[j];
          const { isMatch, indices, score } = searcher.search(text);
          if (isMatch) {
            numMatches += 1;
            totalScore += score;
            if (includeMatches) {
              const type = searcher.constructor.type;
              if (MultiMatchSet.has(type)) {
                allIndices = [...allIndices, ...indices];
              } else {
                allIndices.push(indices);
              }
            }
          } else {
            totalScore = 0;
            numMatches = 0;
            allIndices.length = 0;
            break
          }
        }
        // OR condition, so if TRUE, return
        if (numMatches) {
          let result = {
            isMatch: true,
            score: totalScore / numMatches
          };
          if (includeMatches) {
            result.indices = allIndices;
          }
          return result
        }
      }
      // Nothing was matched
      return {
        isMatch: false,
        score: 1
      }
    }
  }
  const registeredSearchers = [];
  function register(...args) {
    registeredSearchers.push(...args);
  }
  function createSearcher(pattern, options) {
    for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
      let searcherClass = registeredSearchers[i];
      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options)
      }
    }
    return new BitapSearch(pattern, options)
  }
  const LogicalOperator = {
    AND: '$and',
    OR: '$or'
  };
  const KeyType = {
    PATH: '$path',
    PATTERN: '$val'
  };
  const isExpression = (query) =>
    !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  const isPath = (query) => !!query[KeyType.PATH];
  const isLeaf = (query) =>
    !isArray(query) && isObject(query) && !isExpression(query);
  const convertToExplicit = (query) => ({
    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
      [key]: query[key]
    }))
  });
  // When `auto` is `true`, the parse function will infer and initialize and add
  // the appropriate `Searcher` instance
  function parse(query, options, { auto = true } = {}) {
    const next = (query) => {
      let keys = Object.keys(query);
      const isQueryPath = isPath(query);
      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
        return next(convertToExplicit(query))
      }
      if (isLeaf(query)) {
        const key = isQueryPath ? query[KeyType.PATH] : keys[0];
        const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))
        }
        const obj = {
          keyId: createKeyId(key),
          pattern
        };
        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }
        return obj
      }
      let node = {
        children: [],
        operator: keys[0]
      };
      keys.forEach((key) => {
        const value = query[key];
        if (isArray(value)) {
          value.forEach((item) => {
            node.children.push(next(item));
          });
        }
      });
      return node
    };
    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }
    return next(query)
  }
  // Practical scoring function
  function computeScore(
    results,
    { ignoreFieldNorm = Config.ignoreFieldNorm }
  ) {
    results.forEach((result) => {
      let totalScore = 1;
      result.matches.forEach(({ key, norm, score }) => {
        const weight = key ? key.weight : null;
        totalScore *= Math.pow(
          score === 0 && weight ? Number.EPSILON : score,
          (weight || 1) * (ignoreFieldNorm ? 1 : norm)
        );
      });
      result.score = totalScore;
    });
  }
  function transformMatches(result, data) {
    const matches = result.matches;
    data.matches = [];
    if (!isDefined(matches)) {
      return
    }
    matches.forEach((match) => {
      if (!isDefined(match.indices) || !match.indices.length) {
        return
      }
      const { indices, value } = match;
      let obj = {
        indices,
        value
      };
      if (match.key) {
        obj.key = match.key.src;
      }
      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }
      data.matches.push(obj);
    });
  }
  function transformScore(result, data) {
    data.score = result.score;
  }
  function format(
    results,
    docs,
    {
      includeMatches = Config.includeMatches,
      includeScore = Config.includeScore
    } = {}
  ) {
    const transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    return results.map((result) => {
      const { idx } = result;
      const data = {
        item: docs[idx],
        refIndex: idx
      };
      if (transformers.length) {
        transformers.forEach((transformer) => {
          transformer(result, data);
        });
      }
      return data
    })
  }
  class Fuse {
    constructor(docs, options = {}, index) {
      this.options = { ...Config, ...options };
      if (
        this.options.useExtendedSearch &&
        false
      ) ;
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }
    setCollection(docs, index) {
      this._docs = docs;
      if (index && !(index instanceof FuseIndex)) {
        throw new Error(INCORRECT_INDEX_TYPE)
      }
      this._myIndex =
        index ||
        createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn,
          fieldNormWeight: this.options.fieldNormWeight
        });
    }
    add(doc) {
      if (!isDefined(doc)) {
        return
      }
      this._docs.push(doc);
      this._myIndex.add(doc);
    }
    remove(predicate = (/* doc, idx */) => false) {
      const results = [];
      for (let i = 0, len = this._docs.length; i < len; i += 1) {
        const doc = this._docs[i];
        if (predicate(doc, i)) {
          this.removeAt(i);
          i -= 1;
          len -= 1;
          results.push(doc);
        }
      }
      return results
    }
    removeAt(idx) {
      this._docs.splice(idx, 1);
      this._myIndex.removeAt(idx);
    }
    getIndex() {
      return this._myIndex
    }
    search(query, { limit = -1 } = {}) {
      const {
        includeMatches,
        includeScore,
        shouldSort,
        sortFn,
        ignoreFieldNorm
      } = this.options;
      let results = isString(query)
        ? isString(this._docs[0])
          ? this._searchStringList(query)
          : this._searchObjectList(query)
        : this._searchLogical(query);
      computeScore(results, { ignoreFieldNorm });
      if (shouldSort) {
        results.sort(sortFn);
      }
      if (isNumber(limit) && limit > -1) {
        results = results.slice(0, limit);
      }
      return format(results, this._docs, {
        includeMatches,
        includeScore
      })
    }
    _searchStringList(query) {
      const searcher = createSearcher(query, this.options);
      const { records } = this._myIndex;
      const results = [];
      // Iterate over every string in the index
      records.forEach(({ v: text, i: idx, n: norm }) => {
        if (!isDefined(text)) {
          return
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          results.push({
            item: text,
            idx,
            matches: [{ score, value: text, norm, indices }]
          });
        }
      });
      return results
    }
    _searchLogical(query) {
      const expression = parse(query, this.options);
      const evaluate = (node, item, idx) => {
        if (!node.children) {
          const { keyId, searcher } = node;
          const matches = this._findMatches({
            key: this._keyStore.get(keyId),
            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
            searcher
          });
          if (matches && matches.length) {
            return [
              {
                idx,
                item,
                matches
              }
            ]
          }
          return []
        }
        const res = [];
        for (let i = 0, len = node.children.length; i < len; i += 1) {
          const child = node.children[i];
          const result = evaluate(child, item, idx);
          if (result.length) {
            res.push(...result);
          } else if (node.operator === LogicalOperator.AND) {
            return []
          }
        }
        return res
      };
      const records = this._myIndex.records;
      const resultMap = {};
      const results = [];
      records.forEach(({ $: item, i: idx }) => {
        if (isDefined(item)) {
          let expResults = evaluate(expression, item, idx);
          if (expResults.length) {
            // Dedupe when adding
            if (!resultMap[idx]) {
              resultMap[idx] = { idx, item, matches: [] };
              results.push(resultMap[idx]);
            }
            expResults.forEach(({ matches }) => {
              resultMap[idx].matches.push(...matches);
            });
          }
        }
      });
      return results
    }
    _searchObjectList(query) {
      const searcher = createSearcher(query, this.options);
      const { keys, records } = this._myIndex;
      const results = [];
      // List is Array<Object>
      records.forEach(({ $: item, i: idx }) => {
        if (!isDefined(item)) {
          return
        }
        let matches = [];
        // Iterate over every key (i.e, path), and fetch the value at that key
        keys.forEach((key, keyIndex) => {
          matches.push(
            ...this._findMatches({
              key,
              value: item[keyIndex],
              searcher
            })
          );
        });
        if (matches.length) {
          results.push({
            idx,
            item,
            matches
          });
        }
      });
      return results
    }
    _findMatches({ key, value, searcher }) {
      if (!isDefined(value)) {
        return []
      }
      let matches = [];
      if (isArray(value)) {
        value.forEach(({ v: text, i: idx, n: norm }) => {
          if (!isDefined(text)) {
            return
          }
          const { isMatch, score, indices } = searcher.searchIn(text);
          if (isMatch) {
            matches.push({
              score,
              key,
              value: text,
              idx,
              norm,
              indices
            });
          }
        });
      } else {
        const { v: text, n: norm } = value;
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches.push({ score, key, value: text, norm, indices });
        }
      }
      return matches
    }
  }
  Fuse.version = '7.1.0';
  Fuse.createIndex = createIndex;
  Fuse.parseIndex = parseIndex;
  Fuse.config = Config;
  {
    Fuse.parseQuery = parse;
  }
  {
    register(ExtendedSearch);
  }
  // Make libraries available globally
  window.Chart = Chart;
  window.Fuse = Fuse;
})();
//# sourceMappingURL=vendor.bundle.js.map
</file>

<file path="assets/js/vendor.bundle.js.map">
{"version":3,"file":"vendor.bundle.js","sources":["../../node_modules/@kurkle/color/dist/color.esm.js","../../node_modules/chart.js/dist/chunks/helpers.segment.js","../../node_modules/chart.js/dist/chart.js","../../node_modules/chart.js/auto/auto.js","../../node_modules/fuse.js/dist/fuse.mjs","vendor-entry.js"],"sourcesContent":["/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/*!\n * Chart.js v4.4.7\n * https://www.chartjs.org\n * (c) 2024 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , _parsed  } = meta;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n        clip: true,\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */ /**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = Math.floor(chart.height);\n    chart.width = Math.floor(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, fontString as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, overrideTextDirection as aA, _textX as aB, restoreTextDirection as aC, drawPointLegend as aD, distanceBetweenPoints as aE, noop as aF, _setMinAndMaxByKey as aG, niceNum as aH, almostWhole as aI, almostEquals as aJ, _decimalPlaces as aK, Ticks as aL, log10 as aM, _longestText as aN, _filterBetween as aO, _lookup as aP, isPatternOrGradient as aQ, getHoverColor as aR, clone as aS, _merger as aT, _mergerIf as aU, _deprecated as aV, _splitKey as aW, toFontString as aX, splineCurve as aY, splineCurveMonotone as aZ, getStyle as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, _elementsEqual as ah, _isClickEvent as ai, _isBetween as aj, _readValueToProps as ak, _updateBezierControlPoints as al, _computeSegments as am, _boundSegments as an, _steppedInterpolation as ao, _bezierInterpolation as ap, _pointInLine as aq, _steppedLineTo as ar, _bezierCurveTo as as, drawPoint as at, addRoundedRectPath as au, toTRBL as av, toTRBLCorners as aw, _boundSegment as ax, _normalizeAngle as ay, getRtlAdapter as az, isArray as b, toLineHeight as b0, PITAU as b1, INFINITY as b2, RAD_PER_DEG as b3, QUARTER_PI as b4, TWO_THIRDS_PI as b5, _angleDiff as b6, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };\n//# sourceMappingURL=helpers.segment.js.map\n","/*!\n * Chart.js v4.4.7\n * https://www.chartjs.org\n * (c) 2024 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, i as isObject, d as defaults, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as defined, s as sign, j as createContext, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as getRelativePosition, A as _rlookupByKey, B as _lookupByKey, C as _isPointInArea, D as getAngleFromPoint, E as toPadding, F as each, G as getMaximumSize, I as _getParentNode, J as readUsedSize, K as supportsEventListenerOptions, L as throttled, M as _isDomSupported, N as _factorize, O as finiteOrDefault, Q as callback, R as _addGrace, S as _limitValue, U as toDegrees, V as _measureText, W as _int16Range, X as _alignPixel, Y as clipArea, Z as renderText, $ as unclipArea, a0 as toFont, a1 as _toLeftRightCenter, a2 as _alignStartEnd, a3 as overrides, a4 as merge, a5 as _capitalize, a6 as descriptors, a7 as isFunction, a8 as _attachContext, a9 as _createResolver, aa as _descriptors, ab as mergeIf, ac as uid, ad as debounce, ae as retinaScale, af as clearCanvas, ag as setsEqual, ah as _elementsEqual, ai as _isClickEvent, aj as _isBetween, ak as _readValueToProps, al as _updateBezierControlPoints, am as _computeSegments, an as _boundSegments, ao as _steppedInterpolation, ap as _bezierInterpolation, aq as _pointInLine, ar as _steppedLineTo, as as _bezierCurveTo, at as drawPoint, au as addRoundedRectPath, av as toTRBL, aw as toTRBLCorners, ax as _boundSegment, ay as _normalizeAngle, az as getRtlAdapter, aA as overrideTextDirection, aB as _textX, aC as restoreTextDirection, aD as drawPointLegend, aE as distanceBetweenPoints, aF as noop, aG as _setMinAndMaxByKey, aH as niceNum, aI as almostWhole, aJ as almostEquals, aK as _decimalPlaces, aL as Ticks, aM as log10, aN as _longestText, aO as _filterBetween, aP as _lookup } from './chunks/helpers.segment.js';\nimport '@kurkle/color';\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = color(from || transparent);\n        const c1 = c0.valid && color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = effects[cfg.easing] || effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale , vScale  } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (isObject(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(HALF_PI, startY, endY);\n        const minX = calcMin(PI, startX, endX);\n        const minY = calcMin(PI + HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = TAU;\n        let max = -TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPieController: PieController,\nPolarAreaController: PolarAreaController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    options;\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (_angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if (defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = canvas && _getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    x;\n    y;\n    active = false;\n    options;\n    $animations;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return isNumber(this.x) && isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = _factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = valueOrDefault(majorStart, 0);\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = toFont(options.font, fallback);\n    const padding = toPadding(options.padding);\n    const lines = isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n     let ret = _toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = _alignStartEnd(align, left, right);\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: finiteOrDefault(_userMin, _suggestedMin),\n            max: finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: isNumberFinite(_userMin),\n            maxDefined: isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = _addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!isNullOrUndef(label) && !isArray(label)) {\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel =  label[j];\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return _alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = toFont(title.font);\n        const padding = toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\n            offset += padding.bottom;\n            if (isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in defaults[scope]) {\n            delete defaults[scope][id];\n            if (this.override) {\n                delete overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = merge(Object.create(null), [\n        parentScope ? defaults.get(parentScope) : {},\n        defaults.get(scope),\n        item.defaults\n    ]);\n    defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = _capitalize(method);\n        callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        mergeIf(scale, [\n            defaults.scales[scale.type],\n            defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            overrides[type] || {},\n            defaults.datasets[type] || {},\n            {\n                type\n            },\n            defaults,\n            descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = _attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = _createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.4.7\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (_isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nclass Chart {\n    static defaults = defaults;\n    static instances = instances;\n    static overrides = overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, isFunction(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = getDatasetArea(meta, this.chartArea);\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (useClip) {\n            clipArea(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return _isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = _isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return _readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, 𝜃) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash'\n    };\n    circumference;\n    endAngle;\n    fullCircles;\n    innerRadius;\n    outerRadius;\n    pixelMargin;\n    startAngle;\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n        const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= TAU || nonZeroBetween;\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\n function getLineMethod(options) {\n    if (options.stepped) {\n        return _steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierInterpolation;\n    }\n    return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = _boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    parsed;\n    skip;\n    stop;\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nBarElement: BarElement,\nLineElement: LineElement,\nPointElement: PointElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\n        const { elements  } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = _boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = _boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = _normalizeAngle(start);\n        end = _normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (_isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    if (target && line.points.length) {\n        clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    if (property === 'x' && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top , bottom  } = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x') {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            clipArea(ctx, this);\n            this._draw();\n            unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = defaults.color;\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = _alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\n        this._padding = toPadding(opts.padding);\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = _alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = _alignStartEnd(align, bottom, top);\n                rotation = PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = _alignStartEnd(align, top, bottom);\n                rotation = PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: _toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const titleFont = toFont(options.titleFont);\n    const footerFont = toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    each(body, (bodyItem)=>{\n        each(bodyItem.before, maxLineWidth);\n        each(bodyItem.lines, maxLineWidth);\n        each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: _limitValue(x, 0, chart.width - size.width),\n        y: _limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: noop,\n    beforeBody: noop,\n    beforeLabel: noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: noop,\n    afterBody: noop,\n    beforeFooter: noop,\n    footer: noop,\n    afterFooter: noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = toTRBLCorners(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !isNullOrUndef(min);\n    const maxDefined = !isNullOrUndef(max);\n    const countDefined = !isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = sign(min);\n            const maxSign = sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? min : 0;\n        this.max = isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = log10(start);\n        this._valueRange = log10(this.max) - log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = toPadding(tickOpts.backdropPadding);\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: _longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra , additionalAngle , padding , size  } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left , top , right , bottom  } = item;\n    const apexesInArea = _isPointInArea({\n        x: left,\n        y: top\n    }, area) || _isPointInArea({\n        x: left,\n        y: bottom\n    }, area) || _isPointInArea({\n        x: right,\n        y: top\n    }, area) || _isPointInArea({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels , display  } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? PI / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left , top , right , bottom  } = item;\n    const { backdropColor  } = opts;\n    if (!isNullOrUndef(backdropColor)) {\n        const borderRadius = toTRBLCorners(opts.borderRadius);\n        const padding = toPadding(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            addRoundedRectPath(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = toFont(optsAtIndex.font);\n        const { x , y , textAlign  } = item;\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = _lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = _filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = _limitValue(start, 0, limit);\n        end = _limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return _arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, plugin_colors as Colors, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, defaults, elements, layouts, plugins, registerables, registry, scales };\n//# sourceMappingURL=chart.js.map\n","import {Chart, registerables} from '../dist/chart.js';\n\nChart.register(...registerables);\n\nexport * from '../dist/chart.js';\nexport default Chart;\n","/**\n * Fuse.js v7.1.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2025 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When `true`, the algorithm will ignore diacritics (accents) in comparisons\n  ignoreDiacritics: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nconst stripDiacritics = String.prototype.normalize\n    ? ((str) => str.normalize('NFD').replace(/[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C04\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]/g, ''))\n    : ((str) => str);\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreDiacritics = Config.ignoreDiacritics,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreDiacritics,\n      ignoreLocation\n    };\n\n    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;\n    this.pattern = pattern;\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, ignoreDiacritics, includeMatches } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n    text = ignoreDiacritics ? stripDiacritics(text) : text;\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreDiacritics = Config.ignoreDiacritics,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreDiacritics,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// ❗Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreDiacritics = Config.ignoreDiacritics,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      ignoreDiacritics,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    pattern = ignoreDiacritics ? stripDiacritics(pattern) : pattern;\n    this.pattern = pattern;\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive, ignoreDiacritics } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n    text = ignoreDiacritics ? stripDiacritics(text) : text;\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '7.1.0';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n","import Chart from 'chart.js/auto';\nimport Fuse from 'fuse.js';\n\n// Make libraries available globally\nwindow.Chart = Chart;\nwindow.Fuse = Fuse; "],"names":["map","interpolate","clone","isArray","isObject","isNumber","Config","parse"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}
</file>

<file path="assets/js/wiki-graph.js">
function initializeGraph(data, currentPage) {
  const width = document.getElementById('graph-container').clientWidth;
  const height = 500;
  // Create SVG container
  const svg = d3.select('#graph-container')
    .append('svg')
    .attr('width', width)
    .attr('height', height);
  // Create force simulation
  const simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.edges).id(d => d.id))
    .force('charge', d3.forceManyBody().strength(-100))
    .force('center', d3.forceCenter(width / 2, height / 2));
  // Create edges
  const edges = svg.append('g')
    .selectAll('line')
    .data(data.edges)
    .enter()
    .append('line')
    .attr('stroke', d => getRelationshipColor(d.type))
    .attr('stroke-width', d => d.weight * 2);
  // Create nodes
  const nodes = svg.append('g')
    .selectAll('circle')
    .data(data.nodes)
    .enter()
    .append('circle')
    .attr('r', 5)
    .attr('fill', d => getClusterColor(d.cluster))
    .call(drag(simulation));
  // Add node labels
  const labels = svg.append('g')
    .selectAll('text')
    .data(data.nodes)
    .enter()
    .append('text')
    .text(d => d.title)
    .attr('font-size', '10px')
    .attr('dx', 8)
    .attr('dy', 3);
  // Add hover effects
  nodes
    .on('mouseover', highlightConnections)
    .on('mouseout', resetHighlight);
  // Update positions on each tick
  simulation.on('tick', () => {
    edges
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y);
    nodes
      .attr('cx', d => d.x)
      .attr('cy', d => d.y);
    labels
      .attr('x', d => d.x)
      .attr('y', d => d.y);
  });
  // Highlight current page
  if (currentPage) {
    const currentNode = nodes.filter(d => d.id === currentPage);
    currentNode
      .attr('r', 8)
      .attr('stroke', '#000')
      .attr('stroke-width', 2);
  }
}
function updateGraphView(mode) {
  switch (mode) {
    case 'focused':
      // Show only directly connected nodes
      showFocusedView();
      break;
    case 'cluster':
      // Show nodes in the same cluster
      showClusterView();
      break;
    case 'full':
      // Show all nodes
      showFullGraph();
      break;
  }
}
function showFocusedView() {
  const nodes = d3.selectAll('circle');
  const edges = d3.selectAll('line');
  const labels = d3.selectAll('text');
  // Get connected nodes
  const connectedNodes = new Set();
  edges.each(d => {
    if (d.source.id === currentPage) connectedNodes.add(d.target.id);
    if (d.target.id === currentPage) connectedNodes.add(d.source.id);
  });
  // Show only connected nodes
  nodes.style('opacity', d => 
    d.id === currentPage || connectedNodes.has(d.id) ? 1 : 0.1
  );
  edges.style('opacity', d =>
    d.source.id === currentPage || d.target.id === currentPage ? 1 : 0.1
  );
  labels.style('opacity', d =>
    d.id === currentPage || connectedNodes.has(d.id) ? 1 : 0.1
  );
}
function showClusterView() {
  const nodes = d3.selectAll('circle');
  const edges = d3.selectAll('line');
  const labels = d3.selectAll('text');
  const currentCluster = nodes.filter(d => d.id === currentPage).datum().cluster;
  nodes.style('opacity', d => d.cluster === currentCluster ? 1 : 0.1);
  edges.style('opacity', d =>
    d.source.cluster === currentCluster && d.target.cluster === currentCluster ? 1 : 0.1
  );
  labels.style('opacity', d => d.cluster === currentCluster ? 1 : 0.1);
}
function showFullGraph() {
  d3.selectAll('circle, line, text').style('opacity', 1);
}
function getClusterColor(cluster) {
  const metadata = JSON.parse(document.getElementById('wiki-metadata').textContent);
  return metadata.clusters[cluster].color;
}
function getRelationshipColor(type) {
  const metadata = JSON.parse(document.getElementById('wiki-metadata').textContent);
  return metadata.relationship_types[type].color;
}
function highlightConnections(event, d) {
  const nodes = d3.selectAll('circle');
  const edges = d3.selectAll('line');
  const labels = d3.selectAll('text');
  // Get connected nodes
  const connectedNodes = new Set();
  edges.each(edge => {
    if (edge.source === d) connectedNodes.add(edge.target);
    if (edge.target === d) connectedNodes.add(edge.source);
  });
  // Highlight connected elements
  nodes.style('opacity', node => 
    node === d || connectedNodes.has(node) ? 1 : 0.1
  );
  edges.style('opacity', edge =>
    edge.source === d || edge.target === d ? 1 : 0.1
  );
  labels.style('opacity', node =>
    node === d || connectedNodes.has(node) ? 1 : 0.1
  );
}
function resetHighlight() {
  d3.selectAll('circle, line, text').style('opacity', 1);
}
function drag(simulation) {
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }
  return d3.drag()
    .on('start', dragstarted)
    .on('drag', dragged)
    .on('end', dragended);
}
</file>

<file path="assets/js/wiki-preview.js">
// Create preview element
const previewEl = document.createElement('div');
previewEl.className = 'wiki-preview';
document.body.appendChild(previewEl);
// Style preview element
const style = document.createElement('style');
style.textContent = `
  .wiki-preview {
    position: fixed;
    display: none;
    max-width: 400px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 1000;
  }
  .wiki-preview-title {
    font-size: 1.2rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: #333;
  }
  .wiki-preview-summary {
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 0.5rem;
  }
  .wiki-preview-metadata {
    display: flex;
    gap: 0.5rem;
    font-size: 0.8rem;
  }
  .wiki-preview-tag {
    padding: 0.125rem 0.375rem;
    border-radius: 4px;
    color: white;
  }
`;
document.head.appendChild(style);
// Add hover listeners to wiki links
document.addEventListener('DOMContentLoaded', () => {
  const wikiLinks = document.querySelectorAll('a.wiki-link');
  wikiLinks.forEach(link => {
    link.addEventListener('mouseenter', showPreview);
    link.addEventListener('mouseleave', hidePreview);
  });
});
async function showPreview(event) {
  const link = event.target;
  const href = link.getAttribute('href');
  try {
    // Fetch page data
    const response = await fetch(href);
    const text = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'text/html');
    // Extract metadata
    const title = doc.querySelector('.wiki-title').textContent;
    const summary = doc.querySelector('.wiki-summary')?.textContent;
    const category = doc.querySelector('[data-category]')?.dataset.category;
    const difficulty = doc.querySelector('[data-difficulty]')?.dataset.difficulty;
    // Position preview
    const rect = link.getBoundingClientRect();
    previewEl.style.top = `${rect.bottom + window.scrollY + 8}px`;
    previewEl.style.left = `${rect.left + window.scrollX}px`;
    // Update preview content
    previewEl.innerHTML = `
      <div class="wiki-preview-title">${title}</div>
      ${summary ? `<div class="wiki-preview-summary">${summary}</div>` : ''}
      <div class="wiki-preview-metadata">
        ${category ? `
          <span class="wiki-preview-tag" style="background-color: ${getCategoryColor(category)}">
            ${category}
          </span>
        ` : ''}
        ${difficulty ? `
          <span class="wiki-preview-tag" style="background-color: ${getDifficultyColor(difficulty)}">
            ${difficulty}
          </span>
        ` : ''}
      </div>
    `;
    previewEl.style.display = 'block';
  } catch (error) {
    console.error('Error loading preview:', error);
  }
}
function hidePreview() {
  previewEl.style.display = 'none';
}
function getCategoryColor(category) {
  const metadata = JSON.parse(document.getElementById('wiki-metadata').textContent);
  return metadata.categories[category]?.color || '#999';
}
function getDifficultyColor(difficulty) {
  const metadata = JSON.parse(document.getElementById('wiki-metadata').textContent);
  return metadata.difficulty_levels[difficulty]?.color || '#999';
}
</file>

<file path="client/src/hooks/usePriceUpdates.js">
import { useState, useEffect } from 'react';
import axios from 'axios';
export function usePriceUpdates(transactions) {
  const [progress, setProgress] = useState({
    total: 0,
    completed: 0,
    failed: 0,
    status: 'idle'
  });
  const [updatedPrices, setUpdatedPrices] = useState(new Map());
  useEffect(() => {
    if (!transactions?.length) return;
    // Start the price update process
    const startUpdate = async () => {
      try {
        // Queue transactions for update
        await axios.post('/api/prices/queue', { transactions });
      } catch (error) {
        console.error('Failed to queue price updates:', error);
      }
    };
    startUpdate();
  }, [transactions]);
  useEffect(() => {
    // Set up SSE connection for progress updates
    const eventSource = new EventSource('/api/prices/progress');
    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'progress') {
        setProgress(data.progress);
      } else if (data.type === 'price_update') {
        setUpdatedPrices(prev => {
          const next = new Map(prev);
          for (const update of data.updates) {
            const key = `${update.token}-${update.timestamp}`;
            next.set(key, update.price);
          }
          return next;
        });
      }
    };
    eventSource.onerror = (error) => {
      console.error('SSE connection error:', error);
      eventSource.close();
    };
    return () => {
      eventSource.close();
    };
  }, []);
  // Get the latest price for a transaction
  const getPrice = (token, timestamp) => {
    const key = `${token}-${timestamp}`;
    return updatedPrices.get(key);
  };
  return {
    progress,
    getPrice,
    isUpdating: progress.status === 'processing',
    isComplete: progress.status === 'completed'
  };
}
</file>

<file path="docs/analysis.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
Okay, let's dive into the codebase analysis. Here's a breakdown of issues and potential improvements across different areas:

## Codebase Analysis: Issues and Improvements

### Jekyll Configuration Issues (`_config.yml`, `_config.development.yml`, `Gemfile`)

*   **Issue:** Inconsistent `url` setting.
    *   `_config.yml` has `url: "https://dao.cg"` (production).
    *   `_config.development.yml` has `url: "http://localhost:4000"` (development).
    *   **Improvement:** Ensure `url` in `_config.yml` is the primary domain and consider using environment variables or data files for dynamic configuration to manage different environments more cleanly.

*   **Issue:** `theme: null` and `remote_theme: null` are explicitly set to `null`.
    *   **Note:** This is intentional to disable themes, which is fine if the project is fully custom-built, but worth noting.

*   **Issue:** `include` in `_config.yml` only lists `assets/js/*.js`.
    *   **Improvement:** Consider including other asset types if needed for Jekyll to process them, though for JS files, Rollup is used.

*   **Issue:** `Gemfile` includes `github-pages` gem.
    *   **Note:** This is appropriate for GitHub Pages hosting, ensuring compatibility with the GitHub Pages build environment.

*   **Quick Win:** Add comments to `_config.yml` to clarify the purpose of specific settings, especially `domain_aliases`, `production`, and `compress_html`.

*   **Roadmap Item:** Implement a more robust environment configuration using data files or environment variables for easier management of different environments (development, staging, production).

### CSS Issues (`assets/css`)

*   **Issue:** Potential CSS redundancy and lack of component-based CSS.
    *   Multiple CSS files (`main.css`, `treasury-v2.css`, `wiki-components.css`, `wiki.css`) suggest feature-specific styling, which can lead to duplication and maintenance challenges.
    *   **Improvement:**  Adopt a more component-based CSS approach. For example, move treasury specific styles from `treasury-v2.css` into corresponding component-specific CSS files or modules (if using a CSS preprocessor or framework).  Consider using CSS Modules or a CSS-in-JS solution for better component encapsulation and reduced specificity issues.

*   **Issue:**  `main.css` is very large and contains general styles, layout styles, typography, and page-specific styles.
    *   **Improvement:** Refactor `main.css` to separate concerns. Split it into:
        *   `base.css`: Reset, variables, typography defaults.
        *   `layout.css`: Grid system, container, header, footer, general layout structures.
        *   `components.css`: Reusable components like cards, buttons, navigation, etc.
        *   `utilities.css`: Utility classes for spacing, typography, etc.
        *   This will improve maintainability and reduce the size of individual files.

*   **Issue:**  Repetitive media queries within each CSS file.
    *   **Improvement:** Centralize media queries. Define breakpoints as CSS variables in `:root` and reuse them across CSS files for consistency and easier updates. Consider using a CSS preprocessor like Sass for mixins to handle media queries more efficiently.

*   **Issue:** Some styles are duplicated in different CSS files (e.g., `.card`, `.grid`).
    *   **Improvement:** Identify and extract reusable styles into `components.css` or utility classes in `utilities.css`. Utilize CSS variables to manage colors, fonts, and spacing consistently across the site.

*   **Issue:**  `wiki-components.css` and `treasury-search.html`/`treasury_sidebar.html`/`wiki_search.html`/`wiki_sidebar.html` include `<style>` tags directly within HTML.
    *   **Improvement:** Move all styles to CSS files for better separation of concerns and maintainability. Import component-specific CSS files into `main.css` or respective layout files.

*   **Quick Win:** Add comments to CSS files to explain sections, variables, and complex styles.
*   **Quick Win:** Review and optimize CSS variable usage for consistency and maintainability.
*   **Roadmap Item:** Consider adopting a CSS framework (like Tailwind CSS or Bootstrap) or a CSS-in-JS solution to streamline styling, improve consistency, and enhance maintainability. This would be a more significant undertaking but could offer long-term benefits.

### Template Issues (`_layouts`, `_includes`, `wiki`, `_pages`)

*   **Issue:**  Inconsistency in layout structure.
    *   Different layouts (`default.html`, `home.html`, `page.html`, `stakeholder.html`, `treasury.html`, `wiki.html`) have varying structures and may not consistently use includes or shared components.
    *   **Improvement:** Standardize layout structure. Create a base layout (`base.html`) and have other layouts extend it, ensuring consistent header, footer, sidebar, and content areas across the site.

*   **Issue:** Redundant includes and potential for more reusable components.
    *   `treasury_search.html` and `wiki_search.html` are very similar.
    *   `wiki_breadcrumb.html` and `wiki_breadcrumbs.html` seem to serve similar purposes.
    *   **Improvement:**  Consolidate redundant includes into more generic, reusable components with parameters. For example, create a single search component (`search.html`) that can be used in both treasury and wiki sections with different placeholders and functionalities. Create a single breadcrumb component (`breadcrumbs.html`) with dynamic path generation.

*   **Issue:**  Accessibility could be improved.
    *   Lack of sufficient ARIA attributes in some components.
    *   **Improvement:** Review templates for accessibility best practices. Add ARIA attributes for better screen reader support, ensure proper semantic HTML structure, and check color contrast ratios.

*   **Issue:**  Some templates (e.g., `treasury.html`, `wiki.html`) use inline `<style>` tags.
    *   **Improvement:** Move all styles to external CSS files for better maintainability and separation of concerns.

*   **Issue:**  JavaScript is included directly in some templates (e.g., `treasury_search.html`, `treasury_sidebar.html`, `wiki_graph.html`, `wiki_search.html`).
    *   **Improvement:** Move JavaScript code to external JS files. Use data attributes and event delegation to connect JavaScript functionality to HTML elements. This improves separation of concerns and makes code easier to maintain and test.

*   **Quick Win:** Standardize class naming conventions (BEM, SMACSS, etc.) across all templates and CSS for better maintainability and readability.
*   **Quick Win:**  Use Jekyll includes more consistently to avoid code duplication within templates.
*   **Roadmap Item:**  Consider using a component-based JavaScript framework (like React or Vue.js) for more complex and interactive components, especially in the Treasury and Wiki sections. This would be a significant refactoring but would enhance maintainability and allow for more complex UI interactions.

### JavaScript Issues (`assets/js`, `client/src/hooks`)

*   **Issue:** Global scope pollution.
    *   JavaScript code in `assets/js` often directly manipulates the global `window` object (e.g., `window.treasury`, `window.priceUpdates`, `window.treasuryCharts`, `window.treasuryDashboard`, `window.Fuse`, `window.Chart`).
    *   **Improvement:**  Encapsulate JavaScript functionality within modules and avoid polluting the global scope. Use module exports and imports to manage dependencies and scope.

*   **Issue:**  Direct DOM manipulation within JavaScript code embedded in HTML (e.g., `wiki-preview.js`, `treasury_search.html`).
    *   **Improvement:**  Separate JavaScript logic from HTML structure. Move all JavaScript code to external files and use event listeners and DOM manipulation within these files.

*   **Issue:**  Potential performance issues with large JavaScript bundles and unoptimized code.
    *   `vendor.bundle.js` is a large bundle that includes Chart.js and Fuse.js.
    *   **Improvement:**  Optimize JavaScript bundles. Use code splitting and tree-shaking in Rollup configuration to reduce bundle sizes. Consider lazy-loading non-critical JavaScript code. Review JavaScript code for performance bottlenecks and optimize where necessary.

*   **Issue:**  Lack of clear separation of concerns in some JavaScript files.
    *   `treasury-v2.js` seems to handle both data fetching, chart creation, and DOM manipulation.
    *   **Improvement:**  Refactor JavaScript code to separate concerns. For example, create separate modules for data fetching (`treasury-v2-data.js`), chart rendering (`treasury-v2-charts.js`), and UI interactions (`treasury-v2-ui.js`). Use classes or functional components to encapsulate related logic.

*   **Issue:**  `usePriceUpdates.js` hook in `client/src/hooks` mixes SSE connection logic and React state management.
    *   **Improvement:**  Separate SSE connection logic from the React hook. Create a separate utility function or class to manage the SSE connection and progress updates, and use the hook to consume data from this utility. This will improve testability and maintainability.

*   **Issue:**  `mobile-nav.js` and `wiki-preview.js` use inline styles.
    *   **Improvement:** Move styles to CSS files.

*   **Quick Win:** Add JSDoc comments to JavaScript functions and classes to improve code documentation.
*   **Roadmap Item:**  Implement unit tests for JavaScript code, especially for data processing and UI logic, to ensure code quality and prevent regressions during future development.
*   **Roadmap Item:** Consider migrating to a modern JavaScript framework (like React, Vue.js, or Svelte) for better component management, state management, and overall code organization, especially if more complex interactive features are planned for the website.

### Mobile-Readiness Problems

*   **Issue:**  Treasury and Wiki sidebars are sticky but may not be ideal on smaller mobile screens.
    *   **Improvement:**  On mobile, consider making sidebars collapsible or using a different navigation pattern (e.g., bottom navigation or off-canvas menu) for better usability on smaller screens. The existing `wiki-sidebar-toggle` is a good start.

*   **Issue:**  Table layouts, especially in the Treasury section, might not be fully responsive on mobile.
    *   **Improvement:** Implement responsive table layouts using CSS techniques like horizontal scrolling, stacked layouts, or card-based layouts for smaller screens.

*   **Issue:**  Network visualization graph may not be responsive or usable on mobile devices.
    *   **Improvement:**  Ensure the network graph is responsive and scales appropriately for mobile devices. Consider simplifying the graph or providing alternative mobile-friendly visualizations.

*   **Quick Win:** Thoroughly test the website on various mobile devices and screen sizes to identify and fix mobile-specific layout and usability issues.
*   **Roadmap Item:** Implement a dedicated mobile navigation and layout strategy to optimize the user experience on smaller screens. Consider using media queries to adapt the layout and component behavior based on screen size.

### Quick Wins

*   **CSS Comments:** Add more comments to CSS files to improve readability and maintainability.
*   **CSS Variables:** Review and ensure consistent usage of CSS variables for theming and styling.
*   **JSDoc Comments:** Add JSDoc comments to JavaScript functions and classes.
*   **Template Includes:** Consolidate and reuse Jekyll includes to reduce code duplication.
*   **Code Formatting:** Ensure consistent code formatting across all file types (using Prettier or similar).

### Roadmap Items

*   **Component-Based CSS/Framework:** Migrate to a component-based CSS architecture or framework for better styling organization and maintainability.
*   **JavaScript Framework:** Consider migrating to a modern JavaScript framework (React, Vue.js, Svelte) for enhanced interactivity and maintainability, especially for complex components.
*   **Unit Testing:** Implement unit tests for JavaScript code to improve code quality and prevent regressions.
*   **Environment Configuration:** Implement a more robust environment configuration system using data files or environment variables.
*   **Mobile Navigation & Layout Strategy:** Develop a dedicated mobile navigation and layout strategy for better mobile usability.
*   **Accessibility Audit:** Conduct a thorough accessibility audit and implement necessary improvements.
*   **Performance Optimization:** Optimize JavaScript bundles, CSS, and image assets for improved website performance.
*   **Search Functionality Improvements:** Enhance wiki search functionality (e.g., using Algolia or ElasticSearch for more advanced search features).

This detailed analysis should provide a good starting point for addressing issues and planning future improvements for the Common Ground DAO website. Remember to prioritize tasks based on their impact and effort required, starting with quick wins and addressing more complex roadmap items in a phased approach.
</file>

<file path="docs/css-assessment-2.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
```tool_code
cursor-tools repo "cat assets/css/layout.css"
cursor-tools repo "cat assets/css/templates.css"
cursor-tools repo "cat assets/css/components.css"
```
</file>

<file path="docs/css-assessment-3.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
```tool_code
cursor-tools repo "cat assets/css/layout.css"
cursor-tools repo "cat assets/css/templates.css"
```
</file>

<file path="docs/css-assessment.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
## CSS Modularization Assessment

The modular CSS structure implemented in `assets/css` (base.css, layout.css, components.css, utilities.css, templates.css, and main.css) shows a good attempt at separating concerns. However, there are areas for improvement to enhance maintainability, responsiveness, and overall modularity.

**Positive Aspects:**

*   **Separation of Concerns:** The file structure generally reflects a good separation of concerns:
    *   `base.css`: Handles resets, core CSS variables, and typography defaults, which is a solid foundation.
    *   `layout.css`: Focuses on structural elements like grid, container, header, and footer, promoting layout consistency.
    *   `components.css`: Aims to house reusable component styles, improving component reusability.
    *   `utilities.css`: Contains utility classes, which is excellent for quick styling adjustments and consistency.
    *   `templates.css`: Intended for template-specific styles, although this might need further refinement (see below).
    *   `main.css`: Serves as the main entry point, importing other modules and setting global variables, which is a good practice for maintainability.

*   **CSS Variables:** The use of CSS variables in `:root` within `main.css` is a strong point, promoting theming and consistency across the site. The variables cover colors, typography scales, font weights, and line heights, which is comprehensive.

*   **Utility Classes:** The `utilities.css` file is a positive addition, providing reusable utility classes for common styling needs like margins, padding, text alignment, and display properties.

**Issues, Inconsistencies, and Potential Pitfalls:**

*   **Template-Specific Styles in `templates.css`:**
    *   While intended for template styles, `templates.css` currently contains styles for core elements like `header`, `main`, `footer`, `hero`, `content-container`, and typography within `.content`. This mixes layout concerns with more generic template styles.
    *   **Maintainability Pitfall:** Over time, `templates.css` could become bloated and harder to maintain as more page-specific styles are added. It also overlaps with `layout.css` and `components.css` in some areas, leading to potential confusion and specificity issues.
    *   **Responsiveness Concerns:** Media queries are present in `templates.css`, blurring the lines between layout-specific and component-specific responsiveness.

*   **Component Styles in `main.css` and `templates.css`:**
    *   Styles for `.card` and `.grid` are defined in `main.css`, while they are intended to be reusable components and should ideally reside in `components.css`.
    *   **Inconsistency:** This creates inconsistency in where component styles are located and makes it harder to find and modify component-specific styles.

*   **Redundancy and Duplication:**
    *   There's potential redundancy in styles across files. For example, basic typography styles might be repeated in different files instead of being centralized in `base.css` or utilities.
    *   **Maintainability Pitfall:** Duplicated styles increase CSS file sizes and make updates and maintenance more complex, as changes might need to be applied in multiple places.

*   **Responsiveness Distribution:**
    *   Media queries are scattered across multiple CSS files (`main.css`, `treasury-v2.css`, and within HTML `<style>` tags).
    *   **Responsiveness Concerns:** This distributed approach to media queries makes it harder to manage breakpoints and ensure consistent responsiveness across the site. It also increases the risk of inconsistencies and conflicts.

*   **Specificity Issues:**
    *   With styles spread across multiple files and potentially overlapping selectors, there's a risk of increased CSS specificity, making it harder to override styles and creating maintenance headaches.

*   **`vendor.bundle.js` Styles:**
    *   While not directly a CSS issue, including JavaScript libraries within a large `vendor.bundle.js` can impact initial load performance. While vendor CSS isn't directly included here, it's worth noting for overall performance considerations.

**Recommendations for Improvements:**

1.  **Refactor `templates.css`:**
    *   **Move core layout styles** (header, footer, container, basic page structure) to `layout.css`.
    *   **Move generic content typography styles** (headings, paragraphs, lists, links, code, tables, images, etc.) to `base.css` or consider a dedicated `typography.css` if these styles become extensive.
    *   **Reserve `templates.css` for truly template-specific styles**, such as unique styling for the homepage hero section or specific page layouts that are not reusable components.

2.  **Consolidate Component Styles:**
    *   **Move `.card` and `.grid` styles from `main.css` to `components.css`.**
    *   **Thoroughly review all CSS files and move any other reusable component styles to `components.css`.** This includes styles for navigation elements, search inputs, list items, etc.

3.  **Centralize Media Queries:**
    *   **Define breakpoints as CSS variables in `:root` within `base.css` (already partially done).**
    *   **Use these CSS variables consistently in media queries across all CSS files.**
    *   **Consider using CSS preprocessors like Sass for mixins** to manage media queries and breakpoint reuse more effectively. This could involve creating mixins like `@mixin breakpoint($bp) { @media (max-width: var(--breakpoint-#{$bp})) { @content; } }` and using them like `@include breakpoint(sm) { ... }`.

4.  **Eliminate Inline Styles:**
    *   **Move all `<style>` tags from HTML templates** (e.g., `treasury_search.html`, `wiki_sidebar.html`, `wiki-preview.js`, `mobile-nav.js`) to dedicated CSS files.
    *   For component-specific styles, create CSS files alongside the component includes (e.g., `_includes/treasury_search.html` and `assets/css/components/treasury-search.css`). Import these component-specific CSS files into `main.css` or relevant layout files.
    *   For JavaScript-driven styles (like in `wiki-preview.js` and `mobile-nav.js`), consider if these styles can be moved to CSS files and managed with classes toggled by JavaScript instead of direct inline style manipulation. If inline styles are absolutely necessary for dynamic styling, minimize their use and keep them focused on dynamic properties.

5.  **Optimize CSS Variables:**
    *   **Review CSS variables in `main.css` and ensure they cover all essential theming aspects** (colors, fonts, spacing, breakpoints).
    *   **Document CSS variables with comments** in `main.css` to explain their purpose and usage.

6.  **Implement Stylelint:**
    *   **Integrate Stylelint** into the build process to enforce CSS style consistency, catch errors, and prevent potential issues. Configure Stylelint with recommended rules for CSS organization, naming conventions, and best practices.

7.  **Consider CSS Framework or CSS-in-JS (Roadmap Item):**
    *   For a more long-term solution to CSS maintainability and scalability, consider adopting a CSS framework like Tailwind CSS or Bootstrap, or a CSS-in-JS solution like Styled Components or Emotion. This would require a significant refactoring effort but can offer substantial benefits in terms of development speed, consistency, and maintainability, especially as the website grows in complexity.

**Prioritization:**

*   **Quick Wins:** Address quick wins like adding CSS comments, optimizing CSS variables, and standardizing class names first. These are relatively easy to implement and offer immediate benefits in terms of code clarity and maintainability.
*   **Medium Effort:** Refactor `templates.css`, consolidate component styles, centralize media queries, and eliminate inline styles. These will require more effort but will significantly improve the modularity, responsiveness, and maintainability of the CSS codebase.
*   **Roadmap Item (Long-Term):** Consider adopting a CSS framework or CSS-in-JS solution as a longer-term project. This is a more significant undertaking but can provide substantial long-term benefits, especially if the website is expected to grow and evolve significantly.

By addressing these issues and implementing the recommendations, the CSS codebase can become more maintainable, scalable, and easier to work with, leading to a more robust and efficient development process.
</file>

<file path="docs/template-assessment.md">
{% raw %}
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
Okay, let's analyze the Jekyll templates, includes, and layouts. Here's an assessment based on the provided files, focusing on consistency, duplication, maintainability, and recommendations for improvements:

## Jekyll Templates, Includes, and Layouts Assessment

**1. Base Layout (`_layouts/base.html`): Good Foundation**

*   **Positive:**
    *   Sets up the basic HTML structure (`<!DOCTYPE html>`, `html`, `head`, `body`).
    *   Includes essential meta tags for character set, viewport, and title.
    *   Includes `head.html` (not provided, but assumed to contain meta and link tags).
    *   Includes `header.html` and `footer.html` for consistent site-wide elements.
    *   Defines the `<main>` content area, which is standard practice for semantic HTML.
    *   Includes a `main.js` script at the end of the `body`, suggesting proper separation of JavaScript.
    *   Provides a solid, minimal base structure that other layouts can extend.

*   **Potential Improvements:**
    *   Consider adding `lang="en"` attribute to the `<html>` tag for accessibility.
    *   The `<link rel="stylesheet" href="/assets/css/main.css">` is hardcoded. While `main.css` is the main entry point, consider making this more dynamic if there's a possibility of using different stylesheets for different layouts or sections (though this might be overkill for this project).

**2. Default Layout (`_layouts/default.html`): Simple and Effective**

*   **Positive:**
    *   Extends `base.html` using `layout: base`, which is the correct way to inherit the base structure.
    *   Includes `{{ content }}` to inject page-specific content, as expected.
    *   Provides a clean and straightforward default layout for general pages.

*   **Potential Improvements:**
    *   None major. It's intentionally simple and serves its purpose well.

**3. Home Layout (`_layouts/home.html`): Building on Default**

*   **Positive:**
    *   Extends `default.html`, inheriting from the base structure and default page layout.
    *   Wraps content in `content-container` and `content` divs, suggesting consistent content styling.
    *   Includes a section for "Latest Updates" with a post list, which is specific to the homepage.

*   **Potential Improvements:**
    *   The "Latest Updates" section is hardcoded into the `home.html` layout. Consider making this a reusable include (`_includes/home_updates.html`) for better modularity, in case you want to display updates on other pages or in different formats.

**4. Page Layout (`_layouts/page.html`): Consistent Page Structure**

*   **Positive:**
    *   Extends `default.html`, maintaining consistency.
    *   Uses `content-container` and `content` divs for content, similar to `home.html`.

*   **Potential Improvements:**
    *   None major. It's a good, simple layout for general content pages.

**5. Stakeholder Layout (`_layouts/stakeholder.html`): Specific Layout for Stakeholder Pages**

*   **Positive:**
    *   Extends `default.html`, keeping the base layout consistent.
    *   Has a distinct `stakeholder-emoji` in the title, which is a nice visual touch.
    *   Includes specific sections for stakeholder information (role, location, expertise, bio, representatives, social links, CTA).

*   **Potential Improvements:**
    *   The layout is quite specific to stakeholder pages. If there are more page types with similar structured data display, consider creating more generic, reusable components (e.g., a "data card" or "profile card" include) that can be parameterized for different types of data.

**6. Treasury Layout (`_layouts/treasury.html`):  Dashboard-Style Layout**

*   **Positive:**
    *   Extends `default.html`, maintaining base structure.
    *   Implements a two-column layout using CSS Grid (`treasury-container`, `treasury-sidebar`, `treasury-content`), which is appropriate for a dashboard-style page.
    *   Includes `treasury_sidebar.html` and `treasury_search.html`, modularizing treasury-specific elements.

*   **Potential Improvements:**
    *   The two-column structure is hardcoded into the layout. Consider making the sidebar optional or more dynamically controlled (e.g., through frontmatter variables) if there's a need for treasury pages without a sidebar.

**7. Wiki Layout (`_layouts/wiki.html`): Wiki Article Layout**

*   **Positive:**
    *   Extends `default.html`, good consistency.
    *   Implements a two-column layout using CSS Grid (`wiki-container`, `wiki-sidebar`, `wiki-content`), similar to `treasury.html` but for wiki content.
    *   Includes `wiki_sidebar.html` and `wiki_search.html`, modularizing wiki-specific elements.
    *   Handles category index pages using Liquid logic (`{% if page.is_category_index %}`) to display article lists, which is a good approach.

*   **Potential Improvements:**
    *   Similar to `treasury.html`, the two-column structure is fixed. Consider making the sidebar optional or more flexible.
    *   The conditional logic within `wiki.html` for category and tag index pages and regular wiki pages is getting a bit complex.  While Liquid templating is used, if this logic grows much more complex, it might be worth considering moving some of this logic into a Jekyll plugin or using JavaScript for more dynamic content rendering.

**8. Header Include (`_includes/header.html`): Standard Header**

*   **Positive:**
    *   Contains the site header structure, logo, navigation links, and "Join Community" button.
    *   Uses CSS classes (`logo`, `nav-links`, `join-button`) for styling, which is good.

*   **Potential Improvements:**
    *   Navigation links are hardcoded. Consider making the navigation links data-driven, perhaps from a data file or frontmatter, to make it easier to update and manage the navigation menu.

**9. Footer Include (`_includes/footer.html`): Standard Footer**

*   **Positive:**
    *   Contains the site footer structure, logo, DAO info, resources, and social links.
    *   Uses CSS classes (`footer-logo`, `footer-links`, `social-links`) for styling.

*   **Potential Improvements:**
    *   Similar to the header, the footer links could be data-driven for easier management.

**General Recommendations for Improvements:**

1.  **Enhance Base Layout (`_layouts/base.html`):**
    *   Add `lang="en"` to `<html>`.
    *   Consider making the stylesheet link dynamic if needed in the future.

2.  **Modularize Homepage Updates:**
    *   Move the "Latest Updates" section in `_layouts/home.html` to a reusable include (`_includes/home_updates.html`).

3.  **Generic Components:**
    *   Create more generic, parameterized includes for reusable UI patterns:
        *   `_includes/search.html`: A single search component with placeholder and functionality variations.
        *   `_includes/breadcrumbs.html`: A single breadcrumb component with dynamic path generation.
        *   `_includes/data_card.html` or `_includes/profile_card.html`: A generic card component for displaying structured data, which could be used for stakeholders, wiki articles, etc.

4.  **Template Logic Review:**
    *   Simplify conditional logic in `_layouts/wiki.html` if it becomes more complex. Consider Jekyll plugins or JavaScript for dynamic rendering if needed.

5.  **Data-Driven Navigation and Footer Links:**
    *   Make header and footer navigation links data-driven for easier updates. Use Jekyll data files (`_data`) or frontmatter to define navigation items.

6.  **Mobile Responsiveness Focus:**
    *   Make sidebars in `treasury.html` and `wiki.html` more mobile-friendly (collapsible or alternative navigation).

7.  **Accessibility Focus:**
    *   Review all templates for accessibility and implement ARIA attributes, semantic HTML, and color contrast improvements.

By implementing these improvements, the Jekyll template structure will become more modular, consistent, maintainable, and easier to extend in the future. This will also improve the overall user experience, especially on mobile devices. Remember to address the quick wins first and then tackle the more substantial roadmap items incrementally.
{% endraw %}
</file>

<file path="docs/template-final-assessment.md">
{% raw %}
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
Okay, based on the provided file contents, let's conduct a final assessment of the Jekyll templates, includes, and layouts, focusing on the key areas you've highlighted:

## Final Assessment of Jekyll Templates, Includes, and Layouts

After reviewing the code, here's a breakdown of the current state and final recommendations:

**1. Base Layout (`_layouts/base.html`): Excellent Base**

*   **Assessment:**  The `base.html` layout is well-structured and serves as an excellent foundation. It includes `head.html`, `header.html`, `footer.html`, and the main content area, providing a consistent base for all other layouts. The inclusion of `assets/css/main.css` and `assets/js/main.js` is also appropriate. The addition of `<meta charset="UTF-8">` and `<meta name="viewport" content="width=device-width, initial-scale=1.0">` in `head.html` (as included in `base.html`) ensures proper character encoding and responsiveness.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**2. Default Layout (`_layouts/default.html`): Correct Usage**

*   **Assessment:**  `default.html` correctly extends `base.html` and injects content as expected. It remains simple and maintainable.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**3. Home Layout (`_layouts/home.html`): Improved, but Minor Point Remains**

*   **Assessment:** `home.html` extends `default.html` and includes `_includes/home_updates.html`, which is a good move towards modularity as previously suggested. The layout structure with hero and content sections is well-defined.
*   **Status:** Good.
*   **Final Recommendations:**
    *   While `_includes/home_updates.html` is now an include, consider if the "Latest Updates" section *itself* should be even more generic or data-driven. Currently, it's a placeholder with static text. If dynamic updates are intended, ensure the `_includes/home_updates.html` is set up to handle that data dynamically, perhaps by fetching data or using Jekyll collections. However, if it's just a placeholder, the current implementation is fine.

**4. Page Layout (`_layouts/page.html`): Good and Simple**

*   **Assessment:**  `page.html` continues to be a simple and effective layout for general content pages, extending `default.html`.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**5. Stakeholder Layout (`_layouts/stakeholder.html`): Well-Structured**

*   **Assessment:**  `stakeholder.html` effectively presents stakeholder-specific information in a structured manner. The use of includes within the content area (like `{% stakeholder rep_id %}`) is a good example of component reuse.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**6. Treasury Layout (`_layouts/treasury.html`): Good Dashboard Structure**

*   **Assessment:**  `treasury.html` correctly implements a two-column dashboard layout using includes for the sidebar and search (`treasury_sidebar.html`, `treasury_search.html`). The structure is appropriate for its purpose.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**7. Wiki Layout (`_layouts/wiki.html`): Improved Category Index Handling**

*   **Assessment:** `wiki.html` effectively handles both individual wiki articles and category index pages using conditional logic. The use of `wiki_sidebar.html` and `wiki_search.html` promotes modularity. The inclusion of `wiki_article_list.html` for displaying article cards is a good reusable component.
*   **Status:** Good.
*   **Final Recommendations:**
    *   The conditional logic in `wiki.html` is still somewhat complex. While manageable, if further complexity is anticipated for the wiki section, consider if a more structured approach to template rendering (e.g., using Jekyll plugins or a more dynamic frontend framework) might be beneficial long-term. For now, the current implementation is acceptable.

**8. Includes (`_includes`): Good Modularization**

*   **Assessment:** The includes are generally well-organized and contribute to code reuse:
    *   `head.html`, `header.html`, `footer.html`, `home_updates.html`: Core site-wide elements and homepage-specific sections are appropriately modularized.
    *   `treasury_search.html`, `treasury_sidebar.html`: Treasury-specific components are well-contained.
    *   `wiki_article_list.html`, `wiki_breadcrumb.html`, `wiki_breadcrumbs.html`, `wiki_graph.html`, `wiki_metadata.html`, `wiki_nav.html`, `wiki_navigation.html`, `wiki_related.html`, `wiki_search.html`, `wiki_sidebar.html`: Wiki-specific components are well-modularized, demonstrating a component-based approach within the wiki section.

*   **Status:** Excellent.
*   **Final Recommendations:**
    *   Consolidate `wiki_breadcrumb.html` and `wiki_breadcrumbs.html` into a single, more flexible breadcrumb component (`breadcrumbs.html`) that can handle different contexts dynamically, as previously suggested.
    *   Consider creating a more generic `search.html` component to replace both `treasury_search.html` and `wiki_search.html`, using parameters to customize the placeholder text and search functionality if needed.

**9. Pages (`_pages`, `wiki`, `_stakeholders`): Content Pages**

*   **Assessment:**  Pages within `_pages`, `_stakeholders`, and `wiki` directories are correctly using the appropriate layouts (`page.html`, `stakeholder.html`, `wiki.html`). Markdown content is well-structured.
*   **Status:** Excellent.
*   **Final Recommendations:** No further recommendations.

**Final Summary and Recommendations:**

The Jekyll templates, includes, and layouts are in a good state overall, showing a clear effort towards modularity and maintainability. The codebase demonstrates a reasonable separation of concerns and good use of Jekyll's templating features.

**Key areas that are well-implemented:**

*   Base layout and layout inheritance.
*   Modularization of header, footer, sidebars, and reusable components using includes.
*   Use of CSS Grid for layout structure in treasury and wiki sections.
*   Use of CSS variables for theming.

**Final Recommendations (Prioritized):**

1.  **Consolidate Breadcrumb Includes:** Merge `wiki_breadcrumb.html` and `wiki_breadcrumbs.html` into a single, dynamic `_includes/breadcrumbs.html` component. (Medium Effort)
2.  **Generic Search Component:** Create a generic `_includes/search.html` component to replace `treasury_search.html` and `wiki_search.html`. (Low Effort)
3.  **Review and Refine `_includes/home_updates.html`:** Ensure it's set up for dynamic updates if intended, or clarify its purpose if it's meant to be static. (Low Effort)
4.  **Consider Long-Term Template Logic Strategy:** For the Wiki section, keep an eye on the complexity of conditional logic in `_layouts/wiki.html`. If it grows significantly, consider more advanced templating or frontend framework options as a roadmap item.

These final recommendations are mostly focused on further refining the existing structure and enhancing reusability. The codebase is well-organized and maintainable, especially after the improvements implemented based on previous assessments. The suggested roadmap items are for future scalability and potential enhancements, not critical issues.
{% endraw %}
</file>

<file path="docs/template-improvements-roadmap.md">
# Template Improvements Roadmap for Common Ground Website

This roadmap outlines the improvements planned for the Jekyll templates (_layouts, _includes, and template files) to streamline the codebase, improve maintainability, and enhance responsiveness and accessibility.

## 1. Standardizing Layouts

- **Create a Base Layout:**
  - Develop a `_layouts/base.html` that includes the core structure (html head, header, footer, main content, etc.).
  - Use Liquid's `include` and `extends` (or similar) functionality for consistency.
  - Remove duplicated markup from individual layout files.

- **Refactor Existing Layouts:**
  - Update existing layouts (e.g., `default.html`, `home.html`, `page.html`, `treasury.html`, `wiki.html`) to extend from the new base layout.
  - Ensure consistency in header, footer, and navigational sections.

## 2. Consolidating Includes

- **Unified Navigation & Header:**
  - Create or update a single `_includes/header.html` containing the site header and navigation.
  - Remove redundant header declarations from individual templates.

- **Unified Footer:**
  - Move footer markup into `_includes/footer.html` and ensure all layouts include this file.

- **Merge Similar Components:**
  - Identify and combine overlapping components such as search bars, breadcrumbs, or other repeated template elements.
  - Parameterize includes to support variations (e.g., using include variables if needed).

## 3. Removing Inline Styles and Scripts

- **Remove Inline CSS and JavaScript:**
  - Move inline `<style>` blocks from templates into appropriate CSS files.
  - Relocate inline JavaScript into external script files and trigger functionalities via data attributes and event listeners.

## 4. Improving Accessibility

- **Audit for Accessibility:**
  - Review templates for semantic HTML and ARIA roles/attributes.
  - Update navigation, forms, and interactive elements for better screen reader support.

## 5. Enhancing Consistency and Code Clean-Up

- **Adopt Naming Conventions:**
  - Decide on a naming convention (BEM, SMACSS, or another) and apply it consistently across templates and includes.
  - Remove commented-out code and ensure that duplicated code is consolidated.

- **Documentation and Comments:**
  - Add comments in templates to describe sections, particularly in the base layout and include files.
  - Maintain documentation on how templates are structured and how overrides work.

## 6. Mobile-Readiness & Responsiveness

- **Responsive Markup:**
  - Ensure that layouts are responsive by applying consistent container classes and media queries.
  - Test the layout on various devices and update templates to improve mobile navigation (e.g., off-canvas menus).

- **Template-Specific Overrides:**
  - Isolate template-specific styles (e.g., hero sections, page-specific layouts) in dedicated overrides.
  - Use CSS modules or appropriate scoping to prevent style leakage between templates.

## 7. Future Enhancements / Roadmap Items

- **Modern JavaScript Framework Consideration:**
  - Evaluate whether a modern framework (e.g., Vue.js or React) might simplify complex template behaviors in the future.
  - Explore component-based architecture for dynamic parts of the site.

- **Testing and Linting:**
  - Integrate automated tests for template rendering and unit tests for JavaScript behavior.
  - Introduce a templating linter or use tools like HTMLHint to keep the code clean.

- **Performance Optimizations:**
  - Monitor the build process for any unnecessary bloat in the generated site.
  - Consider using Jekyll plugins or build steps to optimize and minify HTML output.

---

This roadmap serves as the blueprint for our next steps in template improvement. Each step should be tackled incrementally, with testing after significant changes to ensure that the site remains functional and accessible.
</file>

<file path="docs/template-styles-analysis.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
Okay, let's analyze the relationship between your Jekyll templates and CSS files. Here's a detailed assessment based on your codebase:

## CSS and Template Integration Analysis

After reviewing the CSS files in `assets/css/` and the templates in `_layouts/` and `_includes/`, here's a detailed analysis addressing your questions:

**1. CSS Class Mismatches (CSS Classes Defined vs. Template Usage):**

*   **General Good Alignment:** For the most part, CSS classes defined in your CSS files are used in the templates. The codebase shows a conscious effort to use classes for styling elements.

*   **Potential Mismatches & Areas for Review:**
    *   **`templates.css` and `layout.css` Overlap:** As noted in the previous analysis, styles for layout elements (like `header`, `footer`, `.container`, `.hero`, `.content-container`, `.grid`) are spread across `layout.css` and `templates.css`. This separation is blurred, and some classes might be defined in one but used in templates expecting them to be in the other. **Action:** Consolidate layout-related classes in `layout.css` and template-specific styles (if any remain after refactoring) in `templates.css`.
    *   **`main.css` and `components.css` Overlap:** Similarly, some component-like styles (e.g., `.card`, `.button`) are defined in `main.css` instead of `components.css`. This creates inconsistency. **Action:** Move component-specific styles to `components.css` for better organization.
    *   **Wiki and Treasury Specific CSS:**  Styles in `wiki-components.css` and `treasury-v2.css` are generally used within their respective templates (`_includes/wiki_*`, `_includes/treasury_*` and `_layouts/wiki.html`, `_layouts/treasury.html`). However, it's worth double-checking for any unused classes within these files to ensure they are all actively applied. **Action:** Review `wiki-components.css` and `treasury-v2.css` for unused classes and verify all defined classes are used in the related templates.
    *   **Dynamic Classes in JavaScript:** JavaScript files like `mobile-nav.js`, `wiki-preview.js`, and `treasury-v2.js` may dynamically add or remove classes. Ensure these classes are actually defined in your CSS files. **Action:** Review JavaScript files and confirm that dynamically added/removed classes have corresponding CSS definitions in your stylesheets.

**2. Duplicate Style Definitions:**

*   **Identified Duplicates:**
    *   **`.card` and `.grid` styles:**  As mentioned, styles for `.card` and `.grid` are defined in both `main.css` and potentially in template-specific CSS (like `wiki.css`, `treasury-v2.css`).  This is a clear duplication.
    *   **Typography Styles:** There might be some duplication of basic typography styles (headings, paragraphs, lists) across `base.css`, `templates.css`, and potentially other CSS files. For instance, heading styles are present in `main.css` and `templates.css`.
    *   **Layout Structures:** Some basic layout structures, like containers or grid systems, might be partially redefined in different CSS files.

*   **Consolidation Needed:**
    *   **Action:**  Aggressively consolidate duplicate styles. Define `.card` and `.grid` styles (and other reusable component styles) *only* in `components.css`. Ensure base typography styles are *only* in `base.css`. Layout structures should be primarily in `layout.css`. Remove redundant definitions from `main.css`, `templates.css`, and other CSS files.
    *   **Action:** Use CSS variables extensively for colors, fonts, spacing, and sizes. This helps in maintaining consistency and reduces the need to repeat style values across different CSS files.  If you're not already, adopt CSS variables for breakpoints as well.

**3. Style Organization Matching Template Structure:**

*   **Partially Matches, Room for Improvement:** The CSS structure *attempts* to match the template structure, but there's room for improvement to make it more aligned and maintainable:
    *   `layout.css`:  Generally aligns with layout templates (`_layouts/*`).
    *   `components.css`: Aims to align with reusable includes and components (`_includes/*`).
    *   `templates.css`:  Intended to be template-specific, but currently overlaps with layout and component styles.
    *   `wiki.css`, `wiki-components.css`: Wiki-specific styles are somewhat modularized, but the separation could be clearer.
    *   `treasury-v2.css`: Treasury-specific styles are in a separate file, which is good, but could be further broken down into component-specific files if needed.

*   **Recommendations for Better Organization:**
    *   **Strict Component-Based CSS:**  For every reusable component in `_includes/`, consider creating a corresponding CSS file in `assets/css/components/` (e.g., `_includes/wiki_search.html` could have `assets/css/components/wiki-search.css`). Import these component-specific CSS files into `main.css` or the relevant layout files (like `wiki.css` or `treasury-v2.css`).
    *   **Layout-Specific CSS Files:**  For each main layout in `_layouts/`, consider having a corresponding CSS file (e.g., `_layouts/wiki.html` could have `assets/css/wiki.css`). This file would primarily handle the layout of that specific page type and import component CSS files as needed.
    *   **Clearer `templates.css` Role:**  If `templates.css` is kept, clearly define its purpose (e.g., only for very high-level, site-wide template styling that doesn't fit in layout or components). However, it might be cleaner to distribute its current styles to `layout.css` and `base.css` and potentially remove `templates.css` altogether.

**4. Unused CSS Classes or Missing Styles:**

*   **Unused CSS Classes:**  It's likely there are unused CSS classes, especially with ongoing development and refactoring. Tools like PurgeCSS (in a production build process) can help identify and remove unused CSS, but a manual review is also beneficial. **Action:** Implement PurgeCSS or a similar tool in your build process to automatically remove unused CSS. Also, periodically manually review CSS files to identify and remove unused classes.

*   **Missing Styles:**
    *   It's difficult to definitively say if there are "missing" styles without a full visual audit of the website against design specifications. However, during development, you might encounter elements that are unstyled or inconsistently styled.
    *   **Action:**  As you work on the website, pay attention to elements that appear unstyled or inconsistently styled. Create or update CSS rules in the appropriate CSS files to address these missing styles. Use browser developer tools to inspect elements and identify which styles are being applied (or not applied).

**Summary of Actions:**

1.  **Refactor `templates.css`:** Move core layout and generic typography styles to `layout.css` and `base.css` respectively. Reserve `templates.css` for truly template-specific styles or consider removing it.
2.  **Consolidate Component Styles:** Move component styles (like `.card`, `.grid`, `.button`, navigation elements, search inputs, list items) to `components.css`.
3.  **Centralize Media Queries:** Define breakpoints as CSS variables in `:root` in `base.css` and reuse them across all CSS files. Consider using Sass mixins for media queries.
4.  **Eliminate Inline Styles:** Move all `<style>` tags from HTML templates and JavaScript files to external CSS files.
5.  **Implement Stylelint:** Integrate Stylelint into your build process.
6.  **Review and Remove Unused CSS:** Implement PurgeCSS and perform manual CSS reviews for unused classes.
7.  **Component-Based CSS Files:** Create component-specific CSS files in `assets/css/components/` for reusable includes.
8.  **Layout-Specific CSS Files:** Consider layout-specific CSS files (e.g., `assets/css/wiki.css`, `assets/css/treasury.css`).
9.  **Thorough Visual Testing:** Regularly test the website visually to identify and address any inconsistencies or missing styles.

By taking these steps, you can create a more modular, maintainable, and consistent CSS structure that aligns well with your Jekyll template organization. This will make future development and styling updates significantly easier.
</file>

<file path="docs/templates-css-status.md">
Packing repository using repomix...
Querying Gemini AI using gemini-2.0-flash-thinking-exp-01-21...
```tool_code
cursor-tools repo "cat assets/css/templates.css"
```
</file>

<file path="wiki/index.html">
---
layout: default
title: Wiki
description: Explore the concepts, primitives, and mechanics that power the Common Ground ecosystem
image: /assets/images/wiki-social-card.png  # We can create a specific image for the wiki
---
<div class="wiki-container">
    {% include wiki_sidebar.html %}
    <div class="wiki-content">
        <header class="wiki-header">
            <h1 class="wiki-title">Common Ground Wiki</h1>
            <p class="wiki-summary">Explore the concepts, primitives, and mechanics that power the Common Ground ecosystem.</p>
        </header>
        <div class="wiki-sections">
            <section class="wiki-section">
                <h2>Core Concepts</h2>
                <div class="wiki-grid">
                    {% assign concept_pages = site.wiki | where_exp:"item","item.category == 'concepts'" | where_exp:"item","item.title != 'Index'" | sort: "weight" %}
                    {% for page in concept_pages limit: 6 %}
                    <a href="{{ page.url }}" class="wiki-card">
                        <h3>{{ page.title }}</h3>
                        <p>{{ page.summary }}</p>
                    </a>
                    {% endfor %}
                </div>
            </section>
            <section class="wiki-section">
                <h2>Technical Primitives</h2>
                <div class="wiki-grid">
                    {% assign primitive_pages = site.wiki | where_exp:"item","item.category == 'primitives'" | where_exp:"item","item.title != 'Index'" | sort: "weight" %}
                    {% for page in primitive_pages limit: 6 %}
                    <a href="{{ page.url }}" class="wiki-card">
                        <h3>{{ page.title }}</h3>
                        <p>{{ page.summary }}</p>
                    </a>
                    {% endfor %}
                </div>
            </section>
            <section class="wiki-section">
                <h2>System Mechanics</h2>
                <div class="wiki-grid">
                    {% assign mechanic_pages = site.wiki | where_exp:"item","item.category == 'mechanics'" | where_exp:"item","item.title != 'Index'" | sort: "weight" %}
                    {% for page in mechanic_pages limit: 6 %}
                    <a href="{{ page.url }}" class="wiki-card">
                        <h3>{{ page.title }}</h3>
                        <p>{{ page.summary }}</p>
                    </a>
                    {% endfor %}
                </div>
            </section>
            <section class="wiki-section">
                <h2>Glossary</h2>
                <div class="wiki-grid">
                    {% assign glossary_pages = site.wiki | where_exp:"item","item.category == 'glossary'" | where_exp:"item","item.title != 'Index'" | sort: "title" %}
                    {% for page in glossary_pages limit: 6 %}
                    <a href="{{ page.url }}" class="wiki-card">
                        <h3>{{ page.title }}</h3>
                        <p>{{ page.summary }}</p>
                    </a>
                    {% endfor %}
                </div>
            </section>
        </div>
    </div>
</div>
<style>
.wiki-container {
    display: grid;
    grid-template-columns: 250px 1fr;
    gap: 2rem;
    padding: 2rem;
}
/* Additional styles specific to the wiki index */
.wiki-sections {
    display: flex;
    flex-direction: column;
    gap: 4rem;
}
.wiki-section h2 {
    font-size: var(--font-size-xl);
    color: var(--text-color);
    margin-bottom: 2rem;
}
.wiki-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
}
.wiki-card {
    background: var(--light-gray);
    border-radius: 1rem;
    padding: 2rem;
    text-decoration: none;
    color: inherit;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    gap: 1rem;
}
.wiki-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
}
.wiki-card h3 {
    font-size: var(--font-size-lg);
    color: var(--text-color);
    margin: 0;
}
.wiki-card p {
    color: var(--text-secondary);
    margin: 0;
    flex-grow: 1;
}
</style>
</file>

<file path="_config.development.yml">
# Development-specific settings
url: "http://localhost:4000"
# Disable some production optimizations for faster builds
profile: true
livereload: true
</file>

<file path="_config.yml">
title: "Common Ground DAO"
description: "Connecting web3 communities through decentralized communication"
url: "https://common-ground-dao.github.io"
baseurl: ""
# Social and SEO settings
tagline: Building the coordination layer for web3 communities
logo: /assets/images/social-card.png  # Path to your default social image
social:
  name: Common Ground
  links:
    - https://twitter.com/CommonGround_cg
    - https://github.com/Common-Ground-DAO
twitter:
  username: CommonGround_cg
  card: summary_large_image
# Domain Aliases (for SEO)
domain_aliases:
  - "https://common-ground-dao.github.io"
# Build settings
markdown: kramdown
kramdown:
  header_offset: 1  # This shifts all markdown headings down one level
permalink: pretty
theme: null  # Explicitly disable theme
remote_theme: null  # Explicitly disable remote theme
plugins:
  - jekyll-feed
  - jekyll-seo-tag
  - jekyll-wiki
# Collections
collections:
  pages:
    output: true
    permalink: /:path/
  stakeholders:
    output: true
    permalink: /stakeholders/:name/
  wiki:
    output: true
    permalink: /wiki/:path/
# Default layouts - unified defaults array
defaults:
  - scope:
      path: ""
      type: "stakeholders"
    values:
      layout: stakeholder
  - scope:
      path: ""
      collection: "wiki"
    values:
      layout: wiki
  - scope:
      path: "assets/js"
    values:
      layout: null
      content_type: application/javascript
  - scope:
      path: ""
    values:
      image: /assets/images/social-card.png  # Default social image for all pages
# Social links
email: ola@dao.cg
github_username: Common-Ground-DAO
# Exclude files from processing
exclude:
  - Gemfile
  - Gemfile.lock
  - node_modules
  - vendor
  - .git/
  - README.md
  - _config.development.yml
  - CNAME
  - .cursorrules
  - "*.log"
  - import/  # Exclude the import directory
  - import/**/*  # Exclude all contents of the import directory
# Environment-specific settings
production: true
compress_html: true  # Enable HTML compression in production
sass:
  style: compressed  # Compress CSS in production
# Add .js files to the list of files Jekyll will copy
include:
  - assets/js/*.js
wiki:
  index: true
  index_layout: wiki
  home: "Home"
  baseurl: "/wiki"
</file>

<file path=".gitignore">
# Jekyll build output
_site
.sass-cache
.jekyll-cache
.jekyll-metadata
vendor
import
node_modules

# Ruby dependencies
.bundle
vendor/bundle

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# IDE specific files
.idea
.vscode
*.swp
*.swo 

.env
</file>

<file path="CNAME">
dao.cg
</file>

<file path="Gemfile">
source "https://rubygems.org"

gem "github-pages", group: :jekyll_plugins
gem "webrick", "~> 1.8"
gem "faraday-retry"

group :jekyll_plugins do
  gem "jekyll-feed", "~> 0.12"
  gem "jekyll-seo-tag", "~> 2.8"
end

# Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem
platforms :mingw, :x64_mingw, :mswin, :jruby do
  gem "tzinfo", ">= 1", "< 3"
  gem "tzinfo-data"
end

# Performance-booster for watching directories on Windows
gem "wdm", "~> 0.1.1", :platforms => [:mingw, :x64_mingw, :mswin]
gem "http_parser.rb", "~> 0.6.0", :platforms => [:jruby]
</file>

<file path="index.md">
---
layout: home
title: Meet the Common Ground DAO
summary: Building the coordination layer for web3 communities through decentralized communication tools.
---

# Hello Human 👋

![Common Ground Product Suite](/assets/images/common-ground-product-suite.png)

Common Ground is a web3-native messaging and voice chat platform that brings together the best of Discord, Telegram, and web3 into one seamless experience. [Learn more...](https://commonground.cg){:target="_blank"}

<header class="page-header">
    <h1 class="page-title">Meet the Common Ground DAO</h1>
</header>

<div class="hero full-screen">
    <div class="hero-content">
        <p class="hero-subtitle">Accelerating the web's transition to  user ownership.</p>
        
        <div class="hero-features">
            <div class="feature-grid">
                <div class="feature-card identity">
                    <div class="feature-icon">🆔</div>
                    <h3>Identity</h3>
                    <p>Unified web3 presence</p>
                </div>
                <div class="feature-card governance">
                    <div class="feature-icon">⚡️</div>
                    <h3>Governance</h3>
                    <p>Dual-token democracy</p>
                </div>
                <div class="feature-card value">
                    <div class="feature-icon">💫</div>
                    <h3>Value Exchange</h3>
                    <p>Seamless coordination</p>
                </div>
                <div class="feature-card community">
                    <div class="feature-icon">🌐</div>
                    <h3>Community</h3>
                    <p>Hyperstructured networks</p>
                </div>
            </div>
        </div>

        <div class="hero-cta">
            <a href="https://app.cg/c/commonground/" class="button primary">Join the Movement</a>
            <a href="/about" class="button secondary">Learn More</a>
        </div>
    </div>
</div>

<div class="stats-banner">
    <div class="stat">
        <h3>65,000+</h3>
        <p>Community Members</p>
    </div>
    <div class="stat">
        <h3>Multichain</h3>
        <p>Across 16+ Ecosystems</p>
    </div>
    <div class="stat">
        <h3>Cooperative</h3>
        <p>Ownership & Governance</p>
    </div>
</div>

<div class="vision-section">
    <div class="container">
        <div class="section-header">
            <h2>Community Hyperstructures</h2>
            <p class="section-subtitle">Building the antifragile network of web3 communities</p>
        </div>

        <div class="vision-grid">
            <div class="vision-card">
                <div class="vision-icon">🔄</div>
                <h3>Multichain Orchestration</h3>
                <p>Connect and embed atomic primitives like identity, roles, and governance into higher-level objects.</p>
            </div>

            <div class="vision-card">
                <div class="vision-icon">🛡️</div>
                <h3>Defensive Acceleration</h3>
                <p>Build systems inherently resistant to coercion, monopolization, or exploitation.</p>
            </div>

            <div class="vision-card">
                <div class="vision-icon">🌱</div>
                <h3>Sustainable Growth</h3>
                <p>Create value through cooperative ownership and community-driven development.</p>
            </div>
        </div>

        <div class="vision-feature">
            <div class="vision-content">
                <h3>The Meta Protocol</h3>
                <p>Common Ground connects web3 primitives into a coherent whole, allowing anyone to harness the superpowers of credibly neutral, sovereign, and resilient coordination infrastructure.</p>
            </div>
            <div class="vision-image">
                <!-- Placeholder for an illustration or diagram -->
                <div class="network-visualization"></div>
            </div>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ '/assets/js/network-viz.js' | relative_url }}"></script>

---

*Common Ground DAO - Connecting web3 communities through decentralized communication*
</file>

<file path="package.json">
{
  "name": "common-ground-dao.github.io",
  "version": "1.0.0",
  "description": "This repository contains the source code for the Common Ground DAO website, built with Jekyll and hosted on GitHub Pages.",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "build:vendor": "rollup -c",
    "watch:vendor": "rollup -c -w"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@rollup/plugin-commonjs": "^25.0.7",
    "@rollup/plugin-node-resolve": "^15.2.3",
    "chart.js": "^4.4.1",
    "fuse.js": "^7.0.0",
    "rollup": "^4.9.5"
  },
  "dependencies": {
    "chartjs-chart-treemap": "^3.1.0"
  }
}
</file>

<file path="README.md">
# Common Ground DAO Website

This repository contains the source code for the Common Ground DAO website, built with Jekyll and hosted on GitHub Pages.

## Local Development

### Prerequisites

- Ruby version 2.7.0 or higher
- RubyGems
- GCC and Make

### Setup

1. Install Jekyll and Bundler:
```bash
gem install jekyll bundler
```

2. Clone the repository:
```bash
git clone https://github.com/Common-Ground-DAO/Common-Ground-DAO.github.io.git
cd Common-Ground-DAO.github.io
```

3. Install dependencies:
```bash
bundle install
```

4. Start the local server:
```bash
bundle exec jekyll serve
```

The site will be available at `http://localhost:4000`

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is open source and available under the MIT License.

## Contact

- Email: ola@dao.cg
- Twitter: [@CommonGround_cg](https://twitter.com/CommonGround_cg)
- GitHub: [@Common-Ground-DAO](https://github.com/Common-Ground-DAO)
</file>

<file path="rollup.config.js">
import { nodeResolve } from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
export default {
    input: 'assets/js/vendor-entry.js',
    output: {
        file: 'assets/js/vendor.bundle.js',
        format: 'iife',
        sourcemap: true
    },
    plugins: [
        nodeResolve(),
        commonjs()
    ]
};
</file>

<file path="search-index.json">
[
  {
    "title": "Community Hyperstructures",
    "url": "/wiki/concepts/community-hyperstructures/",
    "category": "concepts",
    "summary": "Antifragile networks of web3 communities built on composable primitives and credibly neutral coordination infrastructure.",
    "content": "# Community Hyperstructures Community hyperstructures represent a new paradigm in web3 community organization and coordination. They are antifragile networks built on composable primitives that enable credibly neutral, sovereign, and resilient coordination infrastructure. ## Core Principles 1. **Composability** - Atomic primitives (identity, roles, governance) - Higher-level objects - Cross-chain interoperability - Modular design 2. **Antifragility** - Resistance to coercion - Protection against monopolization - Exploitation prevention - Adaptive growth 3. **Credible Neutrality** - Fair participation rules - Transparent governance - Equal access rights - Unbiased mechanisms ## Implementation Community hyperstructures are implemented through several key components: ### 1. Base Layer - Identity systems - Role management - Permission frameworks - Value exchange protocols ### 2. Coordination Layer - Governance mechanisms - Decision frameworks - Resource allocation - Conflict resolution ### 3. Application Layer - Community interfaces - Interaction tools - Analytics dashboards - Integration APIs ## Benefits 1. **Enhanced Coordination** - Efficient decision-making - Reduced friction - Clear accountability - Improved transparency 2. **Sustainable Growth** - Community-driven development - Cooperative ownership - Value alignment - Long-term viability 3. **Network Effects** - Cross-community collaboration - Resource sharing - Knowledge exchange - Collective intelligence ## Challenges 1. **Technical Complexity** - Integration difficulties - Performance optimization - Security considerations - Scalability issues 2. **Social Coordination** - Governance alignment - Incentive design - Cultural differences - Trust building 3. **Resource Management** - Token economics - Value distribution - Resource allocation - Sustainability ## Future Directions The evolution of community hyperstructures will likely focus on: 1. **Enhanced Automation** - AI integration - Smart contracts - Autonomous processes - Predictive analytics 2. **Improved Interoperability** - Cross-chain bridges - Protocol standards - Data portability - Universal interfaces 3. **Advanced Governance** - Fluid democracy - Reputation systems - Dynamic incentives - Adaptive mechanisms",
    "difficulty": "intermediate",
    "tags": [
      "infrastructure",
      "coordination",
      "web3",
      "community"
    ],
    "weight": 1
  },
  {
    "title": "Community Sovereignty",
    "url": "/wiki/concepts/community-sovereignty/",
    "category": "concepts",
    "summary": "The principle and practice of communities maintaining independence and self-governance while participating in broader web3 ecosystems and networks.",
    "content": "# Community Sovereignty Community sovereignty represents the ability of web3 communities to maintain autonomy and self-governance while participating in broader ecosystem networks and value creation systems. ## Core Principles 1. **Autonomous Governance** - Self-determination - Independent decision-making - Resource control - Value autonomy - Cultural independence 2. **Interconnected Systems** - Network participation - Resource sharing - Value exchange - Protocol integration - Cultural exchange 3. **Sovereign Identity** - Community brand - Shared values - Cultural norms - Collective purpose - Unique contribution ## Implementation Mechanisms Community sovereignty is maintained through: ### 1. Governance Systems - Decision frameworks - Voting mechanisms - Role structures - Resource allocation - Conflict resolution ### 2. Economic Independence - Treasury management - Value creation - Resource control - Financial autonomy - Sustainable funding ### 3. Cultural Practices - Identity formation - Value systems - Community rituals - Knowledge management - Social norms ## Benefits 1. **Community Empowerment** - Self-determination - Resource control - Value creation - Cultural autonomy 2. **Network Effects** - Ecosystem participation - Resource sharing - Value exchange - Knowledge transfer 3. **Sustainable Growth** - Independent development - Value retention - Cultural preservation - Long-term viability ## Challenges 1. **Balance Management** - Autonomy vs. integration - Resource allocation - Value alignment - Network participation 2. **Governance Complexity** - Decision-making - Role management - Resource control - Conflict resolution 3. **Ecosystem Integration** - Protocol alignment - Value exchange - Cultural preservation - Identity maintenance ## Future Directions The evolution of community sovereignty will focus on: 1. **Advanced Governance** - Dynamic systems - Adaptive mechanisms - AI integration - Cultural preservation 2. **Enhanced Coordination** - Cross-community collaboration - Resource optimization - Value creation - Knowledge sharing 3. **Sovereign Innovation** - Custom models - Cultural experiments - Value systems - Growth patterns",
    "difficulty": "intermediate",
    "tags": [
      "social",
      "governance",
      "autonomy",
      "community"
    ],
    "weight": 4
  },
  {
    "title": "Composite Primitives",
    "url": "/wiki/concepts/composite-primitives/",
    "category": "concepts",
    "summary": "Higher-level web3 building blocks composed of multiple atomic primitives, enabling complex community interactions and governance structures.",
    "content": "# Composite Primitives Composite primitives are sophisticated web3 building blocks that combine multiple atomic primitives into cohesive, higher-level objects. They enable complex community interactions and governance structures while maintaining simplicity in their interface. ## Core Characteristics 1. **Composition** - Atomic primitive integration - Standardized interfaces - Modular design - Extensible architecture 2. **Interoperability** - Cross-chain compatibility - Protocol alignment - State synchronization - Resource sharing 3. **Functionality** - Enhanced capabilities - Complex operations - Automated workflows - Advanced features ## Implementation Examples Common Ground implements several key composite primitives: ### 1. Passport - Passkey authentication - Smart wallet integration - Identity verification - Trust markers ### 2. Onchain Community - Community wallet - Role management - Governance mechanisms - Resource allocation ### 3. Community Token - Token standards - Distribution mechanisms - Utility design - Value capture ## Benefits 1. **Enhanced Functionality** - Complex operations - Advanced features - Automated workflows - Integrated systems 2. **Simplified Usage** - User-friendly interfaces - Abstracted complexity - Consistent experience - Reduced friction 3. **Ecosystem Integration** - Cross-protocol compatibility - Resource optimization - Value alignment - Network effects ## Challenges 1. **Technical Integration** - Component coordination - State management - Error handling - Performance optimization 2. **Security Considerations** - Attack surface - Vulnerability assessment - Risk mitigation - Privacy protection 3. **User Experience** - Complexity management - Learning curve - Interface design - Feature discovery ## Future Directions The evolution of composite primitives will focus on: 1. **Advanced Composition** - Dynamic assembly - Adaptive primitives - Smart optimization - Context awareness 2. **Enhanced Integration** - Cross-chain primitives - Protocol standards - Resource sharing - Value creation 3. **User Empowerment** - Custom composition - Template creation - Community extensions - Innovation enablement",
    "difficulty": "intermediate",
    "tags": [
      "infrastructure",
      "primitives",
      "web3",
      "composition"
    ],
    "weight": 2
  },
  {
    "title": "Convergence",
    "url": "/wiki/concepts/convergence/",
    "category": "concepts",
    "summary": "The trend of apps aggregating end users and commoditizing blockspace, enabled by the maturation of web3 primitives.",
    "content": "# Convergence Convergence describes the natural evolution of web3 applications towards user aggregation and blockspace commoditization, made possible by the maturation of essential primitives and infrastructure. ## Key Enablers 1. **Zero-Friction Onboarding** - Passkeys & biometric hardware - RIP7212 and optimized signing - Onchain account standards - Gas-relayer infrastructure - One-click fiat onramps 2. **Smart Contract Standards** - Multisig wallets (SAFE) - Onchain roles - Governance primitives - Voting mechanisms - Quadratic voting 3. **Infrastructure Maturity** - Affordable blockspace - Broad VM support - Global stablecoin adoption - DEX liquidity - DeFi lending markets ## Ecosystem Components 1. **Identity & Trust** - Proof of personhood - Decentralized verification - Social graph integration - Reputation systems 2. **Community Coordination** - Onchain culture - Coinship alignment - Cross-chain communication - Resource sharing 3. **Technical Integration** - PWA support - Native notifications - Mobile optimization - Cross-platform compatibility ## Impact The convergence of these elements enables: 1. **User Adoption** - Simplified onboarding - Intuitive interfaces - Seamless experiences - Reduced friction 2. **Community Growth** - Enhanced coordination - Resource optimization - Value alignment - Collective action 3. **Ecosystem Development** - Protocol standardization - Infrastructure maturation - Market efficiency - Innovation acceleration",
    "difficulty": "intermediate",
    "tags": [
      "adoption",
      "infrastructure",
      "scaling"
    ],
    "weight": 3
  },
  {
    "title": "Coordination",
    "url": "/wiki/concepts/coordination/",
    "category": "concepts",
    "summary": "The fundamental challenge and opportunity of aligning diverse communities to achieve shared objectives through decentralized mechanisms.",
    "content": "# Coordination Coordination represents the fundamental challenge and opportunity in web3: how to align diverse communities and stakeholders to achieve shared objectives through decentralized mechanisms. ## Core Aspects 1. **Alignment Mechanisms** - Value alignment - Goal setting - Resource allocation - Decision making 2. **Community Dynamics** - Cross-community interaction - Stakeholder engagement - Collective action - Trust building 3. **Infrastructure Requirements** - Communication channels - Governance frameworks - Resource management - Impact measurement ## Implementation 1. **Technical Layer** - Smart contracts - Voting systems - Token mechanisms - Data structures 2. **Social Layer** - Community norms - Cultural alignment - Trust networks - Reputation systems 3. **Economic Layer** - Value distribution - Resource allocation - Incentive design - Market mechanisms ## Challenges 1. **Scale** - Network effects - Communication overhead - Decision complexity - Resource distribution 2. **Alignment** - Diverse interests - Goal conflicts - Value differences - Priority setting 3. **Implementation** - Technical barriers - Social friction - Economic constraints - Governance complexity ## Solutions 1. **Technical Tools** - Discourse graphs - Smart contracts - Token systems - Governance frameworks 2. **Social Mechanisms** - Trust networks - Reputation systems - Cultural norms - Community standards 3. **Economic Incentives** - Value sharing - Resource pooling - Reward systems - Market alignment",
    "difficulty": "intermediate",
    "tags": [
      "coordination",
      "community",
      "governance",
      "alignment"
    ],
    "weight": 2
  },
  {
    "title": "Cross-Chain Interoperability",
    "url": "/wiki/concepts/cross-chain-interoperability/",
    "category": "concepts",
    "summary": "The ability for different blockchain networks to communicate, share state, and transfer value seamlessly through standardized protocols and bridges.",
    "content": "# Cross-Chain Interoperability Cross-Chain Interoperability represents the technical capability for different blockchain networks to communicate, share state, and transfer value seamlessly through standardized protocols and bridge mechanisms. ## Core Components 1. **Protocol Standards** - Message formats - State proofs - Bridge protocols - Security mechanisms 2. **Bridge Infrastructure** - Value transfer - State synchronization - Message passing - Security validation 3. **Integration Layer** - Protocol adapters - State management - Event handling - Error recovery ## Implementation 1. **Technical Layer** - Bridge contracts - Protocol interfaces - Security systems - State management 2. **Security Layer** - Validation mechanisms - Proof systems - Attack prevention - Risk mitigation 3. **Application Layer** - User interfaces - Integration APIs - Developer tools - Monitoring systems ## Applications 1. **Value Transfer** - Asset bridging - Token wrapping - State transfer - Message passing 2. **Protocol Integration** - Cross-chain governance - Resource sharing - State synchronization - Action coordination 3. **Ecosystem Development** - Network effects - Resource optimization - Market expansion - Innovation enablement ## Benefits 1. **Enhanced Functionality** - Unified experience - Resource sharing - Value transfer - Service integration 2. **Ecosystem Growth** - Network effects - Market expansion - Innovation potential - Resource optimization 3. **User Experience** - Seamless interaction - Reduced friction - Feature access - Value portability ## Challenges 1. **Technical Complexity** - Protocol differences - Security risks - Performance overhead - Scale requirements 2. **Integration Issues** - Standard adoption - Version management - Compatibility - Error handling 3. **Resource Management** - Network costs - Infrastructure needs - Maintenance overhead - Security requirements ## Future Directions The evolution of cross-chain interoperability will focus on: 1. **Advanced Protocols** - Zero-knowledge proofs - Quantum resistance - Dynamic routing - Smart optimization 2. **Enhanced Integration** - Universal standards - Automated bridges - AI coordination - Security innovations 3. **Ecosystem Development** - Protocol discovery - Value networks - Resource sharing - Innovation platforms",
    "difficulty": "advanced",
    "tags": [
      "infrastructure",
      "blockchain",
      "protocols",
      "technical"
    ],
    "weight": 7
  },
  {
    "title": "Ecosystem Economics",
    "url": "/wiki/concepts/ecosystem-economics/",
    "category": "concepts",
    "summary": "The economic frameworks and mechanisms that govern value creation, capture, and distribution across blockchain ecosystems and their communities.",
    "content": "# Ecosystem Economics Ecosystem economics encompasses the economic systems, incentives, and mechanisms that enable sustainable value creation and distribution across blockchain networks and their constituent communities. ## Core Components 1. **Infrastructure Economics** - Blockspace pricing - Gas mechanisms - Sequencer fees - Network costs - Resource allocation 2. **Community Economics** - Grant programs - Development funds - Community treasuries - Incentive systems - Value distribution 3. **Market Dynamics** - Token economics - Liquidity mechanisms - Price discovery - Market making - Trading infrastructure ## Implementation Mechanisms The ecosystem economic framework operates through: ### 1. Value Creation - Infrastructure development - Protocol innovation - Community building - Market making - Public goods ### 2. Value Capture - Transaction fees - Protocol revenue - Treasury management - Token appreciation - Service fees ### 3. Value Distribution - Community rewards - Development funding - Infrastructure grants - Public goods funding - Ecosystem growth ## Benefits 1. **Sustainable Growth** - Resource efficiency - Value retention - Market stability - Long-term viability 2. **Community Development** - Aligned incentives - Resource access - Innovation funding - Collective benefit 3. **Network Effects** - User adoption - Protocol integration - Market depth - Ecosystem expansion ## Challenges 1. **Economic Balance** - Resource allocation - Incentive design - Market stability - Value distribution 2. **Technical Complexity** - System integration - Scale requirements - Performance optimization - Security concerns 3. **Market Dynamics** - Competition - Value volatility - Liquidity management - User adoption ## Future Directions The evolution of ecosystem economics will focus on: 1. **Advanced Systems** - Dynamic pricing - Adaptive mechanisms - AI optimization - Resource efficiency 2. **Enhanced Integration** - Cross-ecosystem coordination - Protocol interoperability - Market efficiency - Value flows 3. **Community Innovation** - Custom models - Experimental designs - Impact measurement - Value creation",
    "difficulty": "advanced",
    "tags": [
      "economics",
      "ecosystem",
      "tokenomics",
      "infrastructure"
    ],
    "weight": 3
  },
  {
    "title": "Game of Chains",
    "url": "/wiki/concepts/game-of-chains/",
    "category": "concepts",
    "summary": "A game-theoretic framework describing how communities compete and cooperate across different blockchain ecosystems to maximize value and impact.",
    "content": "# Game of Chains Game of Chains represents a theoretical framework that describes the complex dynamics of competition and cooperation between communities across different blockchain ecosystems. ## Core Dynamics 1. **Competition** - Resource allocation - Market positioning - Value capture - User acquisition 2. **Cooperation** - Resource sharing - Value creation - Network effects - Protocol alignment 3. **Strategy** - Ecosystem selection - Resource deployment - Alliance formation - Value optimization ## Implementation 1. **Economic Layer** - Value flows - Token mechanics - Market dynamics - Resource allocation 2. **Social Layer** - Community alignment - Network building - Trust formation - Reputation systems 3. **Technical Layer** - Protocol integration - Cross-chain bridges - State management - Resource optimization ## Applications 1. **Ecosystem Growth** - Community building - Value creation - Network expansion - Resource optimization 2. **Value Creation** - Market development - Protocol integration - Resource allocation - Impact maximization 3. **Strategic Planning** - Ecosystem selection - Resource deployment - Partnership formation - Growth optimization",
    "difficulty": "advanced",
    "tags": [
      "game-theory",
      "economics",
      "blockchain",
      "strategy"
    ],
    "weight": 4
  },
  {
    "title": "Identity and Authentication",
    "url": "/wiki/concepts/identity-authentication/",
    "category": "concepts",
    "summary": "The technical foundations and mechanisms for establishing, verifying, and managing digital identity and authentication in web3 communities.",
    "content": "# Identity and Authentication Identity and authentication in web3 encompass the technical systems and standards that enable secure, portable, and user-controlled digital identity management across blockchain networks and communities. ## Core Components 1. **Identity Systems** - Decentralized identifiers - Verifiable credentials - Identity aggregation - Profile management - Recovery mechanisms 2. **Authentication Methods** - Passkey standards - Biometric verification - Multi-factor auth - Social recovery - Hardware security 3. **Privacy Controls** - Data minimization - Selective disclosure - Zero-knowledge proofs - Encryption standards - Access control ## Implementation Mechanisms Identity and authentication are implemented through: ### 1. Technical Standards - DID protocols - Credential formats - Authentication flows - Security protocols - Privacy frameworks ### 2. User Systems - Wallet integration - Profile management - Recovery options - Permission controls - Identity portability ### 3. Security Layers - Cryptographic proofs - Access management - Threat prevention - Audit systems - Recovery protocols ## Benefits 1. **Enhanced Security** - Sovereign identity - Attack resistance - Privacy protection - Data control 2. **User Experience** - Seamless authentication - Identity portability - Profile management - Recovery options 3. **System Integration** - Standard compliance - Protocol compatibility - Service integration - Value preservation ## Challenges 1. **Technical Complexity** - Standard adoption - Integration issues - Performance needs - Security balance 2. **User Management** - Recovery processes - Privacy controls - Feature discovery - Mental models 3. **System Evolution** - Protocol updates - Standard changes - Security threats - Privacy requirements ## Future Directions The evolution of identity and authentication will focus on: 1. **Advanced Systems** - Quantum-safe crypto - AI integration - Dynamic security - Context awareness 2. **Enhanced Privacy** - Zero-knowledge systems - Privacy computation - Data sovereignty - Access control 3. **User Innovation** - Custom identities - Social systems - Recovery networks - Trust frameworks",
    "difficulty": "intermediate",
    "tags": [
      "technical",
      "identity",
      "security",
      "authentication"
    ],
    "weight": 5
  },
  {
    "title": "Meta Protocol",
    "url": "/wiki/concepts/meta-protocol/",
    "category": "concepts",
    "summary": "A protocol layer that orchestrates and aligns multiple underlying protocols and primitives to enable complex community interactions.",
    "content": "# Meta Protocol A Meta Protocol represents an orchestration layer that aligns and coordinates multiple underlying protocols and primitives to enable sophisticated community interactions and governance structures. ## Core Functions 1. **Protocol Orchestration** - Primitive alignment - State coordination - Interface standardization - Resource optimization 2. **Community Integration** - Interaction facilitation - Governance enablement - Value exchange - Resource sharing 3. **System Architecture** - Protocol bridges - State management - Security guarantees - Scalability design ## Implementation 1. **Technical Layer** - Protocol interfaces - State synchronization - Security mechanisms - Performance optimization 2. **Integration Layer** - Community systems - Governance frameworks - Value networks - Resource management 3. **Coordination Layer** - Cross-protocol communication - State alignment - Resource allocation - Value transfer ## Applications 1. **Community Operations** - Governance coordination - Resource management - Value exchange - State synchronization 2. **Protocol Integration** - System alignment - Resource optimization - State management - Security enhancement 3. **Value Networks** - Exchange facilitation - Resource allocation - Market creation - Network effects",
    "difficulty": "advanced",
    "tags": [
      "infrastructure",
      "protocols",
      "web3",
      "coordination"
    ],
    "weight": 3
  },
  {
    "title": "Onchain Culture",
    "url": "/wiki/concepts/onchain-culture/",
    "category": "concepts",
    "summary": "The emergent social norms, values, and practices that develop within web3 communities through their interactions with blockchain systems and protocols.",
    "content": "# Onchain Culture Onchain Culture represents the unique social fabric that emerges when communities interact through blockchain systems, combining traditional social dynamics with cryptographic primitives and decentralized governance. ## Core Elements 1. **Community Values** - Decentralization - Transparency - Sovereignty - Collaboration 2. **Social Practices** - Governance participation - Value creation - Resource sharing - Trust building 3. **Cultural Norms** - Decision making - Conflict resolution - Resource allocation - Contribution recognition ## Implementation 1. **Social Layer** - Community formation - Value alignment - Norm development - Cultural evolution 2. **Governance Layer** - Decision processes - Role definition - Power distribution - Accountability systems 3. **Technical Layer** - Protocol interaction - Tool adoption - Resource management - Value exchange ## Applications 1. **Community Building** - Identity formation - Value alignment - Trust development - Cultural growth 2. **Governance Design** - Process creation - Role definition - Power balance - Conflict resolution 3. **Value Creation** - Resource allocation - Contribution rewards - Innovation support - Impact measurement",
    "difficulty": "intermediate",
    "tags": [
      "culture",
      "community",
      "social",
      "governance"
    ],
    "weight": 8
  },
  {
    "title": "Protocol Discovery",
    "url": "/wiki/concepts/protocol-discovery/",
    "category": "concepts",
    "summary": "The process and mechanisms by which communities discover, evaluate, and integrate new protocols and primitives into their operations.",
    "content": "# Protocol Discovery Protocol Discovery encompasses the processes and mechanisms that enable communities to identify, evaluate, and integrate new protocols and primitives into their operational frameworks. ## Core Components 1. **Discovery Mechanisms** - Protocol registries - Integration guides - Evaluation frameworks - Community feedback 2. **Assessment Tools** - Security analysis - Performance metrics - Integration costs - Value potential 3. **Integration Support** - Technical guides - Best practices - Implementation patterns - Support resources ## Implementation 1. **Discovery Layer** - Protocol indexing - Search mechanisms - Filtering systems - Recommendation engines 2. **Evaluation Layer** - Analysis tools - Testing frameworks - Comparison metrics - Risk assessment 3. **Integration Layer** - Implementation guides - Technical support - Resource allocation - Performance monitoring ## Applications 1. **Community Growth** - Capability expansion - Value creation - Innovation support - Resource optimization 2. **Protocol Integration** - Technical assessment - Implementation planning - Resource allocation - Performance tracking 3. **Ecosystem Development** - Protocol adoption - Innovation fostering - Value creation - Network effects",
    "difficulty": "intermediate",
    "tags": [
      "protocols",
      "discovery",
      "integration",
      "innovation"
    ],
    "weight": 9
  },
  {
    "title": "Shared Coordination Resources",
    "url": "/wiki/concepts/shared-coordination-resources/",
    "category": "concepts",
    "summary": "Common infrastructure and tools that enable efficient coordination and value creation across multiple communities and ecosystems.",
    "content": "# Shared Coordination Resources Shared Coordination Resources represent the common infrastructure, tools, and mechanisms that enable efficient coordination and value creation across multiple communities and ecosystems. ## Core Components 1. **Infrastructure** - Communication channels - Governance frameworks - Resource management - Value exchange 2. **Tools** - Coordination platforms - Decision systems - Resource tracking - Impact measurement 3. **Mechanisms** - Value distribution - Resource allocation - Decision making - Impact assessment ## Implementation 1. **Technical Layer** - Protocol standards - Integration APIs - Data structures - Security systems 2. **Social Layer** - Community interfaces - Governance frameworks - Trust networks - Reputation systems 3. **Economic Layer** - Resource pools - Value flows - Market mechanisms - Incentive design ## Applications 1. **Community Coordination** - Resource sharing - Decision alignment - Value creation - Impact optimization 2. **Resource Management** - Asset allocation - Tool sharing - Infrastructure use - Cost optimization 3. **Value Creation** - Network effects - Resource efficiency - Impact scaling - Innovation enablement",
    "difficulty": "intermediate",
    "tags": [
      "infrastructure",
      "coordination",
      "resources",
      "community"
    ],
    "weight": 5
  },
  {
    "title": "Token Distribution Mechanisms",
    "url": "/wiki/concepts/token-distribution-mechanisms/",
    "category": "concepts",
    "summary": "Different approaches to distributing community tokens that shape community formation, member engagement, and long-term value creation.",
    "content": "# Token Distribution Mechanisms Token distribution mechanisms are the methods and strategies used to allocate community tokens to participants. The choice of distribution mechanism significantly impacts community formation, member behavior, and long-term sustainability. ## Core Components 1. **Distribution Methods** - Fair launches - Airdrops - Token sales - Earned distribution - Retroactive rewards 2. **Distribution Parameters** - Token supply - Allocation ratios - Vesting schedules - Lock-up periods - Distribution curves 3. **Community Considerations** - Target audience - Member lifecycle - Engagement metrics - Value alignment - Growth objectives ## Implementation Factors The optimal distribution mechanism depends on several key factors: ### 1. Community Purpose - Mission alignment - Value proposition - Target demographics - Growth strategy ### 2. Token Design - Token standard - Utility functions - Governance rights - Economic model ### 3. Market Context - Ecosystem dynamics - Market conditions - Liquidity requirements - Competitive landscape ## Benefits 1. **Community Formation** - Aligned incentives - Fair participation - Value distribution - Sustainable growth 2. **Member Engagement** - Active participation - Long-term commitment - Value creation - Community ownership 3. **Economic Sustainability** - Resource allocation - Value capture - Market stability - Growth funding ## Challenges 1. **Design Complexity** - Parameter optimization - Incentive alignment - Game theory - Market dynamics 2. **Implementation Risks** - Technical execution - Market manipulation - Regulatory compliance - Community acceptance 3. **Long-term Management** - Supply management - Price stability - Community evolution - Value sustainability ## Future Directions The evolution of distribution mechanisms will focus on: 1. **Advanced Models** - Dynamic distribution - Adaptive mechanisms - AI-driven optimization - Context awareness 2. **Enhanced Fairness** - Sybil resistance - Value attribution - Contribution measurement - Impact assessment 3. **Community Innovation** - Custom mechanisms - Hybrid models - Experimental designs - Cross-community coordination",
    "difficulty": "intermediate",
    "tags": [
      "economics",
      "tokens",
      "distribution",
      "community"
    ],
    "weight": 3
  },
  {
    "title": "Trust Networks",
    "url": "/wiki/concepts/trust-networks/",
    "category": "concepts",
    "summary": "Decentralized systems of reputation and trust that enable secure and efficient coordination among community members and across ecosystems.",
    "content": "# Trust Networks Trust Networks represent decentralized systems of reputation and trust that enable secure and efficient coordination among community members and across ecosystem boundaries. ## Core Components 1. **Trust Mechanisms** - Reputation systems - Verification methods - Trust scoring - Identity validation 2. **Network Structure** - Trust relationships - Network topology - Connection patterns - Growth dynamics 3. **Security Features** - Sybil resistance - Attack prevention - Risk mitigation - Trust preservation ## Implementation 1. **Technical Layer** - Identity systems - Verification protocols - Trust algorithms - Security measures 2. **Social Layer** - Reputation building - Trust formation - Community norms - Social validation 3. **Integration Layer** - Protocol connections - Network bridges - Data sharing - Trust transfer ## Applications 1. **Community Building** - Member verification - Trust establishment - Relationship building - Network growth 2. **Coordination Enhancement** - Secure interaction - Efficient collaboration - Risk reduction - Trust optimization 3. **Ecosystem Development** - Cross-community trust - Network effects - Value creation - Growth facilitation",
    "difficulty": "intermediate",
    "tags": [
      "trust",
      "reputation",
      "coordination",
      "security"
    ],
    "weight": 6
  },
  {
    "title": "Value Capture Models",
    "url": "/wiki/concepts/value-capture-models/",
    "category": "concepts",
    "summary": "Dual approaches to value creation and distribution in web3 communities, balancing short-term value capture (Degen) with long-term value redistribution (Regen).",
    "content": "# Value Capture Models Value capture models in web3 communities represent a spectrum of approaches to creating, capturing, and distributing value. These models typically balance between Degen mechanics (focused on short-term value capture) and Regen mechanics (focused on long-term value redistribution). ## Core Mechanics 1. **Degen Value Capture** - Market making - Yield farming - Trading incentives - Liquidity provision - Short-term rewards 2. **Regen Value Redistribution** - Public goods funding - Impact investing - Community rewards - Sustainable development - Long-term alignment 3. **Hybrid Approaches** - Balanced incentives - Dual token systems - Adaptive mechanisms - Value cycling - Feedback loops ## Implementation Strategies The implementation of value capture models involves: ### 1. Market Mechanisms - Price discovery - Liquidity pools - Trading pairs - Bonding curves - Automated market makers ### 2. Community Incentives - Contribution rewards - Governance rights - Staking benefits - Impact certificates - Reputation systems ### 3. Value Distribution - Revenue sharing - Impact funding - Community treasury - Grant programs - Development funds ## Benefits 1. **Economic Sustainability** - Balanced growth - Sustainable funding - Value retention - Market stability 2. **Community Alignment** - Shared incentives - Long-term thinking - Value creation - Collective benefit 3. **Ecosystem Development** - Innovation funding - Public goods - Infrastructure - Research & Development ## Challenges 1. **Balance Management** - Incentive design - Value stability - Market dynamics - Community needs 2. **Implementation Complexity** - Technical requirements - Market integration - Regulatory compliance - User experience 3. **Sustainability Concerns** - Long-term viability - Market volatility - Community engagement - Value retention ## Future Directions The evolution of value capture models will focus on: 1. **Advanced Mechanisms** - Dynamic balancing - AI-driven optimization - Adaptive systems - Context awareness 2. **Enhanced Integration** - Cross-chain value flows - Ecosystem alignment - Protocol synergies - Market efficiency 3. **Community Innovation** - Custom models - Experimental designs - Impact measurement - Value attribution",
    "difficulty": "intermediate",
    "tags": [
      "economics",
      "value",
      "sustainability",
      "mechanics"
    ],
    "weight": 3
  },
  {
    "title": "Zero-Friction Onboarding",
    "url": "/wiki/concepts/zero-friction-onboarding/",
    "category": "concepts",
    "summary": "A comprehensive approach to removing technical barriers and simplifying the process of joining and participating in web3 communities.",
    "content": "# Zero-Friction Onboarding Zero-friction onboarding represents a comprehensive technical and user experience approach that minimizes barriers to entry for new participants in web3 communities, making blockchain technology accessible to all users regardless of their technical expertise. ## Core Components 1. **Technical Infrastructure** - Passkey integration - Smart contract wallets - Gas abstraction - Transaction relayers - Fiat onramps 2. **User Experience** - One-click signup - Progressive disclosure - Intuitive interfaces - Mobile optimization - Error prevention 3. **Identity Management** - Social authentication - Credential portability - Recovery mechanisms - Privacy controls - Profile management ## Implementation Mechanisms Zero-friction onboarding is achieved through: ### 1. Authentication Systems - Biometric verification - Passkey standards - Social recovery - Multi-device support - Security layers ### 2. Transaction Management - Gas sponsorship - Batched transactions - Meta-transactions - Fee abstraction - Smart wallets ### 3. User Interface - Progressive web apps - Native integration - Push notifications - Offline support - Cross-platform compatibility ## Benefits 1. **Enhanced Accessibility** - Reduced complexity - Broader adoption - Lower barriers - Inclusive design 2. **Improved Security** - Built-in protection - Recovery options - Risk mitigation - User education 3. **Better Retention** - User satisfaction - Quick activation - Value discovery - Community integration ## Challenges 1. **Technical Integration** - System complexity - Standard adoption - Performance optimization - Security balance 2. **User Education** - Mental models - Feature discovery - Security awareness - Value proposition 3. **Resource Management** - Gas costs - Infrastructure scaling - Support requirements - Maintenance needs ## Future Directions The evolution of zero-friction onboarding will focus on: 1. **Advanced Systems** - AI assistance - Predictive onboarding - Context awareness - Smart optimization 2. **Enhanced Integration** - Cross-chain onboarding - Protocol standards - Identity portability - Value preservation 3. **User Innovation** - Custom pathways - Social onboarding - Community tools - Growth patterns",
    "difficulty": "intermediate",
    "tags": [
      "technical",
      "user-experience",
      "onboarding",
      "accessibility"
    ],
    "weight": 5
  },
  {
    "title": "Antifragility",
    "url": "/wiki/glossary/antifragility/",
    "category": "glossary",
    "summary": "The property of systems that not only resist shocks and disruptions but actually improve and grow stronger from them.",
    "content": "# Antifragility Antifragility represents a system property where exposure to shocks, volatility, and disruptions leads to strengthening and improvement rather than degradation or failure. ## Core Characteristics 1. **Adaptation** - Learning from stress - System evolution - Dynamic response - Growth through chaos 2. **Resilience** - Shock absorption - Recovery capacity - Stress tolerance - Failure resistance 3. **Enhancement** - Strength building - Capability growth - System improvement - Evolution acceleration ## Implementation 1. **System Design** - Redundancy - Modularity - Adaptability - Self-repair 2. **Response Mechanisms** - Stress detection - Adaptation triggers - Recovery processes - Growth pathways 3. **Learning Systems** - Pattern recognition - Knowledge capture - Evolution mechanisms - Improvement cycles ## Applications 1. **Protocol Design** - System architecture - Failure handling - Growth mechanisms - Evolution patterns 2. **Community Systems** - Governance adaptation - Resource resilience - Value preservation - Growth through challenge 3. **Ecosystem Development** - Network resilience - Value enhancement - Innovation fostering - Sustainable growth",
    "difficulty": "intermediate",
    "tags": [
      "systems",
      "resilience",
      "adaptation",
      "growth"
    ],
    "weight": 8
  },
  {
    "title": "CG Token",
    "url": "/wiki/glossary/cg-token/",
    "category": "glossary",
    "summary": "The dual-flavored (blue and red) utility token of Common Ground that enables staking rewards, governance participation, and ecosystem cooperation.",
    "content": "# CG Token The CG Token ($CG) is the core utility token of Common Ground, featuring an innovative dual-flavor design that balances speculative and contributive value. ## Core Features 1. **Token Flavors** - Blue: Speculative, tradeable token - Red: Non-transferrable work token - Equal governance rights - Complementary functions 2. **Utility Functions** - Staking rewards - Governance power - Ecosystem cooperation - Value alignment 3. **Distribution Model** - Community fund (51%) - Team allocation (20%) - Investor distribution (7%) - Treasury reserve (22%) ## Implementation 1. **Token Design** - ERC20 standard - Dual contract system - Auto-decay mechanism - Governance integration 2. **Economic Model** - Value capture - Reward distribution - Staking mechanics - Market dynamics 3. **Governance Structure** - Voting rights - Proposal power - Decision making - Community control ## Applications 1. **Platform Governance** - Decision making - Resource allocation - Feature development - Ecosystem direction 2. **Value Creation** - Staking rewards - Contribution incentives - Market participation - Economic alignment 3. **Ecosystem Development** - Community building - Partnership formation - Innovation funding - Growth facilitation",
    "difficulty": "intermediate",
    "tags": [
      "token",
      "governance",
      "staking",
      "ecosystem"
    ],
    "weight": 9
  },
  {
    "title": "Coinship",
    "url": "/wiki/glossary/coinship/",
    "category": "glossary",
    "summary": "A form of community coordination and alignment achieved through shared token ownership and participation in token-based activities.",
    "content": "# Coinship Coinship represents a novel form of social coordination where communities align and organize around shared token ownership and participation in token-based activities. It's a fundamental concept in web3 that combines economic incentives with social coordination. ## Core Concepts 1. **Token-Based Alignment** - Shared ownership - Economic incentives - Value alignment - Community participation 2. **Coordination Mechanisms** - Token distribution - Governance rights - Value capture - Resource allocation 3. **Community Dynamics** - Social cohesion - Shared purpose - Collective action - Group identity ## Implementation 1. **Token Design** - Distribution models - Governance rights - Utility features - Value accrual 2. **Community Structure** - Participation rules - Decision making - Resource sharing - Value distribution 3. **Incentive Alignment** - Reward systems - Contribution tracking - Value recognition - Growth incentives ## Applications 1. **Community Building** - Member attraction - Value alignment - Participation incentives - Growth mechanisms 2. **Governance** - Decision rights - Resource allocation - Value distribution - Strategic direction 3. **Value Creation** - Token appreciation - Resource development - Community growth - Network effects",
    "difficulty": "intermediate",
    "tags": [
      "tokens",
      "coordination",
      "community",
      "alignment"
    ],
    "weight": 2
  },
  {
    "title": "Common Dollar",
    "url": "/wiki/glossary/common-dollar/",
    "category": "glossary",
    "summary": "A USD-referenced stablecoin that wraps yield-bearing stablecoins like sDAI, allowing Common Ground to capture yield for platform sustainability while providing users with stable value storage.",
    "content": "# Common Dollar The Common Dollar is an innovative stablecoin design that combines stable value storage with sustainable platform economics through yield capture mechanisms. ## Core Components 1. **Stablecoin Wrapper** - USD reference peg - Yield-bearing base asset - Seamless conversion - Stable value storage 2. **Yield Mechanism** - sDAI integration - Yield capture - Platform sustainability - Economic efficiency 3. **User Benefits** - Value stability - Easy conversion - Platform support - Economic alignment ## Implementation 1. **Technical Design** - Smart contract architecture - Yield collection - Conversion mechanisms - Security features 2. **Economic Model** - Yield distribution - Platform sustainability - Value flows - Market dynamics 3. **Integration** - Platform features - User interface - Payment systems - Treasury management ## Applications 1. **Platform Economics** - Sustainable funding - Feature development - Community support - Ecosystem growth 2. **User Experience** - Value storage - Payment medium - Platform interaction - Economic participation 3. **Ecosystem Development** - Liquidity provision - Market making - Protocol integration - Partnership enablement",
    "difficulty": "intermediate",
    "tags": [
      "stablecoin",
      "economics",
      "yield",
      "sustainability"
    ],
    "weight": 7
  },
  {
    "title": "Community Sovereignty",
    "url": "/wiki/glossary/community-sovereignty/",
    "category": "glossary",
    "summary": "The principle that communities should have complete control over their resources, governance, and decision-making processes without external dependencies.",
    "content": "# Community Sovereignty Community Sovereignty represents the fundamental principle that web3 communities should maintain complete autonomy and control over their resources, governance processes, and decision-making mechanisms. ## Core Principles 1. **Autonomy** - Independent governance - Resource control - Decision authority - Self-determination 2. **Control Mechanisms** - Resource management - Governance systems - Access controls - Permission structures 3. **Independence** - Technical sovereignty - Economic freedom - Governance autonomy - Cultural identity ## Implementation 1. **Governance Layer** - Decision frameworks - Voting systems - Role management - Access controls 2. **Resource Layer** - Asset control - Treasury management - Resource allocation - Value distribution 3. **Technical Layer** - Infrastructure control - Protocol selection - Tool management - Security systems ## Applications 1. **Community Management** - Resource control - Decision making - Value distribution - Identity preservation 2. **Governance Systems** - Autonomous processes - Independent decisions - Resource allocation - Access management 3. **Value Creation** - Resource utilization - Economic freedom - Innovation potential - Growth autonomy",
    "difficulty": "intermediate",
    "tags": [
      "governance",
      "autonomy",
      "community",
      "sovereignty"
    ],
    "weight": 6
  },
  {
    "title": "Credible Neutrality",
    "url": "/wiki/glossary/credible-neutrality/",
    "category": "glossary",
    "summary": "The principle that protocols and systems should operate with transparent, fair, and manipulation-resistant rules that treat all participants equally.",
    "content": "# Credible Neutrality Credible Neutrality represents a fundamental design principle where protocols and systems operate with transparent, fair, and manipulation-resistant rules that ensure equal treatment of all participants. ## Core Principles 1. **Fairness** - Equal treatment - Transparent rules - Unbiased execution - Fair access 2. **Transparency** - Open systems - Clear rules - Visible processes - Auditable outcomes 3. **Resistance** - Manipulation prevention - Attack resistance - Capture prevention - Bias elimination ## Implementation 1. **Protocol Design** - Fair mechanisms - Equal access - Clear rules - Transparent execution 2. **Security Features** - Attack prevention - Manipulation resistance - Bias protection - Fairness guarantees 3. **Governance Systems** - Balanced power - Equal rights - Fair processes - Neutral arbitration ## Applications 1. **System Design** - Protocol architecture - Rule creation - Access control - Process implementation 2. **Community Governance** - Decision making - Resource allocation - Conflict resolution - Value distribution 3. **Trust Building** - Fairness demonstration - Trust development - Community confidence - System reliability",
    "difficulty": "intermediate",
    "tags": [
      "governance",
      "fairness",
      "protocols",
      "principles"
    ],
    "weight": 7
  },
  {
    "title": "Degen Value Capture",
    "url": "/wiki/glossary/degen-value-capture/",
    "category": "glossary",
    "summary": "Economic mechanisms that leverage speculative behavior and market dynamics to capture and direct value within web3 ecosystems.",
    "content": "# Degen Value Capture Degen Value Capture represents economic mechanisms that harness speculative market behavior to generate and capture value within web3 ecosystems, which can then be redirected towards sustainable development. ## Core Mechanics 1. **Market Dynamics** - Speculative trading - Price discovery - Liquidity provision - Market making 2. **Value Generation** - Token economics - Trading fees - Market activity - Network effects 3. **Capture Mechanisms** - Protocol fees - Treasury allocation - Value accrual - Revenue streams ## Implementation 1. **Token Design** - Supply mechanics - Distribution model - Utility features - Value accrual 2. **Market Structure** - Trading pairs - Liquidity pools - Price mechanisms - Fee structures 3. **Value Flow** - Revenue capture - Fee distribution - Treasury management - Resource allocation ## Applications 1. **Protocol Revenue** - Trading fees - Protocol fees - Service charges - Value capture 2. **Treasury Growth** - Asset accumulation - Value preservation - Portfolio management - Risk mitigation 3. **Ecosystem Development** - Resource allocation - Infrastructure funding - Development grants - Community rewards",
    "difficulty": "intermediate",
    "tags": [
      "economics",
      "defi",
      "markets",
      "value"
    ],
    "weight": 2
  },
  {
    "title": "DUNA",
    "url": "/wiki/glossary/duna/",
    "category": "glossary",
    "summary": "Decentralized Unincorporated Not-for-profit Association, a Swiss legal structure that operates Common Ground with token-based governance.",
    "content": "# DUNA DUNA (Decentralized Unincorporated Not-for-profit Association) represents Common Ground's legal structure in Switzerland, combining traditional legal frameworks with web3 governance mechanisms. ## Core Components 1. **Legal Structure** - Swiss association - Not-for-profit status - Decentralized operation - Token governance 2. **Governance Model** - Token-based voting - Stakeholder rights - Decision processes - Resource control 3. **Operational Framework** - Development funding - Usage fee collection - Resource allocation - Team management ## Implementation 1. **Legal Framework** - Swiss jurisdiction - Association rules - Compliance measures - Governance structure 2. **Token Integration** - Voting mechanisms - Power distribution - Decision rights - Stakeholder alignment 3. **Operational Systems** - Resource management - Fee collection - Development funding - Team coordination ## Applications 1. **Project Governance** - Decision making - Resource allocation - Development direction - Stakeholder management 2. **Legal Compliance** - Regulatory alignment - Operational framework - Risk management - Stakeholder protection 3. **Ecosystem Development** - Partnership formation - Resource utilization - Growth facilitation - Value creation",
    "difficulty": "intermediate",
    "tags": [
      "legal",
      "governance",
      "organization",
      "structure"
    ],
    "weight": 7
  },
  {
    "title": "Game of Chains",
    "url": "/wiki/glossary/game-of-chains/",
    "category": "glossary",
    "summary": "A framework for understanding how different token distribution mechanisms and community dynamics interact to create diverse forms of coordination and value creation.",
    "content": "# Game of Chains The Game of Chains is a theoretical framework that describes how different token distribution mechanisms and community dynamics interact to create diverse forms of coordination and value creation in web3 ecosystems. ## Core Concepts 1. **Distribution Mechanisms** - Token allocation - Community rewards - Value capture - Incentive design 2. **Community Dynamics** - Social coordination - Value alignment - Participation patterns - Emergent behavior 3. **Game Theory** - Strategic interaction - Nash equilibria - Coordination games - Incentive structures ## Implementation 1. **Token Design** - Distribution models - Incentive structures - Value flows - Governance rights 2. **Community Architecture** - Participation frameworks - Coordination tools - Value systems - Growth mechanisms 3. **Interaction Patterns** - Community formation - Value creation - Resource allocation - Decision making ## Applications 1. **Community Building** - Token distribution - Incentive alignment - Participation design - Growth strategies 2. **Value Creation** - Economic models - Resource allocation - Market dynamics - Network effects 3. **Coordination** - Decision frameworks - Resource management - Collective action - Impact assessment ## Game Dynamics 1. **Player Strategies** - Token accumulation - Community participation - Value creation - Resource allocation 2. **Equilibrium States** - Stable configurations - Value distribution - Community alignment - Sustainable growth 3. **Evolution Patterns** - Community development - Token maturation - Value creation - Ecosystem integration",
    "difficulty": "intermediate",
    "tags": [
      "tokens",
      "game-theory",
      "coordination",
      "distribution"
    ],
    "weight": 4
  },
  {
    "title": "Harberger Tax",
    "url": "/wiki/glossary/harberger-tax/",
    "category": "glossary",
    "summary": "A property rights system where owners self-assess their property's value, pay taxes on that value, and must sell to any buyer willing to pay that price.",
    "content": "# Harberger Tax Harberger Tax represents an innovative property rights system that balances private ownership with public good through continuous self-assessment and taxation. ## Core Principles 1. **Self-Assessment** - Value declaration - Price setting - Market signaling - Ownership costs 2. **Continuous Taxation** - Regular payments - Value-based rates - Public revenue - Resource allocation 3. **Forced Sale** - Market access - Price enforcement - Ownership transfer - Value realization ## Implementation 1. **Economic Design** - Tax rate setting - Value assessment - Market dynamics - Transfer mechanisms 2. **Technical Systems** - Smart contracts - Payment processing - Transfer automation - Value tracking 3. **Governance Framework** - Tax collection - Revenue distribution - Rule enforcement - System maintenance ## Applications 1. **Digital Assets** - Meme ownership - IP rights - Digital property - Content licensing 2. **Resource Allocation** - Efficient use - Market access - Value optimization - Public benefit 3. **Economic Innovation** - Property systems - Value capture - Market design - Social benefit",
    "difficulty": "advanced",
    "tags": [
      "economics",
      "property",
      "taxation",
      "innovation"
    ],
    "weight": 7
  },
  {
    "title": "Hyperobject",
    "url": "/wiki/glossary/hyperobject/",
    "category": "glossary",
    "summary": "Entities massively distributed in time and space that transcend specific localities, making them almost incomprehensible in traditional terms.",
    "content": "# Hyperobject A hyperobject is a concept that describes phenomena or entities that are so massively distributed across time and space that they defy traditional understanding and localization. This term is fundamental to understanding the scale and scope of problems that Common Ground aims to address. ## Characteristics 1. **Scale** - Massive distribution - Temporal extension - Spatial dispersion - System-wide impact 2. **Perception** - Transcends localities - Defies comprehension - System-level effects - Emergent properties 3. **Examples** - Climate change - Global economies - Internet infrastructure - Social movements ## Implications 1. **Problem Solving** - Requires new approaches - Demands coordination - Needs systemic thinking - Requires collective action 2. **System Design** - Distributed architecture - Scalable solutions - Adaptive mechanisms - Resilient structures 3. **Community Impact** - Global coordination - Cross-border collaboration - Collective intelligence - Emergent solutions ## Applications 1. **Coordination** - Multi-stakeholder alignment - Resource allocation - Decision making - Impact measurement 2. **Technology** - Distributed systems - Network effects - Scaling solutions - Integration patterns 3. **Governance** - Collective decision-making - Resource management - Impact assessment - System adaptation",
    "difficulty": "advanced",
    "tags": [
      "theory",
      "concepts",
      "scale"
    ],
    "weight": 1
  },
  {
    "title": "Intent Origination",
    "url": "/wiki/glossary/intent-origination/",
    "category": "glossary",
    "summary": "The process of discovering, creating, and curating user intents in crypto transactions, enabled by chain abstraction, account abstraction, and TEEs.",
    "content": "# Intent Origination Intent Origination represents the future of crypto UX, focusing on how users discover, create, and express their transaction intentions before execution. ## Core Components 1. **Discovery Mechanisms** - User intent identification - Context awareness - Pattern recognition - Opportunity discovery 2. **Creation Tools** - Intent formulation - Parameter specification - Constraint definition - Outcome optimization 3. **Curation Systems** - Intent validation - Quality assessment - Solver matching - Execution optimization ## Implementation 1. **Technical Infrastructure** - Chain abstraction - Account abstraction - TEE integration - Protocol compatibility 2. **User Experience** - Intent expression - Parameter selection - Outcome specification - Solver choice 3. **Platform Integration** - Discovery tools - Creation interfaces - Curation mechanisms - Execution pathways ## Applications 1. **Transaction Design** - Intent specification - Parameter optimization - Outcome definition - Execution planning 2. **User Interaction** - Intent discovery - Creation tools - Curation interfaces - Solver selection 3. **Platform Development** - Tool integration - Interface design - Protocol compatibility - Solver coordination",
    "difficulty": "advanced",
    "tags": [
      "intents",
      "ux",
      "transactions",
      "discovery"
    ],
    "weight": 8
  },
  {
    "title": "Memecoin",
    "url": "/wiki/glossary/memecoin/",
    "category": "glossary",
    "summary": "A Community Token that attempts to coordinate a community around a common goal through memetic value and social dynamics.",
    "content": "# Memecoin A memecoin is a specific type of Community Token that leverages memetic value and social dynamics to coordinate community action around shared goals. In the context of Common Ground, memecoins play a crucial role in the Game of Chains. ## Core Concepts 1. **Memetic Value** - Cultural resonance - Social virality - Community engagement - Narrative power 2. **Coordination Mechanism** - Goal alignment - Community building - Value creation - Social dynamics 3. **Token Dynamics** - Distribution methods - Value capture - Community rewards - Growth incentives ## Implementation 1. **Community Building** - Social engagement - Value alignment - Participation incentives - Growth mechanisms 2. **Token Distribution** - Fair launch - Community mining - Social rewards - Activity incentives 3. **Value Creation** - Memetic spread - Community growth - Network effects - Utility development ## Applications 1. **Ecosystem Growth** - Community expansion - Protocol adoption - Value alignment - Network building 2. **Social Coordination** - Goal setting - Resource allocation - Action coordination - Impact measurement 3. **Value Evolution** - Token maturation - Utility development - Ecosystem integration - Governance implementation ## Example: $DEGEN 1. **Initial Phase** - Community points - Social engagement - Activity tracking - Value recognition 2. **Evolution** - Token conversion - Utility expansion - Ecosystem integration - Governance development 3. **Impact** - Community growth - Value creation - Protocol development - Ecosystem expansion",
    "difficulty": "beginner",
    "tags": [
      "tokens",
      "memes",
      "community",
      "coordination"
    ],
    "weight": 3
  },
  {
    "title": "Regen Value Redistribution",
    "url": "/wiki/glossary/regen-value-redistribution/",
    "category": "glossary",
    "summary": "Sustainable mechanisms for redistributing captured value to support ecosystem development, public goods, and community growth.",
    "content": "# Regen Value Redistribution Regen Value Redistribution encompasses the sustainable mechanisms and practices for redistributing captured value to support long-term ecosystem development, public goods funding, and community growth. ## Core Principles 1. **Sustainability** - Long-term viability - Resource preservation - Ecosystem health - Community benefit 2. **Value Distribution** - Fair allocation - Public goods funding - Community support - Development grants 3. **Impact Focus** - Measurable outcomes - Social benefit - Environmental impact - Community growth ## Implementation 1. **Distribution Mechanisms** - Grant programs - Impact funding - Community rewards - Development support 2. **Governance Systems** - Resource allocation - Decision making - Impact assessment - Community input 3. **Impact Measurement** - Success metrics - Progress tracking - Value assessment - Outcome evaluation ## Applications 1. **Ecosystem Support** - Infrastructure funding - Protocol development - Community building - Resource allocation 2. **Public Goods** - Research funding - Tool development - Education programs - Community resources 3. **Community Development** - Skill building - Knowledge sharing - Resource access - Growth support",
    "difficulty": "intermediate",
    "tags": [
      "economics",
      "sustainability",
      "community",
      "value"
    ],
    "weight": 3
  },
  {
    "title": "SCE",
    "url": "/wiki/glossary/sce/",
    "category": "glossary",
    "summary": "A transnational European Cooperative Society legal structure that will operate Common Ground with a one-member-one-vote governance model.",
    "content": "# SCE (European Cooperative Society) The European Cooperative Society (SCE) represents Common Ground's future cooperative legal structure, designed to enable true user ownership and democratic governance. ## Core Characteristics 1. **Legal Framework** - EU jurisdiction - Cooperative structure - Transnational operation - Democratic governance 2. **Governance Model** - One-member-one-vote - User ownership - Participatory decision-making - Community control 3. **Operational Structure** - Platform operations - Resource management - Community engagement - Value distribution ## Implementation 1. **Legal Design** - EU regulations - Cooperative laws - Member rights - Governance rules 2. **Membership System** - User participation - Voting rights - Resource access - Value sharing 3. **Operational Framework** - Platform management - Resource allocation - Community development - Value creation ## Applications 1. **Platform Governance** - Democratic control - Resource management - Development direction - Community empowerment 2. **User Ownership** - Participation rights - Value distribution - Decision making - Resource control 3. **Ecosystem Development** - Community building - Value creation - Sustainable growth - Innovation fostering",
    "difficulty": "intermediate",
    "tags": [
      "legal",
      "governance",
      "cooperative",
      "organization"
    ],
    "weight": 7
  },
  {
    "title": "Smart Contract Standards",
    "url": "/wiki/glossary/smart-contract-standards/",
    "category": "glossary",
    "summary": "Standardized protocols and interfaces for smart contracts that enable interoperability, security, and consistent functionality across blockchain ecosystems.",
    "content": "# Smart Contract Standards Smart Contract Standards define the common protocols and interfaces that enable secure, interoperable, and consistent functionality across blockchain ecosystems and applications. ## Core Standards 1. **Wallet Standards** - Multisig implementations - Account abstraction - Recovery mechanisms - Access controls 2. **Governance Standards** - Voting systems - Proposal mechanisms - Execution frameworks - Role management 3. **Token Standards** - Fungible tokens - Non-fungible tokens - Semi-fungible tokens - Token interfaces ## Implementation 1. **Technical Specifications** - Interface definitions - Function signatures - Event specifications - State management 2. **Security Features** - Access control - Permission systems - Validation checks - Safety mechanisms 3. **Integration Points** - Protocol compatibility - Standard interfaces - Extension patterns - Upgrade paths ## Applications 1. **Community Infrastructure** - Governance systems - Treasury management - Role assignment - Resource control 2. **Protocol Development** - Standard compliance - Feature implementation - Security patterns - Integration methods 3. **Ecosystem Growth** - Interoperability - Composability - Innovation - Adoption",
    "difficulty": "intermediate",
    "tags": [
      "technical",
      "standards",
      "smart-contracts",
      "infrastructure"
    ],
    "weight": 5
  },
  {
    "title": "Spark",
    "url": "/wiki/glossary/spark/",
    "category": "glossary",
    "summary": "Common Ground's platform currency used for pro features and visibility, serving as a staking reward for $CG token holders and an alternative payment method for interface fees.",
    "content": "# Spark Spark is Common Ground's native platform currency, designed to facilitate value exchange and reward participation within the ecosystem. ## Core Functions 1. **Platform Currency** - Pro feature access - Visibility enhancement - Fee payment - Value exchange 2. **Reward Mechanism** - Staking rewards - Participation incentives - Community engagement - Value distribution 3. **Payment System** - Interface fees - Feature access - Service payments - Platform transactions ## Implementation 1. **Economic Design** - Value flows - Reward distribution - Payment processing - Balance management 2. **Platform Integration** - Feature access - Payment systems - Reward mechanisms - User interface 3. **Utility Framework** - Service access - Feature unlocking - Value transfer - Reward distribution ## Applications 1. **Platform Features** - Pro access - Enhanced visibility - Premium services - Special functions 2. **Reward Systems** - Staking benefits - Participation rewards - Community incentives - Value sharing 3. **Economic Functions** - Payment processing - Value transfer - Service access - Feature unlocking",
    "difficulty": "beginner",
    "tags": [
      "currency",
      "rewards",
      "staking",
      "platform"
    ],
    "weight": 6
  },
  {
    "title": "Zero-Friction Onboarding",
    "url": "/wiki/glossary/zero-friction-onboarding/",
    "category": "glossary",
    "summary": "A user experience paradigm that eliminates traditional web3 barriers through passkeys, smart wallets, and optimized authentication flows.",
    "content": "# Zero-Friction Onboarding Zero-Friction Onboarding represents a modern approach to web3 user experience that eliminates traditional barriers to entry through advanced authentication methods and optimized user flows. ## Core Components 1. **Authentication** - Passkey integration - Biometric verification - Smart wallet creation - Account recovery 2. **Technical Infrastructure** - Gas relayers - Account abstraction - Fiat onramps - Transaction optimization 3. **User Experience** - One-click flows - Progressive disclosure - Intuitive interfaces - Error prevention ## Implementation 1. **Authentication Layer** - Passkey standards - Biometric systems - Recovery mechanisms - Security protocols 2. **Infrastructure Layer** - Gas management - Transaction routing - Account creation - State management 3. **Experience Layer** - Interface design - Flow optimization - Error handling - User guidance ## Benefits 1. **User Adoption** - Reduced barriers - Faster onboarding - Higher retention - Better experience 2. **Technical Efficiency** - Optimized costs - Improved performance - Reliable systems - Scalable infrastructure 3. **Community Growth** - Easier access - Broader reach - Better engagement - Sustained participation",
    "difficulty": "beginner",
    "tags": [
      "ux",
      "onboarding",
      "authentication",
      "adoption"
    ],
    "weight": 4
  },
  {
    "title": "Degen Value Capture",
    "url": "/wiki/mechanics/degen-value-capture/",
    "category": "mechanics",
    "summary": "A mechanism for capturing and distributing value through speculative market dynamics and community engagement in web3 ecosystems.",
    "content": "# Degen Value Capture Degen Value Capture represents a set of mechanisms designed to harness speculative market dynamics and community engagement to generate and distribute value within web3 ecosystems. ## Core Concepts 1. **Market Dynamics** - Price discovery - Liquidity provision - Trading incentives - Market making 2. **Community Engagement** - Participation rewards - Staking mechanisms - Trading activities - Yield generation 3. **Value Distribution** - Token allocation - Reward systems - Fee structures - Incentive alignment ## Implementation 1. **Token Mechanics** - Distribution models - Vesting schedules - Lock-up periods - Trading pairs 2. **Market Infrastructure** - Exchange listings - Liquidity pools - Trading interfaces - Price oracles 3. **Incentive Design** - Reward structures - Staking benefits - Trading rewards - Participation bonuses ## Applications 1. **Community Building** - Token distribution - Engagement rewards - Community incentives - Value sharing 2. **Market Operations** - Trading activities - Liquidity provision - Price stabilization - Market making 3. **Value Creation** - Asset appreciation - Yield generation - Fee collection - Treasury growth ## Risk Management 1. **Market Risks** - Volatility management - Liquidity monitoring - Price stability - Market manipulation 2. **Community Risks** - Token concentration - Participation balance - Incentive alignment - Sustainability 3. **Operational Risks** - Smart contract security - Oracle reliability - Market infrastructure - Regulatory compliance",
    "difficulty": "intermediate",
    "tags": [
      "economics",
      "tokenomics",
      "markets",
      "speculation"
    ],
    "weight": 1
  },
  {
    "title": "Regen Value Redistribution",
    "url": "/wiki/mechanics/regen-value-redistribution/",
    "category": "mechanics",
    "summary": "A mechanism for sustainably redistributing captured value to support public goods, community development, and long-term ecosystem health.",
    "content": "# Regen Value Redistribution Regen Value Redistribution represents a sustainable approach to allocating captured value within web3 ecosystems, focusing on public goods funding, community development, and long-term sustainability. ## Core Concepts 1. **Value Allocation** - Public goods funding - Community development - Ecosystem sustainability - Impact measurement 2. **Distribution Mechanisms** - Quadratic funding - Impact certificates - Community grants - Retroactive funding 3. **Sustainability Focus** - Long-term alignment - Resource preservation - Community health - Ecosystem balance ## Implementation 1. **Funding Mechanisms** - Grant programs - Impact markets - Community pools - Development funds 2. **Distribution Systems** - Allocation frameworks - Impact assessment - Value tracking - Reward distribution 3. **Governance Structure** - Decision making - Proposal systems - Community input - Impact evaluation ## Applications 1. **Public Goods** - Infrastructure funding - Research support - Education initiatives - Community resources 2. **Community Development** - Skill building - Resource allocation - Capacity expansion - Knowledge sharing 3. **Ecosystem Health** - Sustainability programs - Resource management - Impact assessment - Value circulation ## Impact Measurement 1. **Metrics Framework** - Impact indicators - Success measures - Value assessment - Progress tracking 2. **Evaluation Systems** - Quality assessment - Impact verification - Value validation - Progress monitoring 3. **Feedback Loops** - Community input - Impact adjustment - Program refinement - Strategy adaptation",
    "difficulty": "intermediate",
    "tags": [
      "sustainability",
      "public-goods",
      "redistribution",
      "community"
    ],
    "weight": 2
  },
  {
    "title": "AI Hiveminds",
    "url": "/wiki/primitives/ai-hiveminds/",
    "category": "primitives",
    "summary": "Decentralized networks of AI agents that collaborate with human communities to enhance coordination and decision-making capabilities.",
    "content": "# AI Hiveminds AI Hiveminds represent a revolutionary approach to community coordination through decentralized networks of AI agents that collaborate with human communities to enhance collective intelligence and decision-making capabilities. ## Core Components 1. **Agent Networks** - Distributed AI systems - Coordination protocols - Task allocation - Resource management 2. **Human Integration** - Interface design - Interaction models - Feedback loops - Trust building 3. **Collective Intelligence** - Knowledge synthesis - Pattern recognition - Decision support - Learning systems ## Implementation 1. **Technical Architecture** - Agent frameworks - Communication protocols - Data structures - Integration APIs 2. **Coordination Mechanisms** - Task distribution - Resource allocation - Decision processes - Consensus building 3. **Learning Systems** - Knowledge capture - Pattern analysis - Model adaptation - Performance optimization ## Applications 1. **Community Support** - Decision assistance - Resource optimization - Knowledge management - Process automation 2. **Coordination Enhancement** - Task coordination - Resource allocation - Goal alignment - Impact assessment 3. **Knowledge Systems** - Information synthesis - Pattern recognition - Insight generation - Learning optimization",
    "difficulty": "advanced",
    "tags": [
      "ai",
      "coordination",
      "intelligence",
      "community"
    ],
    "weight": 7
  },
  {
    "title": "Community Token",
    "url": "/wiki/primitives/community-token/",
    "category": "primitives",
    "summary": "A tokenized representation of community value and participation that enables governance, incentive alignment, and resource allocation.",
    "content": "# Community Token Community Tokens serve as the economic and governance backbone of web3 communities, enabling value alignment, participation incentives, and resource allocation through sophisticated token mechanics. ## Core Functions 1. **Value Representation** - Community ownership - Participation rights - Resource claims - Governance power 2. **Economic Mechanics** - Value capture - Resource allocation - Incentive design - Market dynamics 3. **Governance Tools** - Voting rights - Proposal power - Decision weight - Stake-based influence ## Implementation 1. **Token Design** - Supply mechanics - Distribution model - Utility features - Governance rights 2. **Economic Model** - Value accrual - Fee structures - Reward systems - Market mechanisms 3. **Integration Points** - Governance systems - Treasury management - Community roles - Resource allocation ## Applications 1. **Community Governance** - Decision making - Resource allocation - Proposal creation - Vote weighting 2. **Economic Alignment** - Value distribution - Incentive design - Market creation - Resource optimization 3. **Participation Incentives** - Contribution rewards - Engagement bonuses - Loyalty programs - Stake-based benefits",
    "difficulty": "intermediate",
    "tags": [
      "token",
      "economics",
      "governance",
      "community"
    ],
    "weight": 3
  },
  {
    "title": "Discourse Graphs",
    "url": "/wiki/primitives/discourse-graphs/",
    "category": "primitives",
    "summary": "A structured data format for mapping conversations and viewpoints across communities, enabling collective sensemaking and coordination.",
    "content": "# Discourse Graphs Discourse Graphs provide a structured approach to mapping and analyzing conversations and viewpoints across decentralized communities. They enable collective sensemaking and coordinated problem-solving through standardized data structures. ## Core Concepts 1. **Structured Mapping** - Conversation tracking - Viewpoint identification - Relationship mapping - Pattern recognition 2. **Sensemaking Tools** - Convergence analysis - Divergence tracking - Consensus building - Knowledge synthesis 3. **Coordination Framework** - Cross-community dialogue - Viewpoint alignment - Action coordination - Resource allocation ## Technical Implementation 1. **Data Structure** - Graph schema - Node types - Edge relationships - Metadata framework 2. **Analysis Tools** - Pattern detection - Sentiment analysis - Consensus tracking - Impact measurement 3. **Integration Layer** - Community systems - Communication tools - Knowledge bases - Decision frameworks ## Applications 1. **Community Coordination** - Discussion mapping - Decision tracking - Consensus building - Action planning 2. **Knowledge Management** - Information organization - Context preservation - Relationship mapping - Knowledge discovery 3. **Problem Solving** - Issue identification - Solution development - Impact assessment - Implementation tracking ## Features 1. **Visualization** - Graph rendering - Relationship display - Pattern highlighting - Interactive exploration 2. **Analysis Tools** - Trend detection - Sentiment tracking - Influence mapping - Impact assessment 3. **Integration Points** - Community platforms - Knowledge bases - Decision systems - Action frameworks",
    "difficulty": "advanced",
    "tags": [
      "sensemaking",
      "coordination",
      "knowledge",
      "communication"
    ],
    "weight": 6
  },
  {
    "title": "Ecosystem",
    "url": "/wiki/primitives/ecosystem/",
    "category": "primitives",
    "summary": "A gateway for broader adoption that acts as a Schelling Point for communities, providing infrastructure, funding, and coordination resources.",
    "content": "# Ecosystem An Ecosystem in Common Ground represents a comprehensive infrastructure layer that supports community development, token deployment, and user onboarding. It serves as a coordination point for communities and provides essential resources for growth. ## Core Functions 1. **Infrastructure Provision** - Blockchain networks - Identity systems - Smart contract platforms - Scaling solutions 2. **Community Support** - Grant programs - Gas sponsorship - Technical resources - Growth initiatives 3. **Coordination Services** - Community outreach - User acquisition - Resource allocation - Network effects ## Technical Infrastructure 1. **Blockchain Layer** - Layer 1 networks - Layer 2 solutions - Layer n scaling - Cross-chain bridges 2. **Identity Stack** - Passport deployment - Chain-specific identities - Verification systems - Social graph integration 3. **Development Tools** - Smart contract frameworks - Development SDKs - Testing environments - Deployment tools ## Community Integration 1. **Onboarding Process** - Community deployment - Token integration - Resource allocation - User acquisition 2. **Resource Management** - Grant distribution - Gas optimization - Infrastructure access - Technical support 3. **Growth Support** - Marketing resources - Community building - Network expansion - Value creation ## Applications 1. **Builder Support** - Distribution channels - Active communities - Engagement metrics - Reward systems 2. **User Benefits** - Cross-community access - Seamless communication - Resource sharing - Value alignment 3. **Ecosystem Development** - Protocol standards - Market infrastructure - Technical innovation - Community growth",
    "difficulty": "advanced",
    "tags": [
      "infrastructure",
      "blockchain",
      "scaling",
      "coordination"
    ],
    "weight": 4
  },
  {
    "title": "Hypercerts",
    "url": "/wiki/primitives/hypercerts/",
    "category": "primitives",
    "summary": "A standardized format for representing and tracking impact claims, enabling the creation of impact markets and value attribution systems.",
    "content": "# Hypercerts Hypercerts represent a breakthrough in impact tracking and value attribution, providing a standardized format for representing, verifying, and trading impact claims in web3 ecosystems. ## Core Features 1. **Impact Claims** - Standardized format - Verifiable metrics - Attribution tracking - Value assessment 2. **Market Mechanisms** - Impact trading - Value discovery - Price formation - Market liquidity 3. **Integration Points** - Community systems - Token economies - Governance frameworks - Value networks ## Implementation 1. **Technical Standards** - Data schema - Smart contracts - Integration APIs - Verification protocols 2. **Market Infrastructure** - Trading platforms - Price discovery - Liquidity provision - Settlement systems 3. **Governance Framework** - Claim verification - Dispute resolution - Standard setting - Protocol updates ## Applications 1. **Impact Markets** - Value attribution - Impact trading - Market making - Price discovery 2. **Community Integration** - Value tracking - Resource allocation - Impact assessment - Reward distribution 3. **Ecosystem Development** - Market creation - Value networks - Protocol integration - Standard adoption",
    "difficulty": "advanced",
    "tags": [
      "impact",
      "coordination",
      "value",
      "markets"
    ],
    "weight": 5
  },
  {
    "title": "Onchain Community",
    "url": "/wiki/primitives/onchain-community/",
    "category": "primitives",
    "summary": "A web3-native community structure with integrated governance, treasury, and role management capabilities built on smart contract primitives.",
    "content": "# Onchain Community Onchain Communities represent web3-native organizational structures that leverage smart contract primitives to enable sophisticated governance, treasury management, and role-based coordination. ## Core Components 1. **Governance System** - Proposal mechanisms - Voting systems - Decision execution - Role management 2. **Treasury Management** - Asset control - Resource allocation - Spending policies - Financial tracking 3. **Role Framework** - Access control - Permission management - Responsibility definition - Task allocation ## Implementation 1. **Smart Contracts** - Governance logic - Treasury controls - Role definitions - Access management 2. **Integration Points** - Identity systems - Token mechanisms - Voting protocols - Resource management 3. **Security Features** - Access controls - Transaction signing - Multi-signature - Time locks ## Applications 1. **Community Operations** - Member management - Resource allocation - Decision making - Task coordination 2. **Resource Management** - Asset allocation - Budget control - Expense tracking - Investment decisions 3. **Governance Activities** - Proposal creation - Voting processes - Implementation tracking - Impact assessment",
    "difficulty": "intermediate",
    "tags": [
      "community",
      "governance",
      "web3",
      "organization"
    ],
    "weight": 2
  },
  {
    "title": "Passport",
    "url": "/wiki/primitives/passport/",
    "category": "primitives",
    "summary": "A composite primitive combining passkeys, smart wallets, and verified identities to create a unified web3 identity and authentication system.",
    "content": "# Passport The Common Ground Passport (CG Passport) is a foundational primitive that combines multiple web3 technologies to create a unified identity and authentication system. It serves as the user's primary interface with the Common Ground ecosystem. ## Core Components 1. **Authentication System** - Passkey integration - Biometric verification - Device-based security - Cross-platform support 2. **Smart Wallet Infrastructure** - Personal SAFE wallet - Ecosystem chain deployment - Upgradable signing contracts - Gas relayer services 3. **Identity Verification** - Onchain identity integration - Farcaster - Lens - Universal Profile - Social graph import - PFP display - Trust markers ## Features 1. **Authentication Capabilities** - App login - Transaction signing - Proof generation - Cross-platform verification 2. **Asset Management** - Send/receive functionality - Multi-chain support - Asset viewing - Transaction history 3. **Identity Management** - Verified identity aggregation - Trust marker collection - Reputation building - Social graph integration ## Technical Implementation 1. **Wallet Architecture** - SAFE contract deployment - RIP7212 compatibility - Upgradable contracts - Multi-chain support 2. **Authentication Flow** - Passkey registration - Biometric verification - Device management - Recovery mechanisms 3. **Identity Integration** - Protocol connections - Verification systems - Data aggregation - Privacy controls ## Applications 1. **User Onboarding** - Zero-friction signup - Identity verification - Wallet creation - Ecosystem integration 2. **Community Access** - Role verification - Permission management - Trust establishment - Community participation 3. **Asset Operations** - Transaction execution - Asset transfer - Contract interaction - Gas management",
    "difficulty": "beginner",
    "tags": [
      "identity",
      "authentication",
      "wallet",
      "verification"
    ],
    "weight": 1
  },
  {
    "title": "Subjectivocracy",
    "url": "/wiki/primitives/subjectivocracy/",
    "category": "primitives",
    "summary": "A conceptual framework that leverages subjective decision-making at the boundaries of objective systems to enhance resilience and adaptability.",
    "content": "# Subjectivocracy Subjectivocracy represents a novel approach to governance and decision-making that strategically incorporates subjective human judgment to complement and enhance objective systems. ## Core Concepts 1. **Subjective Decision-Making** - Human judgment - Context awareness - Value consideration - Adaptive reasoning 2. **System Boundaries** - Interface definition - Integration points - Transition zones - Interaction models 3. **Resilience Enhancement** - Vulnerability mitigation - Adaptability increase - System flexibility - Error correction ## Applications 1. **Oracle Systems** - Data validation - Truth verification - Context interpretation - Value judgment 2. **Dispute Resolution** - Conflict mediation - Solution finding - Fairness assessment - Context consideration 3. **Work Evaluation** - Quality assessment - Value determination - Impact measurement - Contribution rating ## Implementation 1. **Framework Design** - Decision boundaries - Integration points - Process flows - Feedback loops 2. **Governance Mechanisms** - Decision protocols - Voting systems - Consensus building - Dispute handling 3. **System Integration** - Objective interfaces - Subjective inputs - Process coordination - Outcome validation ## Benefits 1. **System Enhancement** - Flexibility increase - Adaptability improvement - Resilience building - Error reduction 2. **Decision Quality** - Context consideration - Value alignment - Fairness improvement - Outcome optimization 3. **Community Impact** - Trust building - Participation increase - Engagement enhancement - Satisfaction improvement",
    "difficulty": "advanced",
    "tags": [
      "governance",
      "decision-making",
      "subjectivity",
      "resilience"
    ],
    "weight": 8
  }
]
</file>

<file path="site.webmanifest">
{"name":"","short_name":"","icons":[{"src":"/android-chrome-192x192.png","sizes":"192x192","type":"image/png"},{"src":"/android-chrome-512x512.png","sizes":"512x512","type":"image/png"}],"theme_color":"#ffffff","background_color":"#ffffff","display":"standalone"}
</file>

</files>
